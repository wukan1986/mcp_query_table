const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["./CdUQ4k_6.js", "./BWxz71CD.js", "./CmqY7iL4.js", "./swiper-vue.DrL5u-mu.css", "./inline-loading.CZ_kLEde.css", "./_id_.piwSNkKs.css", "./CU8OBk3R.js", "./1MQqg9KZ.js", "./C8kL_wtD.js", "./d4ehk0MD.js", "./DsQhMveg.js", "./qlOlbA_A.js", "./C7x-xCHw.js", "./B6YRAGrs.js", "./el-scrollbar.CCursvKC.css", "./BMIs6A25.js", "./el-popover.Cktl5fHm.css", "./Bn1S7hW0.js", "./B56i8gE6.js", "./el-dialog.DlGDtvr8.css", "./DeOF71Qi.js", "./C7IldxpR.js", "./CWdx7vn2.js", "./DeB6DOwF.js", "./el-date-picker.OYqEYO72.css", "./YWXbGMGf.js", "./C6mKmy5I.js", "./eRFhyQY-.js", "./DGhY9PTQ.js", "./BE6BSbpE.js", "./LP10ytXF.js", "./empty.BxfpAwCe.css", "./Cc20FnIx.js", "./C3awZUOW.js", "./useXsLoading.C5IeuJ3V.css", "./B3rJLzZx.js", "./DNryu08g.js", "./C1hXAUa2.js", "./BAp9JRVq.js", "./el-tag.DljBBxJR.css", "./Bw3IBBUH.js", "./BycYZHbh.js", "./el-checkbox.Bmnw1Znx.css", "./el-table.C3Iu1Mh_.css", "./charts.client.Dk3fjMuI.css", "./FNsQSe8M.js", "./qrcode.D6nqNSjs.css", "./CdMP1jd3.js", "./3masWBSD.js", "./CjlobkDd.js", "./detail.BN25t67t.css", "./PgckAxYC.js", "./lq4bXooV.js", "./DTAjFpME.js", "./BJqo8wzm.js", "./BX1QRgds.js", "./wx-service-dialog.947ohaE2.css", "./hot-recent.DxrEDg_e.css", "./C5KJvZhm.js", "./base.DcwZCcDd.css", "./CQI8Qxnh.js", "./list.BOu5vDe4.css", "./sDXetOXF.js", "./rY-FUFEX.js", "./Dtgdq2VE.js", "./sidebar-chat.nhqBdmD8.css", "./_id_.BcspUdkd.css", "./BUdQuuf9.js", "./BH67grfC.js", "./CVlBT9zP.js", "./DQzxyDy_.js", "./D3jte0DN.js", "./BRt1oO4t.js", "./BoplQBa3.js", "./comparison.yRGMaCrW.css", "./BfjFKN33.js", "./CMEmzuFt.js", "./ZfYwl-Ta.js", "./DBsN5LVO.js", "./el.DVaYIJ8q.css", "./el-pagination.DIzD0XMV.css", "./rank-header.BR5jlYqI.css", "./DIzleTaG.js", "./DN3NlWfb.js", "./el-radio-group.BMT_05zM.css", "./9HeOtYet.js", "./channel-introduction.DaBVyzuT.css", "./el-checkbox-group.D_6SYB2i.css", "./_conditionStr_.Dl8T-lMt.css", "./nNW3gU2p.js", "./B9nvX9hu.js", "./lqXCKu2T.js", "./CwSLQaDD.js", "./Br7XJgPN.js", "./rank.BdBw2tfk.css", "./Dxjt-ewS.js", "./smph-page.C_Q0m2gh.css", "./C87toilZ.js", "./_conditionStr_.BU-osdop.css", "./Dz_D3GaN.js", "./_conditionStr_.Bi77psCB.css", "./JGmMoj3g.js", "./DXAZ3o89.js", "./company.Bh238GGy.css", "./d6IJZqUx.js", "./Dl2GgYW-.js", "./index.BUKeMSdH.css", "./CLit5r1o.js", "./U8aCHacY.js", "./el-divider.BUtF_RGI.css", "./DboTyCCj.js", "./_id_.OaJ71j-z.css", "./Ar2nHDFq.js", "./CpzqOiG9.js", "./_conditionStr_.Btj1umxS.css", "./CQrvD4o0.js", "./CXHl9Kcr.js", "./DILW8-Rj.js", "./DuAS-52M.js", "./CSM9R8yG.js", "./x_rD_Ya3.js", "./default.DRjiCFx2.css", "./YsuGZQKX.js", "./qjhiAhXC.js", "./CTPfC6uf.js", "./DIVKPZLC.js", "./login.vWJsl2VE.css", "./D9dRy5ZG.js", "./index.mCRKDcHd.css", "./BaxF9V-l.js", "./DFv6WNOT.js", "./appointment.B3sxMAZk.css", "./BdXMsUsu.js", "./Bk2rD15r.js", "./copy2favor.MTC3-mBF.css", "./CqhE9Pb7.js", "./P2P-apply.CXjX0agP.css", "./Dslga1CL.js", "./import-fund.C3r00Q0c.css", "./GcsWccdl.js", "./index.h6ElHE6k.css", "./CKKMvVcK.js", "./index.C_QEItIn.css"]))) => i.map(i => d[i]);
var pe = Object.defineProperty;
var he = (e, t, r) => t in e ? pe(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r;
var ne = (e, t, r) => he(e, typeof t != "symbol" ? t + "" : t, r);
import {e as effectScope, s as shallowReactive, r as reactive, g as getCurrentScope, h as hasInjectionContext, a as getCurrentInstance, i as inject, t as toRef, b as ref, m as markRaw, w as watch, c as isRef, d as isReactive, f as toRaw, o as onScopeDispose, n as nextTick, j as toRefs, k as computed, u as unref, v as version, l as watchEffect, p as onBeforeUnmount, q as onDeactivated, x as onActivated, y as shallowRef, z as defineComponent, A as h, B as provide, K as KeepAlive, C as readonly, D as onMounted, E as onUnmounted, F as isReadonly, G as customRef, H as resolveComponent, I as defineAsyncComponent, J as openBlock, L as createElementBlock, M as createBaseVNode, N as warn, O as renderSlot, P as createVNode, Q as withCtx, R as withDirectives, S as normalizeClass, T as normalizeStyle, U as toDisplayString, V as vShow, W as Transition, X as mergeProps, Y as createBlock, Z as createCommentVNode, _ as resolveDynamicComponent, $ as Fragment, a0 as withModifiers, a1 as isVNode, a2 as render, a3 as useAttrs$1, a4 as useSlots, a5 as Text, a6 as withKeys, a7 as createTextVNode, a8 as createApp, a9 as toValue$1, aa as Suspense, ab as resolveDirective, ac as onErrorCaptured, ad as createSSRApp} from "./CmqY7iL4.js";
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype"in t) {
        warnKeyDropped(e);
        return
    }
    return t
}
function warnKeyDropped(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function destr(e, t={}) {
    if (typeof e != "string")
        return e;
    const r = e.trim();
    if (e[0] === '"' && e.endsWith('"') && !e.includes("\\"))
        return r.slice(1, -1);
    if (r.length <= 9) {
        const n = r.toLowerCase();
        if (n === "true")
            return !0;
        if (n === "false")
            return !1;
        if (n === "undefined")
            return;
        if (n === "null")
            return null;
        if (n === "nan")
            return Number.NaN;
        if (n === "infinity")
            return Number.POSITIVE_INFINITY;
        if (n === "-infinity")
            return Number.NEGATIVE_INFINITY
    }
    if (!JsonSigRx.test(e)) {
        if (t.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return e
    }
    try {
        if (suspectProtoRx.test(e) || suspectConstructorRx.test(e)) {
            if (t.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(e, jsonParseTransform)
        }
        return JSON.parse(e)
    } catch (n) {
        if (t.strict)
            throw n;
        return e
    }
}
const HASH_RE$1 = /#/g
  , AMPERSAND_RE$1 = /&/g
  , SLASH_RE$1 = /\//g
  , EQUAL_RE$1 = /=/g
  , PLUS_RE$1 = /\+/g
  , ENC_CARET_RE$1 = /%5e/gi
  , ENC_BACKTICK_RE$1 = /%60/gi
  , ENC_PIPE_RE$1 = /%7c/gi
  , ENC_SPACE_RE$1 = /%20/gi;
function encode$2(e) {
    return encodeURI("" + e).replace(ENC_PIPE_RE$1, "|")
}
function encodeQueryValue$1(e) {
    return encode$2(typeof e == "string" ? e : JSON.stringify(e)).replace(PLUS_RE$1, "%2B").replace(ENC_SPACE_RE$1, "+").replace(HASH_RE$1, "%23").replace(AMPERSAND_RE$1, "%26").replace(ENC_BACKTICK_RE$1, "`").replace(ENC_CARET_RE$1, "^").replace(SLASH_RE$1, "%2F")
}
function encodeQueryKey$1(e) {
    return encodeQueryValue$1(e).replace(EQUAL_RE$1, "%3D")
}
function decode$3(e="") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}
function decodeQueryKey(e) {
    return decode$3(e.replace(PLUS_RE$1, " "))
}
function decodeQueryValue(e) {
    return decode$3(e.replace(PLUS_RE$1, " "))
}
function parseQuery$1(e="") {
    const t = {};
    e[0] === "?" && (e = e.slice(1));
    for (const r of e.split("&")) {
        const n = r.match(/([^=]+)=?(.*)/) || [];
        if (n.length < 2)
            continue;
        const o = decodeQueryKey(n[1]);
        if (o === "__proto__" || o === "constructor")
            continue;
        const a = decodeQueryValue(n[2] || "");
        t[o] === void 0 ? t[o] = a : Array.isArray(t[o]) ? t[o].push(a) : t[o] = [t[o], a]
    }
    return t
}
function encodeQueryItem(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)),
    t ? Array.isArray(t) ? t.map(r => `${encodeQueryKey$1(e)}=${encodeQueryValue$1(r)}`).join("&") : `${encodeQueryKey$1(e)}=${encodeQueryValue$1(t)}` : encodeQueryKey$1(e)
}
function stringifyQuery$1(e) {
    return Object.keys(e).filter(t => e[t] !== void 0).map(t => encodeQueryItem(t, e[t])).filter(Boolean).join("&")
}
const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
  , PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
  , PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/
  , PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i
  , TRAILING_SLASH_RE$1 = /\/$|\/\?|\/#/
  , JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(e, t={}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }),
    t.strict ? PROTOCOL_STRICT_REGEX.test(e) : PROTOCOL_REGEX.test(e) || (t.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(e) : !1)
}
function isScriptProtocol(e) {
    return !!e && PROTOCOL_SCRIPT_RE.test(e)
}
function hasTrailingSlash(e="", t) {
    return t ? TRAILING_SLASH_RE$1.test(e) : e.endsWith("/")
}
function withoutTrailingSlash(e="", t) {
    if (!t)
        return (hasTrailingSlash(e) ? e.slice(0, -1) : e) || "/";
    if (!hasTrailingSlash(e, !0))
        return e || "/";
    let r = e
      , n = "";
    const o = e.indexOf("#");
    o >= 0 && (r = e.slice(0, o),
    n = e.slice(o));
    const [a,...s] = r.split("?");
    return ((a.endsWith("/") ? a.slice(0, -1) : a) || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + n
}
function withTrailingSlash(e="", t) {
    if (!t)
        return e.endsWith("/") ? e : e + "/";
    if (hasTrailingSlash(e, !0))
        return e || "/";
    let r = e
      , n = "";
    const o = e.indexOf("#");
    if (o >= 0 && (r = e.slice(0, o),
    n = e.slice(o),
    !r))
        return n;
    const [a,...s] = r.split("?");
    return a + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + n
}
function hasLeadingSlash(e="") {
    return e.startsWith("/")
}
function withLeadingSlash(e="") {
    return hasLeadingSlash(e) ? e : "/" + e
}
function withBase(e, t) {
    if (isEmptyURL(t) || hasProtocol(e))
        return e;
    const r = withoutTrailingSlash(t);
    return e.startsWith(r) ? e : joinURL(r, e)
}
function withoutBase(e, t) {
    if (isEmptyURL(t))
        return e;
    const r = withoutTrailingSlash(t);
    if (!e.startsWith(r))
        return e;
    const n = e.slice(r.length);
    return n[0] === "/" ? n : "/" + n
}
function withQuery(e, t) {
    const r = parseURL$1(e)
      , n = {
        ...parseQuery$1(r.search),
        ...t
    };
    return r.search = stringifyQuery$1(n),
    stringifyParsedURL(r)
}
function isEmptyURL(e) {
    return !e || e === "/"
}
function isNonEmptyURL(e) {
    return e && e !== "/"
}
function joinURL(e, ...t) {
    let r = e || "";
    for (const n of t.filter(o => isNonEmptyURL(o)))
        if (r) {
            const o = n.replace(JOIN_LEADING_SLASH_RE, "");
            r = withTrailingSlash(r) + o
        } else
            r = n;
    return r
}
function joinRelativeURL(...e) {
    var s, i, l, u;
    const t = /\/(?!\/)/
      , r = e.filter(Boolean)
      , n = [];
    let o = 0;
    for (const c of r)
        if (!(!c || c === "/")) {
            for (const [f,d] of c.split(t).entries())
                if (!(!d || d === ".")) {
                    if (d === "..") {
                        if (n.length === 1 && hasProtocol(n[0]))
                            continue;
                        n.pop(),
                        o--;
                        continue
                    }
                    if (f === 1 && ((s = n[n.length - 1]) != null && s.endsWith(":/"))) {
                        n[n.length - 1] += "/" + d;
                        continue
                    }
                    n.push(d),
                    o++
                }
        }
    let a = n.join("/");
    return o >= 0 ? (i = r[0]) != null && i.startsWith("/") && !a.startsWith("/") ? a = "/" + a : (l = r[0]) != null && l.startsWith("./") && !a.startsWith("./") && (a = "./" + a) : a = "../".repeat(-1 * o) + a,
    (u = r[r.length - 1]) != null && u.endsWith("/") && !a.endsWith("/") && (a += "/"),
    a
}
function isEqual$1(e, t, r={}) {
    return r.trailingSlash || (e = withTrailingSlash(e),
    t = withTrailingSlash(t)),
    r.leadingSlash || (e = withLeadingSlash(e),
    t = withLeadingSlash(t)),
    r.encoding || (e = decode$3(e),
    t = decode$3(t)),
    e === t
}
const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL$1(e="", t) {
    const r = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (r) {
        const [,f,d=""] = r;
        return {
            protocol: f.toLowerCase(),
            pathname: d,
            href: f + d,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!hasProtocol(e, {
        acceptRelative: !0
    }))
        return parsePath(e);
    const [,n="",o,a=""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
    let[,s="",i=""] = a.match(/([^#/?]*)(.*)?/) || [];
    n === "file:" && (i = i.replace(/\/(?=[A-Za-z]:)/, ""));
    const {pathname: l, search: u, hash: c} = parsePath(i);
    return {
        protocol: n.toLowerCase(),
        auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "",
        host: s,
        pathname: l,
        search: u,
        hash: c,
        [protocolRelative]: !n
    }
}
function parsePath(e="") {
    const [t="",r="",n=""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: r,
        hash: n
    }
}
function stringifyParsedURL(e) {
    const t = e.pathname || ""
      , r = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : ""
      , n = e.hash || ""
      , o = e.auth ? e.auth + "@" : ""
      , a = e.host || "";
    return (e.protocol || e[protocolRelative] ? (e.protocol || "") + "//" : "") + o + a + t + r + n
}
class FetchError extends Error {
    constructor(t, r) {
        super(t, r),
        this.name = "FetchError",
        r != null && r.cause && !this.cause && (this.cause = r.cause)
    }
}
function createFetchError(e) {
    var l, u, c, f, d;
    const t = ((l = e.error) == null ? void 0 : l.message) || ((u = e.error) == null ? void 0 : u.toString()) || ""
      , r = ((c = e.request) == null ? void 0 : c.method) || ((f = e.options) == null ? void 0 : f.method) || "GET"
      , n = ((d = e.request) == null ? void 0 : d.url) || String(e.request) || "/"
      , o = `[${r}] ${JSON.stringify(n)}`
      , a = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>"
      , s = `${o}: ${a}${t ? ` ${t}` : ""}`
      , i = new FetchError(s,e.error ? {
        cause: e.error
    } : void 0);
    for (const p of ["request", "options", "response"])
        Object.defineProperty(i, p, {
            get() {
                return e[p]
            }
        });
    for (const [p,m] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
        Object.defineProperty(i, p, {
            get() {
                return e.response && e.response[m]
            }
        });
    return i
}
const payloadMethods = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function isPayloadMethod(e="GET") {
    return payloadMethods.has(e.toUpperCase())
}
function isJSONSerializable(e) {
    if (e === void 0)
        return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const textTypes = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
  , JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(e="") {
    if (!e)
        return "json";
    const t = e.split(";").shift() || "";
    return JSON_RE.test(t) ? "json" : textTypes.has(t) || t.startsWith("text/") ? "text" : "blob"
}
function resolveFetchOptions(e, t, r, n) {
    const o = mergeHeaders((t == null ? void 0 : t.headers) ?? (e == null ? void 0 : e.headers), r == null ? void 0 : r.headers, n);
    let a;
    return (r != null && r.query || r != null && r.params || t != null && t.params || t != null && t.query) && (a = {
        ...r == null ? void 0 : r.params,
        ...r == null ? void 0 : r.query,
        ...t == null ? void 0 : t.params,
        ...t == null ? void 0 : t.query
    }),
    {
        ...r,
        ...t,
        query: a,
        params: a,
        headers: o
    }
}
function mergeHeaders(e, t, r) {
    if (!t)
        return new r(e);
    const n = new r(t);
    if (e)
        for (const [o,a] of Symbol.iterator in e || Array.isArray(e) ? e : new r(e))
            n.set(o, a);
    return n
}
async function callHooks(e, t) {
    if (t)
        if (Array.isArray(t))
            for (const r of t)
                await r(e);
        else
            await t(e)
}
const retryStatusCodes = new Set([408, 409, 425, 429, 500, 502, 503, 504])
  , nullBodyResponses = new Set([101, 204, 205, 304]);
function createFetch(e={}) {
    const {fetch: t=globalThis.fetch, Headers: r=globalThis.Headers, AbortController: n=globalThis.AbortController} = e;
    async function o(i) {
        const l = i.error && i.error.name === "AbortError" && !i.options.timeout || !1;
        if (i.options.retry !== !1 && !l) {
            let c;
            typeof i.options.retry == "number" ? c = i.options.retry : c = isPayloadMethod(i.options.method) ? 0 : 1;
            const f = i.response && i.response.status || 500;
            if (c > 0 && (Array.isArray(i.options.retryStatusCodes) ? i.options.retryStatusCodes.includes(f) : retryStatusCodes.has(f))) {
                const d = typeof i.options.retryDelay == "function" ? i.options.retryDelay(i) : i.options.retryDelay || 0;
                return d > 0 && await new Promise(p => setTimeout(p, d)),
                a(i.request, {
                    ...i.options,
                    retry: c - 1
                })
            }
        }
        const u = createFetchError(i);
        throw Error.captureStackTrace && Error.captureStackTrace(u, a),
        u
    }
    const a = async function(l, u={}) {
        const c = {
            request: l,
            options: resolveFetchOptions(l, u, e.defaults, r),
            response: void 0,
            error: void 0
        };
        c.options.method && (c.options.method = c.options.method.toUpperCase()),
        c.options.onRequest && await callHooks(c, c.options.onRequest),
        typeof c.request == "string" && (c.options.baseURL && (c.request = withBase(c.request, c.options.baseURL)),
        c.options.query && (c.request = withQuery(c.request, c.options.query),
        delete c.options.query),
        "query"in c.options && delete c.options.query,
        "params"in c.options && delete c.options.params),
        c.options.body && isPayloadMethod(c.options.method) && (isJSONSerializable(c.options.body) ? (c.options.body = typeof c.options.body == "string" ? c.options.body : JSON.stringify(c.options.body),
        c.options.headers = new r(c.options.headers || {}),
        c.options.headers.has("content-type") || c.options.headers.set("content-type", "application/json"),
        c.options.headers.has("accept") || c.options.headers.set("accept", "application/json")) : ("pipeTo"in c.options.body && typeof c.options.body.pipeTo == "function" || typeof c.options.body.pipe == "function") && ("duplex"in c.options || (c.options.duplex = "half")));
        let f;
        if (!c.options.signal && c.options.timeout) {
            const p = new n;
            f = setTimeout( () => {
                const m = new Error("[TimeoutError]: The operation was aborted due to timeout");
                m.name = "TimeoutError",
                m.code = 23,
                p.abort(m)
            }
            , c.options.timeout),
            c.options.signal = p.signal
        }
        try {
            c.response = await t(c.request, c.options)
        } catch (p) {
            return c.error = p,
            c.options.onRequestError && await callHooks(c, c.options.onRequestError),
            await o(c)
        } finally {
            f && clearTimeout(f)
        }
        if ((c.response.body || c.response._bodyInit) && !nullBodyResponses.has(c.response.status) && c.options.method !== "HEAD") {
            const p = (c.options.parseResponse ? "json" : c.options.responseType) || detectResponseType(c.response.headers.get("content-type") || "");
            switch (p) {
            case "json":
                {
                    const m = await c.response.text()
                      , g = c.options.parseResponse || destr;
                    c.response._data = g(m);
                    break
                }
            case "stream":
                {
                    c.response._data = c.response.body || c.response._bodyInit;
                    break
                }
            default:
                c.response._data = await c.response[p]()
            }
        }
        return c.options.onResponse && await callHooks(c, c.options.onResponse),
        !c.options.ignoreResponseError && c.response.status >= 400 && c.response.status < 600 ? (c.options.onResponseError && await callHooks(c, c.options.onResponseError),
        await o(c)) : c.response
    }
      , s = async function(l, u) {
        return (await a(l, u))._data
    };
    return s.raw = a,
    s.native = (...i) => t(...i),
    s.create = (i={}, l={}) => createFetch({
        ...e,
        ...l,
        defaults: {
            ...e.defaults,
            ...l.defaults,
            ...i
        }
    }),
    s
}
const _globalThis$1 = function() {
    if (typeof globalThis < "u")
        return globalThis;
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}()
  , fetch$1 = _globalThis$1.fetch ? (...e) => _globalThis$1.fetch(...e) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))
  , Headers = _globalThis$1.Headers
  , AbortController$1 = _globalThis$1.AbortController
  , ofetch = createFetch({
    fetch: fetch$1,
    Headers,
    AbortController: AbortController$1
})
  , $fetch$1 = ofetch
  , useRuntimeConfig$1 = () => {
    var e;
    return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
}
  , appConfig = useRuntimeConfig$1().app
  , baseURL = () => appConfig.baseURL
  , buildAssetsDir = () => appConfig.buildAssetsDir
  , buildAssetsURL = (...e) => joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...e)
  , publicAssetsURL = (...e) => {
    const t = appConfig.cdnURL || appConfig.baseURL;
    return e.length ? joinRelativeURL(t, ...e) : t
}
;
globalThis.__buildAssetsURL = buildAssetsURL,
globalThis.__publicAssetsURL = publicAssetsURL;
globalThis.$fetch || (globalThis.$fetch = $fetch$1.create({
    baseURL: baseURL()
}));
function flatHooks(e, t={}, r) {
    for (const n in e) {
        const o = e[n]
          , a = r ? `${r}:${n}` : n;
        typeof o == "object" && o !== null ? flatHooks(o, t, a) : typeof o == "function" && (t[a] = o)
    }
    return t
}
const defaultTask = {
    run: e => e()
}
  , _createTask = () => defaultTask
  , createTask = typeof console.createTask < "u" ? console.createTask : _createTask;
function serialTaskCaller(e, t) {
    const r = t.shift()
      , n = createTask(r);
    return e.reduce( (o, a) => o.then( () => n.run( () => a(...t))), Promise.resolve())
}
function parallelTaskCaller(e, t) {
    const r = t.shift()
      , n = createTask(r);
    return Promise.all(e.map(o => n.run( () => o(...t))))
}
function callEachWith(e, t) {
    for (const r of [...e])
        r(t)
}
class Hookable {
    constructor() {
        this._hooks = {},
        this._before = void 0,
        this._after = void 0,
        this._deprecatedMessages = void 0,
        this._deprecatedHooks = {},
        this.hook = this.hook.bind(this),
        this.callHook = this.callHook.bind(this),
        this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, r, n={}) {
        if (!t || typeof r != "function")
            return () => {}
            ;
        const o = t;
        let a;
        for (; this._deprecatedHooks[t]; )
            a = this._deprecatedHooks[t],
            t = a.to;
        if (a && !n.allowDeprecated) {
            let s = a.message;
            s || (s = `${o} hook has been deprecated` + (a.to ? `, please use ${a.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(s) || (console.warn(s),
            this._deprecatedMessages.add(s))
        }
        if (!r.name)
            try {
                Object.defineProperty(r, "name", {
                    get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch {}
        return this._hooks[t] = this._hooks[t] || [],
        this._hooks[t].push(r),
        () => {
            r && (this.removeHook(t, r),
            r = void 0)
        }
    }
    hookOnce(t, r) {
        let n, o = (...a) => (typeof n == "function" && n(),
        n = void 0,
        o = void 0,
        r(...a));
        return n = this.hook(t, o),
        n
    }
    removeHook(t, r) {
        if (this._hooks[t]) {
            const n = this._hooks[t].indexOf(r);
            n !== -1 && this._hooks[t].splice(n, 1),
            this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, r) {
        this._deprecatedHooks[t] = typeof r == "string" ? {
            to: r
        } : r;
        const n = this._hooks[t] || [];
        delete this._hooks[t];
        for (const o of n)
            this.hook(t, o)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const r in t)
            this.deprecateHook(r, t[r])
    }
    addHooks(t) {
        const r = flatHooks(t)
          , n = Object.keys(r).map(o => this.hook(o, r[o]));
        return () => {
            for (const o of n.splice(0, n.length))
                o()
        }
    }
    removeHooks(t) {
        const r = flatHooks(t);
        for (const n in r)
            this.removeHook(n, r[n])
    }
    removeAllHooks() {
        for (const t in this._hooks)
            delete this._hooks[t]
    }
    callHook(t, ...r) {
        return r.unshift(t),
        this.callHookWith(serialTaskCaller, t, ...r)
    }
    callHookParallel(t, ...r) {
        return r.unshift(t),
        this.callHookWith(parallelTaskCaller, t, ...r)
    }
    callHookWith(t, r, ...n) {
        const o = this._before || this._after ? {
            name: r,
            args: n,
            context: {}
        } : void 0;
        this._before && callEachWith(this._before, o);
        const a = t(r in this._hooks ? [...this._hooks[r]] : [], n);
        return a instanceof Promise ? a.finally( () => {
            this._after && o && callEachWith(this._after, o)
        }
        ) : (this._after && o && callEachWith(this._after, o),
        a)
    }
    beforeEach(t) {
        return this._before = this._before || [],
        this._before.push(t),
        () => {
            if (this._before !== void 0) {
                const r = this._before.indexOf(t);
                r !== -1 && this._before.splice(r, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [],
        this._after.push(t),
        () => {
            if (this._after !== void 0) {
                const r = this._after.indexOf(t);
                r !== -1 && this._after.splice(r, 1)
            }
        }
    }
}
function createHooks() {
    return new Hookable
}
function createContext(e={}) {
    let t, r = !1;
    const n = s => {
        if (t && t !== s)
            throw new Error("Context conflict")
    }
    ;
    let o;
    if (e.asyncContext) {
        const s = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        s ? o = new s : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const a = () => {
        if (o && t === void 0) {
            const s = o.getStore();
            if (s !== void 0)
                return s
        }
        return t
    }
    ;
    return {
        use: () => {
            const s = a();
            if (s === void 0)
                throw new Error("Context is not available");
            return s
        }
        ,
        tryUse: () => a(),
        set: (s, i) => {
            i || n(s),
            t = s,
            r = !0
        }
        ,
        unset: () => {
            t = void 0,
            r = !1
        }
        ,
        call: (s, i) => {
            n(s),
            t = s;
            try {
                return o ? o.run(s, i) : i()
            } finally {
                r || (t = void 0)
            }
        }
        ,
        async callAsync(s, i) {
            t = s;
            const l = () => {
                t = s
            }
              , u = () => t === s ? l : void 0;
            asyncHandlers.add(u);
            try {
                const c = o ? o.run(s, i) : i();
                return r || (t = void 0),
                await c
            } finally {
                asyncHandlers.delete(u)
            }
        }
    }
}
function createNamespace(e={}) {
    const t = {};
    return {
        get(r, n={}) {
            return t[r] || (t[r] = createContext({
                ...e,
                ...n
            })),
            t[r],
            t[r]
        }
    }
}
const _globalThis = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
  , globalKey$3 = "__unctx__"
  , defaultNamespace$1 = _globalThis[globalKey$3] || (_globalThis[globalKey$3] = createNamespace())
  , getContext = (e, t={}) => defaultNamespace$1.get(e, t)
  , asyncHandlersKey = "__unctx_async_handlers__"
  , asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = new Set);
function executeAsync(e) {
    const t = [];
    for (const o of asyncHandlers) {
        const a = o();
        a && t.push(a)
    }
    const r = () => {
        for (const o of t)
            o()
    }
    ;
    let n = e();
    return n && typeof n == "object" && "catch"in n && (n = n.catch(o => {
        throw r(),
        o
    }
    )),
    [n, r]
}
const appLayoutTransition = !1
  , appPageTransition = !1
  , appKeepalive = !1
  , nuxtLinkDefaults = {
    componentName: "NuxtLink",
    prefetch: !0,
    prefetchOn: {
        visibility: !0
    }
}
  , asyncDataDefaults = {
    value: null,
    errorValue: null,
    deep: !0
}
  , nuxtDefaultErrorValue = null
  , vueAppRootContainer = "#__nuxt"
  , appId = "nuxt-app"
  , outdatedBuildInterval = 36e5
  , chunkErrorEvent = "vite:preloadError";
function getNuxtAppCtx(e=appId) {
    return getContext(e, {
        asyncContext: !1
    })
}
const NuxtPluginIndicator = "__nuxt_plugin";
function createNuxtApp(e) {
    var o;
    let t = 0;
    const r = {
        _id: e.id || appId || "nuxt-app",
        _scope: effectScope(),
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.13.2"
            },
            get vue() {
                return r.vueApp.version
            }
        },
        payload: shallowReactive({
            ...((o = e.ssrContext) == null ? void 0 : o.payload) || {},
            data: shallowReactive({}),
            state: reactive({}),
            once: new Set,
            _errors: shallowReactive({})
        }),
        static: {
            data: {}
        },
        runWithContext(a) {
            return r._scope.active && !getCurrentScope() ? r._scope.run( () => callWithNuxt(r, a)) : callWithNuxt(r, a)
        },
        isHydrating: !0,
        deferHydration() {
            if (!r.isHydrating)
                return () => {}
                ;
            t++;
            let a = !1;
            return () => {
                if (!a && (a = !0,
                t--,
                t === 0))
                    return r.isHydrating = !1,
                    r.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: shallowReactive({}),
        _payloadRevivers: {},
        ...e
    };
    {
        const a = window.__NUXT__;
        if (a)
            for (const s in a)
                switch (s) {
                case "data":
                case "state":
                case "_errors":
                    Object.assign(r.payload[s], a[s]);
                    break;
                default:
                    r.payload[s] = a[s]
                }
    }
    r.hooks = createHooks(),
    r.hook = r.hooks.hook,
    r.callHook = r.hooks.callHook,
    r.provide = (a, s) => {
        const i = "$" + a;
        defineGetter(r, i, s),
        defineGetter(r.vueApp.config.globalProperties, i, s)
    }
    ,
    defineGetter(r.vueApp, "$nuxt", r),
    defineGetter(r.vueApp.config.globalProperties, "$nuxt", r);
    {
        window.addEventListener(chunkErrorEvent, s => {
            r.callHook("app:chunkError", {
                error: s.payload
            }),
            (r.isHydrating || s.payload.message.includes("Unable to preload CSS")) && s.preventDefault()
        }
        ),
        window.useNuxtApp = window.useNuxtApp || useNuxtApp;
        const a = r.hook("app:error", (...s) => {
            console.error("[nuxt] error caught during app initialization", ...s)
        }
        );
        r.hook("app:mounted", a)
    }
    const n = r.payload.config;
    return r.provide("config", n),
    r
}
function registerPluginHooks(e, t) {
    t.hooks && e.hooks.addHooks(t.hooks)
}
async function applyPlugin(e, t) {
    if (typeof t == "function") {
        const {provide: r} = await e.runWithContext( () => t(e)) || {};
        if (r && typeof r == "object")
            for (const n in r)
                e.provide(n, r[n])
    }
}
async function applyPlugins(e, t) {
    const r = []
      , n = []
      , o = []
      , a = [];
    let s = 0;
    async function i(l) {
        var c;
        const u = ((c = l.dependsOn) == null ? void 0 : c.filter(f => t.some(d => d._name === f) && !r.includes(f))) ?? [];
        if (u.length > 0)
            n.push([new Set(u), l]);
        else {
            const f = applyPlugin(e, l).then(async () => {
                l._name && (r.push(l._name),
                await Promise.all(n.map(async ([d,p]) => {
                    d.has(l._name) && (d.delete(l._name),
                    d.size === 0 && (s++,
                    await i(p)))
                }
                )))
            }
            );
            l.parallel ? o.push(f.catch(d => a.push(d))) : await f
        }
    }
    for (const l of t)
        registerPluginHooks(e, l);
    for (const l of t)
        await i(l);
    if (await Promise.all(o),
    s)
        for (let l = 0; l < s; l++)
            await Promise.all(o);
    if (a.length)
        throw a[0]
}
function defineNuxtPlugin(e) {
    if (typeof e == "function")
        return e;
    const t = e._name || e.name;
    return delete e.name,
    Object.assign(e.setup || ( () => {}
    ), e, {
        [NuxtPluginIndicator]: !0,
        _name: t
    })
}
const definePayloadPlugin = defineNuxtPlugin;
function callWithNuxt(e, t, r) {
    const n = () => t();
    return getNuxtAppCtx(e._id).set(e),
    e.vueApp.runWithContext(n)
}
function tryUseNuxtApp(e) {
    var r;
    let t;
    return hasInjectionContext() && (t = (r = getCurrentInstance()) == null ? void 0 : r.appContext.app.$nuxt),
    t = t || getNuxtAppCtx(e).tryUse(),
    t || null
}
function useNuxtApp(e) {
    const t = tryUseNuxtApp(e);
    if (!t)
        throw new Error("[nuxt] instance unavailable");
    return t
}
function useRuntimeConfig(e) {
    return useNuxtApp().$config
}
function defineGetter(e, t, r) {
    Object.defineProperty(e, t, {
        get: () => r
    })
}
function parse$3(e, t) {
    if (typeof e != "string")
        throw new TypeError("argument str must be a string");
    const r = {}
      , n = t || {}
      , o = n.decode || decode$2;
    let a = 0;
    for (; a < e.length; ) {
        const s = e.indexOf("=", a);
        if (s === -1)
            break;
        let i = e.indexOf(";", a);
        if (i === -1)
            i = e.length;
        else if (i < s) {
            a = e.lastIndexOf(";", s - 1) + 1;
            continue
        }
        const l = e.slice(a, s).trim();
        if (n != null && n.filter && !(n != null && n.filter(l))) {
            a = i + 1;
            continue
        }
        if (r[l] === void 0) {
            let u = e.slice(s + 1, i).trim();
            u.codePointAt(0) === 34 && (u = u.slice(1, -1)),
            r[l] = tryDecode(u, o)
        }
        a = i + 1
    }
    return r
}
function decode$2(e) {
    return e.includes("%") ? decodeURIComponent(e) : e
}
function tryDecode(e, t) {
    try {
        return t(e)
    } catch {
        return e
    }
}
const fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function serialize(e, t, r) {
    const n = r || {}
      , o = n.encode || encodeURIComponent;
    if (typeof o != "function")
        throw new TypeError("option encode is invalid");
    if (!fieldContentRegExp.test(e))
        throw new TypeError("argument name is invalid");
    const a = o(t);
    if (a && !fieldContentRegExp.test(a))
        throw new TypeError("argument val is invalid");
    let s = e + "=" + a;
    if (n.maxAge !== void 0 && n.maxAge !== null) {
        const i = n.maxAge - 0;
        if (Number.isNaN(i) || !Number.isFinite(i))
            throw new TypeError("option maxAge is invalid");
        s += "; Max-Age=" + Math.floor(i)
    }
    if (n.domain) {
        if (!fieldContentRegExp.test(n.domain))
            throw new TypeError("option domain is invalid");
        s += "; Domain=" + n.domain
    }
    if (n.path) {
        if (!fieldContentRegExp.test(n.path))
            throw new TypeError("option path is invalid");
        s += "; Path=" + n.path
    }
    if (n.expires) {
        if (!isDate$2(n.expires) || Number.isNaN(n.expires.valueOf()))
            throw new TypeError("option expires is invalid");
        s += "; Expires=" + n.expires.toUTCString()
    }
    if (n.httpOnly && (s += "; HttpOnly"),
    n.secure && (s += "; Secure"),
    n.priority)
        switch (typeof n.priority == "string" ? n.priority.toLowerCase() : n.priority) {
        case "low":
            {
                s += "; Priority=Low";
                break
            }
        case "medium":
            {
                s += "; Priority=Medium";
                break
            }
        case "high":
            {
                s += "; Priority=High";
                break
            }
        default:
            throw new TypeError("option priority is invalid")
        }
    if (n.sameSite)
        switch (typeof n.sameSite == "string" ? n.sameSite.toLowerCase() : n.sameSite) {
        case !0:
            {
                s += "; SameSite=Strict";
                break
            }
        case "lax":
            {
                s += "; SameSite=Lax";
                break
            }
        case "strict":
            {
                s += "; SameSite=Strict";
                break
            }
        case "none":
            {
                s += "; SameSite=None";
                break
            }
        default:
            throw new TypeError("option sameSite is invalid")
        }
    return n.partitioned && (s += "; Partitioned"),
    s
}
function isDate$2(e) {
    return Object.prototype.toString.call(e) === "[object Date]" || e instanceof Date
}
const defaults$2 = Object.freeze({
    ignoreUnknown: !1,
    respectType: !1,
    respectFunctionNames: !1,
    respectFunctionProperties: !1,
    unorderedObjects: !0,
    unorderedArrays: !1,
    unorderedSets: !1,
    excludeKeys: void 0,
    excludeValues: void 0,
    replacer: void 0
});
function objectHash(e, t) {
    t ? t = {
        ...defaults$2,
        ...t
    } : t = defaults$2;
    const r = createHasher(t);
    return r.dispatch(e),
    r.toString()
}
const defaultPrototypesKeys = Object.freeze(["prototype", "__proto__", "constructor"]);
function createHasher(e) {
    let t = ""
      , r = new Map;
    const n = o => {
        t += o
    }
    ;
    return {
        toString() {
            return t
        },
        getContext() {
            return r
        },
        dispatch(o) {
            return e.replacer && (o = e.replacer(o)),
            this[o === null ? "null" : typeof o](o)
        },
        object(o) {
            if (o && typeof o.toJSON == "function")
                return this.object(o.toJSON());
            const a = Object.prototype.toString.call(o);
            let s = "";
            const i = a.length;
            i < 10 ? s = "unknown:[" + a + "]" : s = a.slice(8, i - 1),
            s = s.toLowerCase();
            let l = null;
            if ((l = r.get(o)) === void 0)
                r.set(o, r.size);
            else
                return this.dispatch("[CIRCULAR:" + l + "]");
            if (typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(o))
                return n("buffer:"),
                n(o.toString("utf8"));
            if (s !== "object" && s !== "function" && s !== "asyncfunction")
                this[s] ? this[s](o) : e.ignoreUnknown || this.unkown(o, s);
            else {
                let u = Object.keys(o);
                e.unorderedObjects && (u = u.sort());
                let c = [];
                e.respectType !== !1 && !isNativeFunction(o) && (c = defaultPrototypesKeys),
                e.excludeKeys && (u = u.filter(d => !e.excludeKeys(d)),
                c = c.filter(d => !e.excludeKeys(d))),
                n("object:" + (u.length + c.length) + ":");
                const f = d => {
                    this.dispatch(d),
                    n(":"),
                    e.excludeValues || this.dispatch(o[d]),
                    n(",")
                }
                ;
                for (const d of u)
                    f(d);
                for (const d of c)
                    f(d)
            }
        },
        array(o, a) {
            if (a = a === void 0 ? e.unorderedArrays !== !1 : a,
            n("array:" + o.length + ":"),
            !a || o.length <= 1) {
                for (const l of o)
                    this.dispatch(l);
                return
            }
            const s = new Map
              , i = o.map(l => {
                const u = createHasher(e);
                u.dispatch(l);
                for (const [c,f] of u.getContext())
                    s.set(c, f);
                return u.toString()
            }
            );
            return r = s,
            i.sort(),
            this.array(i, !1)
        },
        date(o) {
            return n("date:" + o.toJSON())
        },
        symbol(o) {
            return n("symbol:" + o.toString())
        },
        unkown(o, a) {
            if (n(a),
            !!o && (n(":"),
            o && typeof o.entries == "function"))
                return this.array(Array.from(o.entries()), !0)
        },
        error(o) {
            return n("error:" + o.toString())
        },
        boolean(o) {
            return n("bool:" + o)
        },
        string(o) {
            n("string:" + o.length + ":"),
            n(o)
        },
        function(o) {
            n("fn:"),
            isNativeFunction(o) ? this.dispatch("[native]") : this.dispatch(o.toString()),
            e.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(o.name)),
            e.respectFunctionProperties && this.object(o)
        },
        number(o) {
            return n("number:" + o)
        },
        xml(o) {
            return n("xml:" + o.toString())
        },
        null() {
            return n("Null")
        },
        undefined() {
            return n("Undefined")
        },
        regexp(o) {
            return n("regex:" + o.toString())
        },
        uint8array(o) {
            return n("uint8array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        uint8clampedarray(o) {
            return n("uint8clampedarray:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        int8array(o) {
            return n("int8array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        uint16array(o) {
            return n("uint16array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        int16array(o) {
            return n("int16array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        uint32array(o) {
            return n("uint32array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        int32array(o) {
            return n("int32array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        float32array(o) {
            return n("float32array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        float64array(o) {
            return n("float64array:"),
            this.dispatch(Array.prototype.slice.call(o))
        },
        arraybuffer(o) {
            return n("arraybuffer:"),
            this.dispatch(new Uint8Array(o))
        },
        url(o) {
            return n("url:" + o.toString())
        },
        map(o) {
            n("map:");
            const a = [...o];
            return this.array(a, e.unorderedSets !== !1)
        },
        set(o) {
            n("set:");
            const a = [...o];
            return this.array(a, e.unorderedSets !== !1)
        },
        file(o) {
            return n("file:"),
            this.dispatch([o.name, o.size, o.type, o.lastModfied])
        },
        blob() {
            if (e.ignoreUnknown)
                return n("[blob]");
            throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
        },
        domwindow() {
            return n("domwindow")
        },
        bigint(o) {
            return n("bigint:" + o.toString())
        },
        process() {
            return n("process")
        },
        timer() {
            return n("timer")
        },
        pipe() {
            return n("pipe")
        },
        tcp() {
            return n("tcp")
        },
        udp() {
            return n("udp")
        },
        tty() {
            return n("tty")
        },
        statwatcher() {
            return n("statwatcher")
        },
        securecontext() {
            return n("securecontext")
        },
        connection() {
            return n("connection")
        },
        zlib() {
            return n("zlib")
        },
        context() {
            return n("context")
        },
        nodescript() {
            return n("nodescript")
        },
        httpparser() {
            return n("httpparser")
        },
        dataview() {
            return n("dataview")
        },
        signal() {
            return n("signal")
        },
        fsevent() {
            return n("fsevent")
        },
        tlswrap() {
            return n("tlswrap")
        }
    }
}
const nativeFunc = "[native code] }"
  , nativeFuncLength = nativeFunc.length;
function isNativeFunction(e) {
    return typeof e != "function" ? !1 : Function.prototype.toString.call(e).slice(-nativeFuncLength) === nativeFunc
}
function isEqual(e, t, r={}) {
    return e === t || objectHash(e, r) === objectHash(t, r)
}
function _createMatcher(e, t) {
    return {
        ctx: {
            table: e
        },
        matchAll: r => _matchRoutes(r, e)
    }
}
function _createTableFromExport(e) {
    const t = {};
    for (const r in e)
        t[r] = r === "dynamic" ? new Map(Object.entries(e[r]).map( ([n,o]) => [n, _createTableFromExport(o)])) : new Map(Object.entries(e[r]));
    return t
}
function createMatcherFromExport(e) {
    return _createMatcher(_createTableFromExport(e))
}
function _matchRoutes(e, t, r) {
    e.endsWith("/") && (e = e.slice(0, -1) || "/");
    const n = [];
    for (const [a,s] of _sortRoutesMap(t.wildcard))
        (e === a || e.startsWith(a + "/")) && n.push(s);
    for (const [a,s] of _sortRoutesMap(t.dynamic))
        if (e.startsWith(a + "/")) {
            const i = "/" + e.slice(a.length).split("/").splice(2).join("/");
            n.push(..._matchRoutes(i, s))
        }
    const o = t.static.get(e);
    return o && n.push(o),
    n.filter(Boolean)
}
function _sortRoutesMap(e) {
    return [...e.entries()].sort( (t, r) => t[0].length - r[0].length)
}
function isPlainObject$1(e) {
    if (e === null || typeof e != "object")
        return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}
function _defu(e, t, r=".", n) {
    if (!isPlainObject$1(t))
        return _defu(e, {}, r, n);
    const o = Object.assign({}, t);
    for (const a in e) {
        if (a === "__proto__" || a === "constructor")
            continue;
        const s = e[a];
        s != null && (n && n(o, a, s, r) || (Array.isArray(s) && Array.isArray(o[a]) ? o[a] = [...s, ...o[a]] : isPlainObject$1(s) && isPlainObject$1(o[a]) ? o[a] = _defu(s, o[a], (r ? `${r}.` : "") + a.toString(), n) : o[a] = s))
    }
    return o
}
function createDefu(e) {
    return (...t) => t.reduce( (r, n) => _defu(r, n, "", e), {})
}
const defu = createDefu();
function hasProp(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
var __defProp$2 = Object.defineProperty
  , __defNormalProp$2 = (e, t, r) => t in e ? __defProp$2(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , __publicField$2 = (e, t, r) => (__defNormalProp$2(e, typeof t != "symbol" ? t + "" : t, r),
r);
class H3Error extends Error {
    constructor(t, r={}) {
        super(t, r),
        __publicField$2(this, "statusCode", 500),
        __publicField$2(this, "fatal", !1),
        __publicField$2(this, "unhandled", !1),
        __publicField$2(this, "statusMessage"),
        __publicField$2(this, "data"),
        __publicField$2(this, "cause"),
        r.cause && !this.cause && (this.cause = r.cause)
    }
    toJSON() {
        const t = {
            message: this.message,
            statusCode: sanitizeStatusCode(this.statusCode, 500)
        };
        return this.statusMessage && (t.statusMessage = sanitizeStatusMessage(this.statusMessage)),
        this.data !== void 0 && (t.data = this.data),
        t
    }
}
__publicField$2(H3Error, "__h3_error__", !0);
function createError$1(e) {
    if (typeof e == "string")
        return new H3Error(e);
    if (isError$1(e))
        return e;
    const t = new H3Error(e.message ?? e.statusMessage ?? "",{
        cause: e.cause || e
    });
    if (hasProp(e, "stack"))
        try {
            Object.defineProperty(t, "stack", {
                get() {
                    return e.stack
                }
            })
        } catch {
            try {
                t.stack = e.stack
            } catch {}
        }
    if (e.data && (t.data = e.data),
    e.statusCode ? t.statusCode = sanitizeStatusCode(e.statusCode, t.statusCode) : e.status && (t.statusCode = sanitizeStatusCode(e.status, t.statusCode)),
    e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText),
    t.statusMessage) {
        const r = t.statusMessage;
        sanitizeStatusMessage(t.statusMessage) !== r && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal),
    e.unhandled !== void 0 && (t.unhandled = e.unhandled),
    t
}
function isError$1(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(e="") {
    return e.replace(DISALLOWED_STATUS_CHARS, "")
}
function sanitizeStatusCode(e, t=200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)),
    e < 100 || e > 999) ? t : e
}
typeof setImmediate > "u" || setImmediate;
const LayoutMetaSymbol = Symbol("layout-meta")
  , PageRouteSymbol = Symbol("route")
  , useRouter = () => {
    var e;
    return (e = useNuxtApp()) == null ? void 0 : e.$router
}
  , useRoute$1 = () => hasInjectionContext() ? inject(PageRouteSymbol, useNuxtApp()._route) : useNuxtApp()._route;
function defineNuxtRouteMiddleware(e) {
    return e
}
const addRouteMiddleware = (e, t, r={}) => {
    const n = useNuxtApp()
      , o = r.global || typeof e != "string"
      , a = typeof e != "string" ? e : t;
    if (!a) {
        console.warn("[nuxt] No route middleware passed to `addRouteMiddleware`.", e);
        return
    }
    o ? n._middleware.global.push(a) : n._middleware.named[e] = a
}
  , isProcessingMiddleware = () => {
    try {
        if (useNuxtApp()._processingMiddleware)
            return !0
    } catch {
        return !1
    }
    return !1
}
  , navigateTo = (e, t) => {
    e || (e = "/");
    const r = typeof e == "string" ? e : "path"in e ? resolveRouteObject(e) : useRouter().resolve(e).href;
    if (t != null && t.open) {
        const {target: l="_blank", windowFeatures: u={}} = t.open
          , c = Object.entries(u).filter( ([f,d]) => d !== void 0).map( ([f,d]) => `${f.toLowerCase()}=${d}`).join(", ");
        return open(r, l, c),
        Promise.resolve()
    }
    const n = hasProtocol(r, {
        acceptRelative: !0
    })
      , o = (t == null ? void 0 : t.external) || n;
    if (o) {
        if (!(t != null && t.external))
            throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
        const {protocol: l} = new URL(r,window.location.href);
        if (l && isScriptProtocol(l))
            throw new Error(`Cannot navigate to a URL with '${l}' protocol.`)
    }
    const a = isProcessingMiddleware();
    if (!o && a)
        return e;
    const s = useRouter()
      , i = useNuxtApp();
    return o ? (i._scope.stop(),
    t != null && t.replace ? location.replace(r) : location.href = r,
    a ? i.isHydrating ? new Promise( () => {}
    ) : !1 : Promise.resolve()) : t != null && t.replace ? s.replace(e) : s.push(e)
}
;
function resolveRouteObject(e) {
    return withQuery(e.path || "", e.query || {}) + (e.hash || "")
}
const NUXT_ERROR_SIGNATURE = "__nuxt_error"
  , useError = () => toRef(useNuxtApp().payload, "error")
  , showError = e => {
    const t = createError(e);
    try {
        const r = useNuxtApp()
          , n = useError();
        r.hooks.callHook("app:error", t),
        n.value = n.value || t
    } catch {
        throw t
    }
    return t
}
  , clearError = async (e={}) => {
    const t = useNuxtApp()
      , r = useError();
    t.callHook("app:error:cleared", e),
    e.redirect && await useRouter().replace(e.redirect),
    r.value = nuxtDefaultErrorValue
}
  , isNuxtError = e => !!e && typeof e == "object" && NUXT_ERROR_SIGNATURE in e
  , createError = e => {
    const t = createError$1(e);
    return Object.defineProperty(t, NUXT_ERROR_SIGNATURE, {
        value: !0,
        configurable: !1,
        writable: !1
    }),
    t
}
  , isVue2 = !1;
/*!
 * pinia v2.2.5
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = e => activePinia = e
  , piniaSymbol = Symbol();
function isPlainObject(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var MutationType;
(function(e) {
    e.direct = "direct",
    e.patchObject = "patch object",
    e.patchFunction = "patch function"
}
)(MutationType || (MutationType = {}));
function createPinia() {
    const e = effectScope(!0)
      , t = e.run( () => ref({}));
    let r = []
      , n = [];
    const o = markRaw({
        install(a) {
            setActivePinia(o),
            o._a = a,
            a.provide(piniaSymbol, o),
            a.config.globalProperties.$pinia = o,
            n.forEach(s => r.push(s)),
            n = []
        },
        use(a) {
            return !this._a && !isVue2 ? n.push(a) : r.push(a),
            this
        },
        _p: r,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return o
}
const noop$3 = () => {}
;
function addSubscription(e, t, r, n=noop$3) {
    e.push(t);
    const o = () => {
        const a = e.indexOf(t);
        a > -1 && (e.splice(a, 1),
        n())
    }
    ;
    return !r && getCurrentScope() && onScopeDispose(o),
    o
}
function triggerSubscriptions(e, ...t) {
    e.slice().forEach(r => {
        r(...t)
    }
    )
}
const fallbackRunWithContext = e => e()
  , ACTION_MARKER = Symbol()
  , ACTION_NAME = Symbol();
function mergeReactiveObjects(e, t) {
    e instanceof Map && t instanceof Map ? t.forEach( (r, n) => e.set(n, r)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const r in t) {
        if (!t.hasOwnProperty(r))
            continue;
        const n = t[r]
          , o = e[r];
        isPlainObject(o) && isPlainObject(n) && e.hasOwnProperty(r) && !isRef(n) && !isReactive(n) ? e[r] = mergeReactiveObjects(o, n) : e[r] = n
    }
    return e
}
const skipHydrateSymbol = Symbol();
function shouldHydrate(e) {
    return !isPlainObject(e) || !e.hasOwnProperty(skipHydrateSymbol)
}
const {assign: assign$2} = Object;
function isComputed(e) {
    return !!(isRef(e) && e.effect)
}
function createOptionsStore(e, t, r, n) {
    const {state: o, actions: a, getters: s} = t
      , i = r.state.value[e];
    let l;
    function u() {
        i || (r.state.value[e] = o ? o() : {});
        const c = toRefs(r.state.value[e]);
        return assign$2(c, a, Object.keys(s || {}).reduce( (f, d) => (f[d] = markRaw(computed( () => {
            setActivePinia(r);
            const p = r._s.get(e);
            return s[d].call(p, p)
        }
        )),
        f), {}))
    }
    return l = createSetupStore(e, u, t, r, n, !0),
    l
}
function createSetupStore(e, t, r={}, n, o, a) {
    let s;
    const i = assign$2({
        actions: {}
    }, r)
      , l = {
        deep: !0
    };
    let u, c, f = [], d = [], p;
    const m = n.state.value[e];
    !a && !m && (n.state.value[e] = {}),
    ref({});
    let g;
    function _(I) {
        let M;
        u = c = !1,
        typeof I == "function" ? (I(n.state.value[e]),
        M = {
            type: MutationType.patchFunction,
            storeId: e,
            events: p
        }) : (mergeReactiveObjects(n.state.value[e], I),
        M = {
            type: MutationType.patchObject,
            payload: I,
            storeId: e,
            events: p
        });
        const w = g = Symbol();
        nextTick().then( () => {
            g === w && (u = !0)
        }
        ),
        c = !0,
        triggerSubscriptions(f, M, n.state.value[e])
    }
    const b = a ? function() {
        const {state: M} = r
          , w = M ? M() : {};
        this.$patch(T => {
            assign$2(T, w)
        }
        )
    }
    : noop$3;
    function y() {
        s.stop(),
        f = [],
        d = [],
        n._s.delete(e)
    }
    const v = (I, M="") => {
        if (ACTION_MARKER in I)
            return I[ACTION_NAME] = M,
            I;
        const w = function() {
            setActivePinia(n);
            const T = Array.from(arguments)
              , k = []
              , A = [];
            function B(N) {
                k.push(N)
            }
            function $(N) {
                A.push(N)
            }
            triggerSubscriptions(d, {
                args: T,
                name: w[ACTION_NAME],
                store: C,
                after: B,
                onError: $
            });
            let P;
            try {
                P = I.apply(this && this.$id === e ? this : C, T)
            } catch (N) {
                throw triggerSubscriptions(A, N),
                N
            }
            return P instanceof Promise ? P.then(N => (triggerSubscriptions(k, N),
            N)).catch(N => (triggerSubscriptions(A, N),
            Promise.reject(N))) : (triggerSubscriptions(k, P),
            P)
        };
        return w[ACTION_MARKER] = !0,
        w[ACTION_NAME] = M,
        w
    }
      , S = {
        _p: n,
        $id: e,
        $onAction: addSubscription.bind(null, d),
        $patch: _,
        $reset: b,
        $subscribe(I, M={}) {
            const w = addSubscription(f, I, M.detached, () => T())
              , T = s.run( () => watch( () => n.state.value[e], k => {
                (M.flush === "sync" ? c : u) && I({
                    storeId: e,
                    type: MutationType.direct,
                    events: p
                }, k)
            }
            , assign$2({}, l, M)));
            return w
        },
        $dispose: y
    }
      , C = reactive(S);
    n._s.set(e, C);
    const E = (n._a && n._a.runWithContext || fallbackRunWithContext)( () => n._e.run( () => (s = effectScope()).run( () => t({
        action: v
    }))));
    for (const I in E) {
        const M = E[I];
        if (isRef(M) && !isComputed(M) || isReactive(M))
            a || (m && shouldHydrate(M) && (isRef(M) ? M.value = m[I] : mergeReactiveObjects(M, m[I])),
            n.state.value[e][I] = M);
        else if (typeof M == "function") {
            const w = v(M, I);
            E[I] = w,
            i.actions[I] = M
        }
    }
    return assign$2(C, E),
    assign$2(toRaw(C), E),
    Object.defineProperty(C, "$state", {
        get: () => n.state.value[e],
        set: I => {
            _(M => {
                assign$2(M, I)
            }
            )
        }
    }),
    n._p.forEach(I => {
        assign$2(C, s.run( () => I({
            store: C,
            app: n._a,
            pinia: n,
            options: i
        })))
    }
    ),
    m && a && r.hydrate && r.hydrate(C.$state, m),
    u = !0,
    c = !0,
    C
}
/*! #__NO_SIDE_EFFECTS__ */
function defineStore(e, t, r) {
    let n, o;
    const a = typeof t == "function";
    typeof e == "string" ? (n = e,
    o = a ? r : t) : (o = e,
    n = e.id);
    function s(i, l) {
        const u = hasInjectionContext();
        return i = i || (u ? inject(piniaSymbol, null) : null),
        i && setActivePinia(i),
        i = activePinia,
        i._s.has(n) || (a ? createSetupStore(n, t, o, i) : createOptionsStore(n, o, i)),
        i._s.get(n)
    }
    return s.$id = n,
    s
}
function decode64(e) {
    const t = asciiToBinary(e)
      , r = new ArrayBuffer(t.length)
      , n = new DataView(r);
    for (let o = 0; o < r.byteLength; o++)
        n.setUint8(o, t.charCodeAt(o));
    return r
}
const KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(e) {
    e.length % 4 === 0 && (e = e.replace(/==?$/, ""));
    let t = ""
      , r = 0
      , n = 0;
    for (let o = 0; o < e.length; o++)
        r <<= 6,
        r |= KEY_STRING.indexOf(e[o]),
        n += 6,
        n === 24 && (t += String.fromCharCode((r & 16711680) >> 16),
        t += String.fromCharCode((r & 65280) >> 8),
        t += String.fromCharCode(r & 255),
        r = n = 0);
    return n === 12 ? (r >>= 4,
    t += String.fromCharCode(r)) : n === 18 && (r >>= 2,
    t += String.fromCharCode((r & 65280) >> 8),
    t += String.fromCharCode(r & 255)),
    t
}
const UNDEFINED = -1
  , HOLE = -2
  , NAN = -3
  , POSITIVE_INFINITY = -4
  , NEGATIVE_INFINITY = -5
  , NEGATIVE_ZERO = -6;
function parse$2(e, t) {
    return unflatten(JSON.parse(e), t)
}
function unflatten(e, t) {
    if (typeof e == "number")
        return o(e, !0);
    if (!Array.isArray(e) || e.length === 0)
        throw new Error("Invalid input");
    const r = e
      , n = Array(r.length);
    function o(a, s=!1) {
        if (a === UNDEFINED)
            return;
        if (a === NAN)
            return NaN;
        if (a === POSITIVE_INFINITY)
            return 1 / 0;
        if (a === NEGATIVE_INFINITY)
            return -1 / 0;
        if (a === NEGATIVE_ZERO)
            return -0;
        if (s)
            throw new Error("Invalid input");
        if (a in n)
            return n[a];
        const i = r[a];
        if (!i || typeof i != "object")
            n[a] = i;
        else if (Array.isArray(i))
            if (typeof i[0] == "string") {
                const l = i[0]
                  , u = t == null ? void 0 : t[l];
                if (u)
                    return n[a] = u(o(i[1]));
                switch (l) {
                case "Date":
                    n[a] = new Date(i[1]);
                    break;
                case "Set":
                    const c = new Set;
                    n[a] = c;
                    for (let p = 1; p < i.length; p += 1)
                        c.add(o(i[p]));
                    break;
                case "Map":
                    const f = new Map;
                    n[a] = f;
                    for (let p = 1; p < i.length; p += 2)
                        f.set(o(i[p]), o(i[p + 1]));
                    break;
                case "RegExp":
                    n[a] = new RegExp(i[1],i[2]);
                    break;
                case "Object":
                    n[a] = Object(i[1]);
                    break;
                case "BigInt":
                    n[a] = BigInt(i[1]);
                    break;
                case "null":
                    const d = Object.create(null);
                    n[a] = d;
                    for (let p = 1; p < i.length; p += 2)
                        d[i[p]] = o(i[p + 1]);
                    break;
                case "Int8Array":
                case "Uint8Array":
                case "Uint8ClampedArray":
                case "Int16Array":
                case "Uint16Array":
                case "Int32Array":
                case "Uint32Array":
                case "Float32Array":
                case "Float64Array":
                case "BigInt64Array":
                case "BigUint64Array":
                    {
                        const p = globalThis[l]
                          , m = i[1]
                          , g = decode64(m)
                          , _ = new p(g);
                        n[a] = _;
                        break
                    }
                case "ArrayBuffer":
                    {
                        const p = i[1]
                          , m = decode64(p);
                        n[a] = m;
                        break
                    }
                default:
                    throw new Error(`Unknown type ${l}`)
                }
            } else {
                const l = new Array(i.length);
                n[a] = l;
                for (let u = 0; u < i.length; u += 1) {
                    const c = i[u];
                    c !== HOLE && (l[u] = o(c))
                }
            }
        else {
            const l = {};
            n[a] = l;
            for (const u in i) {
                const c = i[u];
                l[u] = o(c)
            }
        }
        return n[a]
    }
    return o(0)
}
const TagsWithInnerContent = new Set(["title", "titleTemplate", "script", "style", "noscript"])
  , HasElementTags = new Set(["base", "meta", "link", "style", "script", "noscript"])
  , ValidHeadTags = new Set(["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"])
  , UniqueTags = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"])
  , TagConfigKeys = new Set(["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"])
  , IsBrowser = typeof window < "u";
function defineHeadPlugin(e) {
    return e
}
function hashCode(e) {
    let t = 9;
    for (let r = 0; r < e.length; )
        t = Math.imul(t ^ e.charCodeAt(r++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function hashTag(e) {
    if (e._h)
        return e._h;
    if (e._d)
        return hashCode(e._d);
    let t = `${e.tag}:${e.textContent || e.innerHTML || ""}:`;
    for (const r in e.props)
        t += `${r}:${String(e.props[r])},`;
    return hashCode(t)
}
function thenable(e, t) {
    return e instanceof Promise ? e.then(t) : t(e)
}
function normaliseTag(e, t, r, n) {
    const o = n || normaliseProps(typeof t == "object" && typeof t != "function" && !(t instanceof Promise) ? {
        ...t
    } : {
        [e === "script" || e === "noscript" || e === "style" ? "innerHTML" : "textContent"]: t
    }, e === "templateParams" || e === "titleTemplate");
    if (o instanceof Promise)
        return o.then(s => normaliseTag(e, t, r, s));
    const a = {
        tag: e,
        props: o
    };
    for (const s of TagConfigKeys) {
        const i = a.props[s] !== void 0 ? a.props[s] : r[s];
        i !== void 0 && ((!(s === "innerHTML" || s === "textContent" || s === "children") || TagsWithInnerContent.has(a.tag)) && (a[s === "children" ? "innerHTML" : s] = i),
        delete a.props[s])
    }
    return a.props.body && (a.tagPosition = "bodyClose",
    delete a.props.body),
    a.tag === "script" && typeof a.innerHTML == "object" && (a.innerHTML = JSON.stringify(a.innerHTML),
    a.props.type = a.props.type || "application/json"),
    Array.isArray(a.props.content) ? a.props.content.map(s => ({
        ...a,
        props: {
            ...a.props,
            content: s
        }
    })) : a
}
function normaliseStyleClassProps(e, t) {
    var n;
    const r = e === "class" ? " " : ";";
    return t && typeof t == "object" && !Array.isArray(t) && (t = Object.entries(t).filter( ([,o]) => o).map( ([o,a]) => e === "style" ? `${o}:${a}` : o)),
    (n = String(Array.isArray(t) ? t.join(r) : t)) == null ? void 0 : n.split(r).filter(o => !!o.trim()).join(r)
}
function nestedNormaliseProps(e, t, r, n) {
    for (let o = n; o < r.length; o += 1) {
        const a = r[o];
        if (a === "class" || a === "style") {
            e[a] = normaliseStyleClassProps(a, e[a]);
            continue
        }
        if (e[a]instanceof Promise)
            return e[a].then(s => (e[a] = s,
            nestedNormaliseProps(e, t, r, o)));
        if (!t && !TagConfigKeys.has(a)) {
            const s = String(e[a])
              , i = a.startsWith("data-");
            s === "true" || s === "" ? e[a] = i ? "true" : !0 : e[a] || (i && s === "false" ? e[a] = "false" : delete e[a])
        }
    }
}
function normaliseProps(e, t=!1) {
    const r = nestedNormaliseProps(e, t, Object.keys(e), 0);
    return r instanceof Promise ? r.then( () => e) : e
}
const TagEntityBits = 10;
function nestedNormaliseEntryTags(e, t, r) {
    for (let n = r; n < t.length; n += 1) {
        const o = t[n];
        if (o instanceof Promise)
            return o.then(a => (t[n] = a,
            nestedNormaliseEntryTags(e, t, n)));
        Array.isArray(o) ? e.push(...o) : e.push(o)
    }
}
function normaliseEntryTags(e) {
    const t = []
      , r = e.resolvedInput;
    for (const o in r) {
        if (!Object.prototype.hasOwnProperty.call(r, o))
            continue;
        const a = r[o];
        if (!(a === void 0 || !ValidHeadTags.has(o))) {
            if (Array.isArray(a)) {
                for (const s of a)
                    t.push(normaliseTag(o, s, e));
                continue
            }
            t.push(normaliseTag(o, a, e))
        }
    }
    if (t.length === 0)
        return [];
    const n = [];
    return thenable(nestedNormaliseEntryTags(n, t, 0), () => n.map( (o, a) => (o._e = e._i,
    e.mode && (o._m = e.mode),
    o._p = (e._i << TagEntityBits) + a,
    o)))
}
const NetworkEvents = new Set(["onload", "onerror", "onabort", "onprogress", "onloadstart"])
  , TAG_WEIGHTS = {
    base: -10,
    title: 10
}
  , TAG_ALIASES = {
    critical: -80,
    high: -10,
    low: 20
};
function tagWeight(e) {
    const t = e.tagPriority;
    if (typeof t == "number")
        return t;
    let r = 100;
    return e.tag === "meta" ? e.props["http-equiv"] === "content-security-policy" ? r = -30 : e.props.charset ? r = -20 : e.props.name === "viewport" && (r = -15) : e.tag === "link" && e.props.rel === "preconnect" ? r = 20 : e.tag in TAG_WEIGHTS && (r = TAG_WEIGHTS[e.tag]),
    t && t in TAG_ALIASES ? r + TAG_ALIASES[t] : r
}
const SortModifiers = [{
    prefix: "before:",
    offset: -1
}, {
    prefix: "after:",
    offset: 1
}]
  , allowedMetaProperties = ["name", "property", "http-equiv"];
function tagDedupeKey(e) {
    const {props: t, tag: r} = e;
    if (UniqueTags.has(r))
        return r;
    if (r === "link" && t.rel === "canonical")
        return "canonical";
    if (t.charset)
        return "charset";
    if (t.id)
        return `${r}:id:${t.id}`;
    for (const n of allowedMetaProperties)
        if (t[n] !== void 0)
            return `${r}:${n}:${t[n]}`;
    return !1
}
const sepSub = "%separator";
function sub(e, t) {
    var n;
    let r;
    if (t === "s" || t === "pageTitle")
        r = e.pageTitle;
    else if (t.includes(".")) {
        const o = t.indexOf(".");
        r = (n = e[t.substring(0, o)]) == null ? void 0 : n[t.substring(o + 1)]
    } else
        r = e[t];
    return r !== void 0 ? (r || "").replace(/"/g, '\\"') : void 0
}
const sepSubRe = new RegExp(`${sepSub}(?:\\s*${sepSub})*`,"g");
function processTemplateParams(e, t, r) {
    if (typeof e != "string" || !e.includes("%"))
        return e;
    let n = e;
    try {
        n = decodeURI(e)
    } catch {}
    const o = n.match(/%\w+(?:\.\w+)?/g);
    if (!o)
        return e;
    const a = e.includes(sepSub);
    return e = e.replace(/%\w+(?:\.\w+)?/g, s => {
        if (s === sepSub || !o.includes(s))
            return s;
        const i = sub(t, s.slice(1));
        return i !== void 0 ? i : s
    }
    ).trim(),
    a && (e.endsWith(sepSub) && (e = e.slice(0, -sepSub.length)),
    e.startsWith(sepSub) && (e = e.slice(sepSub.length)),
    e = e.replace(sepSubRe, r).trim()),
    e
}
function resolveTitleTemplate(e, t) {
    return e == null ? t || null : typeof e == "function" ? e(t) : e
}
async function renderDOMHead(e, t={}) {
    const r = t.document || e.resolvedOptions.document;
    if (!r || !e.dirty)
        return;
    const n = {
        shouldRender: !0,
        tags: []
    };
    if (await e.hooks.callHook("dom:beforeRender", n),
    !!n.shouldRender)
        return e._domUpdatePromise || (e._domUpdatePromise = new Promise(async o => {
            var f;
            const a = (await e.resolveTags()).map(d => ({
                tag: d,
                id: HasElementTags.has(d.tag) ? hashTag(d) : d.tag,
                shouldRender: !0
            }));
            let s = e._dom;
            if (!s) {
                s = {
                    elMap: {
                        htmlAttrs: r.documentElement,
                        bodyAttrs: r.body
                    }
                };
                const d = new Set;
                for (const p of ["body", "head"]) {
                    const m = (f = r[p]) == null ? void 0 : f.children;
                    for (const g of m) {
                        const _ = g.tagName.toLowerCase();
                        if (!HasElementTags.has(_))
                            continue;
                        const b = {
                            tag: _,
                            props: await normaliseProps(g.getAttributeNames().reduce( (C, x) => ({
                                ...C,
                                [x]: g.getAttribute(x)
                            }), {})),
                            innerHTML: g.innerHTML
                        }
                          , y = tagDedupeKey(b);
                        let v = y
                          , S = 1;
                        for (; v && d.has(v); )
                            v = `${y}:${S++}`;
                        v && (b._d = v,
                        d.add(v)),
                        s.elMap[g.getAttribute("data-hid") || hashTag(b)] = g
                    }
                }
            }
            s.pendingSideEffects = {
                ...s.sideEffects
            },
            s.sideEffects = {};
            function i(d, p, m) {
                const g = `${d}:${p}`;
                s.sideEffects[g] = m,
                delete s.pendingSideEffects[g]
            }
            function l({id: d, $el: p, tag: m}) {
                const g = m.tag.endsWith("Attrs");
                if (s.elMap[d] = p,
                g || (m.textContent && m.textContent !== p.textContent && (p.textContent = m.textContent),
                m.innerHTML && m.innerHTML !== p.innerHTML && (p.innerHTML = m.innerHTML),
                i(d, "el", () => {
                    var _;
                    (_ = s.elMap[d]) == null || _.remove(),
                    delete s.elMap[d]
                }
                )),
                m._eventHandlers)
                    for (const _ in m._eventHandlers)
                        Object.prototype.hasOwnProperty.call(m._eventHandlers, _) && p.getAttribute(`data-${_}`) !== "" && ((m.tag === "bodyAttrs" ? r.defaultView : p).addEventListener(_.substring(2), m._eventHandlers[_].bind(p)),
                        p.setAttribute(`data-${_}`, ""));
                for (const _ in m.props) {
                    if (!Object.prototype.hasOwnProperty.call(m.props, _))
                        continue;
                    const b = m.props[_]
                      , y = `attr:${_}`;
                    if (_ === "class") {
                        if (!b)
                            continue;
                        for (const v of b.split(" "))
                            g && i(d, `${y}:${v}`, () => p.classList.remove(v)),
                            !p.classList.contains(v) && p.classList.add(v)
                    } else if (_ === "style") {
                        if (!b)
                            continue;
                        for (const v of b.split(";")) {
                            const S = v.indexOf(":")
                              , C = v.substring(0, S).trim()
                              , x = v.substring(S + 1).trim();
                            i(d, `${y}:${C}`, () => {
                                p.style.removeProperty(C)
                            }
                            ),
                            p.style.setProperty(C, x)
                        }
                    } else
                        p.getAttribute(_) !== b && p.setAttribute(_, b === !0 ? "" : String(b)),
                        g && i(d, y, () => p.removeAttribute(_))
                }
            }
            const u = []
              , c = {
                bodyClose: void 0,
                bodyOpen: void 0,
                head: void 0
            };
            for (const d of a) {
                const {tag: p, shouldRender: m, id: g} = d;
                if (m) {
                    if (p.tag === "title") {
                        r.title = p.textContent;
                        continue
                    }
                    d.$el = d.$el || s.elMap[g],
                    d.$el ? l(d) : HasElementTags.has(p.tag) && u.push(d)
                }
            }
            for (const d of u) {
                const p = d.tag.tagPosition || "head";
                d.$el = r.createElement(d.tag.tag),
                l(d),
                c[p] = c[p] || r.createDocumentFragment(),
                c[p].appendChild(d.$el)
            }
            for (const d of a)
                await e.hooks.callHook("dom:renderTag", d, r, i);
            c.head && r.head.appendChild(c.head),
            c.bodyOpen && r.body.insertBefore(c.bodyOpen, r.body.firstChild),
            c.bodyClose && r.body.appendChild(c.bodyClose);
            for (const d in s.pendingSideEffects)
                s.pendingSideEffects[d]();
            e._dom = s,
            await e.hooks.callHook("dom:rendered", {
                renders: a
            }),
            o()
        }
        ).finally( () => {
            e._domUpdatePromise = void 0,
            e.dirty = !1
        }
        )),
        e._domUpdatePromise
}
function debouncedRenderDOMHead(e, t={}) {
    const r = t.delayFn || (n => setTimeout(n, 10));
    return e._domDebouncedUpdatePromise = e._domDebouncedUpdatePromise || new Promise(n => r( () => renderDOMHead(e, t).then( () => {
        delete e._domDebouncedUpdatePromise,
        n()
    }
    )))
}
function DomPlugin(e) {
    return t => {
        var n, o;
        const r = ((o = (n = t.resolvedOptions.document) == null ? void 0 : n.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : o.innerHTML) || !1;
        return r && t.push(JSON.parse(r)),
        {
            mode: "client",
            hooks: {
                "entries:updated": a => {
                    debouncedRenderDOMHead(a, e)
                }
            }
        }
    }
}
const UsesMergeStrategy = new Set(["templateParams", "htmlAttrs", "bodyAttrs"])
  , DedupePlugin = {
    hooks: {
        "tag:normalise": ({tag: e}) => {
            e.props.hid && (e.key = e.props.hid,
            delete e.props.hid),
            e.props.vmid && (e.key = e.props.vmid,
            delete e.props.vmid),
            e.props.key && (e.key = e.props.key,
            delete e.props.key);
            const t = tagDedupeKey(e);
            t && !t.startsWith("meta:og:") && !t.startsWith("meta:twitter:") && delete e.key;
            const r = t || (e.key ? `${e.tag}:${e.key}` : !1);
            r && (e._d = r)
        }
        ,
        "tags:resolve": e => {
            const t = Object.create(null);
            for (const n of e.tags) {
                const o = (n.key ? `${n.tag}:${n.key}` : n._d) || hashTag(n)
                  , a = t[o];
                if (a) {
                    let i = n == null ? void 0 : n.tagDuplicateStrategy;
                    if (!i && UsesMergeStrategy.has(n.tag) && (i = "merge"),
                    i === "merge") {
                        const l = a.props;
                        l.style && n.props.style && (l.style[l.style.length - 1] !== ";" && (l.style += ";"),
                        n.props.style = `${l.style} ${n.props.style}`),
                        l.class && n.props.class ? n.props.class = `${l.class} ${n.props.class}` : l.class && (n.props.class = l.class),
                        t[o].props = {
                            ...l,
                            ...n.props
                        };
                        continue
                    } else if (n._e === a._e) {
                        a._duped = a._duped || [],
                        n._d = `${a._d}:${a._duped.length + 1}`,
                        a._duped.push(n);
                        continue
                    } else if (tagWeight(n) > tagWeight(a))
                        continue
                }
                if (!(n.innerHTML || n.textContent || Object.keys(n.props).length !== 0) && HasElementTags.has(n.tag)) {
                    delete t[o];
                    continue
                }
                t[o] = n
            }
            const r = [];
            for (const n in t) {
                const o = t[n]
                  , a = o._duped;
                r.push(o),
                a && (delete o._duped,
                r.push(...a))
            }
            e.tags = r,
            e.tags = e.tags.filter(n => !(n.tag === "meta" && (n.props.name || n.props.property) && !n.props.content))
        }
    }
}
  , ValidEventTags = new Set(["script", "link", "bodyAttrs"])
  , EventHandlersPlugin = e => ({
    hooks: {
        "tags:resolve": t => {
            for (const r of t.tags) {
                if (!ValidEventTags.has(r.tag))
                    continue;
                const n = r.props;
                for (const o in n) {
                    if (o[0] !== "o" || o[1] !== "n" || !Object.prototype.hasOwnProperty.call(n, o))
                        continue;
                    const a = n[o];
                    typeof a == "function" && (e.ssr && NetworkEvents.has(o) ? n[o] = `this.dataset.${o}fired = true` : delete n[o],
                    r._eventHandlers = r._eventHandlers || {},
                    r._eventHandlers[o] = a)
                }
                e.ssr && r._eventHandlers && (r.props.src || r.props.href) && (r.key = r.key || hashCode(r.props.src || r.props.href))
            }
        }
        ,
        "dom:renderTag": ({$el: t, tag: r}) => {
            var o, a;
            const n = t == null ? void 0 : t.dataset;
            if (n)
                for (const s in n) {
                    if (!s.endsWith("fired"))
                        continue;
                    const i = s.slice(0, -5);
                    NetworkEvents.has(i) && ((a = (o = r._eventHandlers) == null ? void 0 : o[i]) == null || a.call(t, new Event(i.substring(2))))
                }
        }
    }
})
  , DupeableTags = new Set(["link", "style", "script", "noscript"])
  , HashKeyedPlugin = {
    hooks: {
        "tag:normalise": ({tag: e}) => {
            e.key && DupeableTags.has(e.tag) && (e.props["data-hid"] = e._h = hashCode(e.key))
        }
    }
}
  , PayloadPlugin = {
    mode: "server",
    hooks: {
        "tags:beforeResolve": e => {
            const t = {};
            let r = !1;
            for (const n of e.tags)
                n._m !== "server" || n.tag !== "titleTemplate" && n.tag !== "templateParams" && n.tag !== "title" || (t[n.tag] = n.tag === "title" || n.tag === "titleTemplate" ? n.textContent : n.props,
                r = !0);
            r && e.tags.push({
                tag: "script",
                innerHTML: JSON.stringify(t),
                props: {
                    id: "unhead:payload",
                    type: "application/json"
                }
            })
        }
    }
}
  , SortPlugin = {
    hooks: {
        "tags:resolve": e => {
            var t;
            for (const r of e.tags)
                if (typeof r.tagPriority == "string")
                    for (const {prefix: n, offset: o} of SortModifiers) {
                        if (!r.tagPriority.startsWith(n))
                            continue;
                        const a = r.tagPriority.substring(n.length)
                          , s = (t = e.tags.find(i => i._d === a)) == null ? void 0 : t._p;
                        if (s !== void 0) {
                            r._p = s + o;
                            break
                        }
                    }
            e.tags.sort( (r, n) => {
                const o = tagWeight(r)
                  , a = tagWeight(n);
                return o < a ? -1 : o > a ? 1 : r._p - n._p
            }
            )
        }
    }
}
  , SupportedAttrs = {
    meta: "content",
    link: "href",
    htmlAttrs: "lang"
}
  , contentAttrs = ["innerHTML", "textContent"]
  , TemplateParamsPlugin = e => ({
    hooks: {
        "tags:resolve": t => {
            var s;
            const {tags: r} = t;
            let n;
            for (let i = 0; i < r.length; i += 1)
                r[i].tag === "templateParams" && (n = t.tags.splice(i, 1)[0].props,
                i -= 1);
            const o = n || {}
              , a = o.separator || "|";
            delete o.separator,
            o.pageTitle = processTemplateParams(o.pageTitle || ((s = r.find(i => i.tag === "title")) == null ? void 0 : s.textContent) || "", o, a);
            for (const i of r) {
                if (i.processTemplateParams === !1)
                    continue;
                const l = SupportedAttrs[i.tag];
                if (l && typeof i.props[l] == "string")
                    i.props[l] = processTemplateParams(i.props[l], o, a);
                else if (i.processTemplateParams || i.tag === "titleTemplate" || i.tag === "title")
                    for (const u of contentAttrs)
                        typeof i[u] == "string" && (i[u] = processTemplateParams(i[u], o, a))
            }
            e._templateParams = o,
            e._separator = a
        }
        ,
        "tags:afterResolve": ({tags: t}) => {
            let r;
            for (let n = 0; n < t.length; n += 1) {
                const o = t[n];
                o.tag === "title" && o.processTemplateParams !== !1 && (r = o)
            }
            r != null && r.textContent && (r.textContent = processTemplateParams(r.textContent, e._templateParams, e._separator))
        }
    }
})
  , TitleTemplatePlugin = {
    hooks: {
        "tags:resolve": e => {
            const {tags: t} = e;
            let r, n;
            for (let o = 0; o < t.length; o += 1) {
                const a = t[o];
                a.tag === "title" ? r = a : a.tag === "titleTemplate" && (n = a)
            }
            if (n && r) {
                const o = resolveTitleTemplate(n.textContent, r.textContent);
                o !== null ? r.textContent = o || r.textContent : e.tags.splice(e.tags.indexOf(r), 1)
            } else if (n) {
                const o = resolveTitleTemplate(n.textContent);
                o !== null && (n.textContent = o,
                n.tag = "title",
                n = void 0)
            }
            n && e.tags.splice(e.tags.indexOf(n), 1)
        }
    }
}
  , XSSPlugin = {
    hooks: {
        "tags:afterResolve": e => {
            for (const t of e.tags)
                typeof t.innerHTML == "string" && (t.innerHTML && (t.props.type === "application/ld+json" || t.props.type === "application/json") ? t.innerHTML = t.innerHTML.replace(/</g, "\\u003C") : t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`,"g"), `<\\/${t.tag}`))
        }
    }
};
let activeHead;
function createHead$1(e={}) {
    const t = createHeadCore(e);
    return t.use(DomPlugin()),
    activeHead = t
}
function filterMode(e, t) {
    return !e || e === "server" && t || e === "client" && !t
}
function createHeadCore(e={}) {
    const t = createHooks();
    t.addHooks(e.hooks || {}),
    e.document = e.document || (IsBrowser ? document : void 0);
    const r = !e.document
      , n = () => {
        i.dirty = !0,
        t.callHook("entries:updated", i)
    }
    ;
    let o = 0
      , a = [];
    const s = []
      , i = {
        plugins: s,
        dirty: !1,
        resolvedOptions: e,
        hooks: t,
        headEntries() {
            return a
        },
        use(l) {
            const u = typeof l == "function" ? l(i) : l;
            (!u.key || !s.some(c => c.key === u.key)) && (s.push(u),
            filterMode(u.mode, r) && t.addHooks(u.hooks || {}))
        },
        push(l, u) {
            u == null || delete u.head;
            const c = {
                _i: o++,
                input: l,
                ...u
            };
            return filterMode(c.mode, r) && (a.push(c),
            n()),
            {
                dispose() {
                    a = a.filter(f => f._i !== c._i),
                    n()
                },
                patch(f) {
                    for (const d of a)
                        d._i === c._i && (d.input = c.input = f);
                    n()
                }
            }
        },
        async resolveTags() {
            const l = {
                tags: [],
                entries: [...a]
            };
            await t.callHook("entries:resolve", l);
            for (const u of l.entries) {
                const c = u.resolvedInput || u.input;
                if (u.resolvedInput = await (u.transform ? u.transform(c) : c),
                u.resolvedInput)
                    for (const f of await normaliseEntryTags(u)) {
                        const d = {
                            tag: f,
                            entry: u,
                            resolvedOptions: i.resolvedOptions
                        };
                        await t.callHook("tag:normalise", d),
                        l.tags.push(d.tag)
                    }
            }
            return await t.callHook("tags:beforeResolve", l),
            await t.callHook("tags:resolve", l),
            await t.callHook("tags:afterResolve", l),
            l.tags
        },
        ssr: r
    };
    return [DedupePlugin, PayloadPlugin, EventHandlersPlugin, HashKeyedPlugin, SortPlugin, TemplateParamsPlugin, TitleTemplatePlugin, XSSPlugin, ...(e == null ? void 0 : e.plugins) || []].forEach(l => i.use(l)),
    i.hooks.callHook("init", i),
    i
}
function getActiveHead() {
    return activeHead
}
const Vue3 = version[0] === "3";
function resolveUnref$1(e) {
    return typeof e == "function" ? e() : unref(e)
}
function resolveUnrefHeadInput(e) {
    if (e instanceof Promise || e instanceof Date || e instanceof RegExp)
        return e;
    const t = resolveUnref$1(e);
    if (!e || !t)
        return t;
    if (Array.isArray(t))
        return t.map(r => resolveUnrefHeadInput(r));
    if (typeof t == "object") {
        const r = {};
        for (const n in t)
            if (Object.prototype.hasOwnProperty.call(t, n)) {
                if (n === "titleTemplate" || n[0] === "o" && n[1] === "n") {
                    r[n] = unref(t[n]);
                    continue
                }
                r[n] = resolveUnrefHeadInput(t[n])
            }
        return r
    }
    return t
}
const VueReactivityPlugin = {
    hooks: {
        "entries:resolve": e => {
            for (const t of e.entries)
                t.resolvedInput = resolveUnrefHeadInput(t.input)
        }
    }
}
  , headSymbol = "usehead";
function vueInstall(e) {
    return {
        install(r) {
            Vue3 && (r.config.globalProperties.$unhead = e,
            r.config.globalProperties.$head = e,
            r.provide(headSymbol, e))
        }
    }.install
}
function createHead(e={}) {
    e.domDelayFn = e.domDelayFn || (r => nextTick( () => setTimeout( () => r(), 0)));
    const t = createHead$1(e);
    return t.use(VueReactivityPlugin),
    t.install = vueInstall(t),
    t
}
const _global$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , globalKey$2 = "__unhead_injection_handler__";
function setHeadInjectionHandler(e) {
    _global$2[globalKey$2] = e
}
function injectHead() {
    if (globalKey$2 in _global$2)
        return _global$2[globalKey$2]();
    const e = inject(headSymbol);
    return e || getActiveHead()
}
function useHead(e, t={}) {
    const r = t.head || injectHead();
    if (r)
        return r.ssr ? r.push(e, t) : clientUseHead(r, e, t)
}
function clientUseHead(e, t, r={}) {
    const n = ref(!1)
      , o = ref({});
    watchEffect( () => {
        o.value = n.value ? {} : resolveUnrefHeadInput(t)
    }
    );
    const a = e.push(o.value, r);
    return watch(o, i => {
        a.patch(i)
    }
    ),
    getCurrentInstance() && (onBeforeUnmount( () => {
        a.dispose()
    }
    ),
    onDeactivated( () => {
        n.value = !0
    }
    ),
    onActivated( () => {
        n.value = !1
    }
    )),
    a
}
let manifest, matcher;
function fetchManifest() {
    return manifest = $fetch(buildAssetsURL(`builds/meta/${useRuntimeConfig().app.buildId}.json`), {
        responseType: "json"
    }),
    manifest.then(e => {
        matcher = createMatcherFromExport(e.matcher)
    }
    ).catch(e => {
        console.error("[nuxt] Error fetching app manifest.", e)
    }
    ),
    manifest
}
function getAppManifest() {
    return manifest || fetchManifest()
}
async function getRouteRules(e) {
    if (await getAppManifest(),
    !matcher)
        return console.error("[nuxt] Error creating app manifest matcher.", matcher),
        {};
    try {
        return defu({}, ...matcher.matchAll(e).reverse())
    } catch (t) {
        return console.error("[nuxt] Error matching route rules.", t),
        {}
    }
}
async function loadPayload(e, t={}) {
    const r = await _getPayloadURL(e, t)
      , n = useNuxtApp()
      , o = n._payloadCache = n._payloadCache || {};
    return r in o || (o[r] = isPrerendered(e).then(a => a ? _importPayload(r).then(s => s || (delete o[r],
    null)) : (o[r] = null,
    null))),
    o[r]
}
const filename = "_payload.json";
async function _getPayloadURL(e, t={}) {
    const r = new URL(e,"http://localhost");
    if (r.host !== "localhost" || hasProtocol(r.pathname, {
        acceptRelative: !0
    }))
        throw new Error("Payload URL must not include hostname: " + e);
    const n = useRuntimeConfig()
      , o = t.hash || (t.fresh ? Date.now() : n.app.buildId)
      , a = n.app.cdnURL
      , s = a && await isPrerendered(e) ? a : n.app.baseURL;
    return joinURL(s, r.pathname, filename + (o ? `?${o}` : ""))
}
async function _importPayload(e) {
    const t = fetch(e).then(r => r.text().then(parsePayload));
    try {
        return await t
    } catch (r) {
        console.warn("[nuxt] Cannot load payload ", e, r)
    }
    return null
}
async function isPrerendered(e=useRoute$1().path) {
    if (e = withoutTrailingSlash(e),
    (await getAppManifest()).prerendered.includes(e))
        return !0;
    const r = await getRouteRules(e);
    return !!r.prerender && !r.redirect
}
let payloadCache = null;
async function getNuxtClientPayload() {
    var n;
    if (payloadCache)
        return payloadCache;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e)
        return {};
    const t = await parsePayload(e.textContent || "")
      , r = e.dataset.src ? await _importPayload(e.dataset.src) : void 0;
    return payloadCache = {
        ...t,
        ...r,
        ...window.__NUXT__
    },
    (n = payloadCache.config) != null && n.public && (payloadCache.config.public = reactive(payloadCache.config.public)),
    payloadCache
}
async function parsePayload(e) {
    return await parse$2(e, useNuxtApp()._payloadRevivers)
}
function definePayloadReviver(e, t) {
    useNuxtApp()._payloadRevivers[e] = t
}
const payloadPlugin = definePayloadPlugin( () => {
    definePayloadReviver("skipHydrate", e => {}
    )
}
)
  , revivers = {
    NuxtError: e => createError(e),
    EmptyShallowRef: e => shallowRef(e === "_" ? void 0 : e === "0n" ? BigInt(0) : destr(e)),
    EmptyRef: e => ref(e === "_" ? void 0 : e === "0n" ? BigInt(0) : destr(e)),
    ShallowRef: e => shallowRef(e),
    ShallowReactive: e => shallowReactive(e),
    Ref: e => ref(e),
    Reactive: e => reactive(e)
}
  , revive_payload_client_SjK25sGxMS = defineNuxtPlugin({
    name: "nuxt:revive-payload:client",
    order: -30,
    async setup(e) {
        let t, r;
        for (const n in revivers)
            definePayloadReviver(n, revivers[n]);
        Object.assign(e.payload, ([t,r] = executeAsync( () => e.runWithContext(getNuxtClientPayload)),
        t = await t,
        r(),
        t)),
        window.__NUXT__ = e.payload
    }
})
  , unheadPlugins = []
  , unhead_pUDVp0zH3P = defineNuxtPlugin({
    name: "nuxt:head",
    enforce: "pre",
    setup(e) {
        const t = createHead({
            plugins: unheadPlugins
        });
        setHeadInjectionHandler( () => useNuxtApp().vueApp._context.provides.usehead),
        e.vueApp.use(t);
        {
            let r = !0;
            const n = async () => {
                r = !1,
                await renderDOMHead(t)
            }
            ;
            t.hooks.hook("dom:beforeRender", o => {
                o.shouldRender = !r
            }
            ),
            e.hooks.hook("page:start", () => {
                r = !0
            }
            ),
            e.hooks.hook("page:finish", () => {
                e.isHydrating || n()
            }
            ),
            e.hooks.hook("app:error", n),
            e.hooks.hook("app:suspense:resolve", n)
        }
    }
});
/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof document < "u";
function isRouteComponent(e) {
    return typeof e == "object" || "displayName"in e || "props"in e || "__vccOpts"in e
}
function isESModule(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && isRouteComponent(e.default)
}
const assign$1 = Object.assign;
function applyToParams(e, t) {
    const r = {};
    for (const n in t) {
        const o = t[n];
        r[n] = isArray$6(o) ? o.map(e) : e(o)
    }
    return r
}
const noop$2 = () => {}
  , isArray$6 = Array.isArray
  , HASH_RE = /#/g
  , AMPERSAND_RE = /&/g
  , SLASH_RE = /\//g
  , EQUAL_RE = /=/g
  , IM_RE = /\?/g
  , PLUS_RE = /\+/g
  , ENC_BRACKET_OPEN_RE = /%5B/g
  , ENC_BRACKET_CLOSE_RE = /%5D/g
  , ENC_CARET_RE = /%5E/g
  , ENC_BACKTICK_RE = /%60/g
  , ENC_CURLY_OPEN_RE = /%7B/g
  , ENC_PIPE_RE = /%7C/g
  , ENC_CURLY_CLOSE_RE = /%7D/g
  , ENC_SPACE_RE = /%20/g;
function commonEncode(e) {
    return encodeURI("" + e).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]")
}
function encodeHash(e) {
    return commonEncode(e).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryValue(e) {
    return commonEncode(e).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryKey(e) {
    return encodeQueryValue(e).replace(EQUAL_RE, "%3D")
}
function encodePath(e) {
    return commonEncode(e).replace(HASH_RE, "%23").replace(IM_RE, "%3F")
}
function encodeParam(e) {
    return e == null ? "" : encodePath(e).replace(SLASH_RE, "%2F")
}
function decode$1(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
const TRAILING_SLASH_RE = /\/$/
  , removeTrailingSlash = e => e.replace(TRAILING_SLASH_RE, "");
function parseURL(e, t, r="/") {
    let n, o = {}, a = "", s = "";
    const i = t.indexOf("#");
    let l = t.indexOf("?");
    return i < l && i >= 0 && (l = -1),
    l > -1 && (n = t.slice(0, l),
    a = t.slice(l + 1, i > -1 ? i : t.length),
    o = e(a)),
    i > -1 && (n = n || t.slice(0, i),
    s = t.slice(i, t.length)),
    n = resolveRelativePath(n ?? t, r),
    {
        fullPath: n + (a && "?") + a + s,
        path: n,
        query: o,
        hash: decode$1(s)
    }
}
function stringifyURL(e, t) {
    const r = t.query ? e(t.query) : "";
    return t.path + (r && "?") + r + (t.hash || "")
}
function stripBase(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function isSameRouteLocation(e, t, r) {
    const n = t.matched.length - 1
      , o = r.matched.length - 1;
    return n > -1 && n === o && isSameRouteRecord(t.matched[n], r.matched[o]) && isSameRouteLocationParams(t.params, r.params) && e(t.query) === e(r.query) && t.hash === r.hash
}
function isSameRouteRecord(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function isSameRouteLocationParams(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const r in e)
        if (!isSameRouteLocationParamsValue(e[r], t[r]))
            return !1;
    return !0
}
function isSameRouteLocationParamsValue(e, t) {
    return isArray$6(e) ? isEquivalentArray(e, t) : isArray$6(t) ? isEquivalentArray(t, e) : e === t
}
function isEquivalentArray(e, t) {
    return isArray$6(t) ? e.length === t.length && e.every( (r, n) => r === t[n]) : e.length === 1 && e[0] === t
}
function resolveRelativePath(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const r = t.split("/")
      , n = e.split("/")
      , o = n[n.length - 1];
    (o === ".." || o === ".") && n.push("");
    let a = r.length - 1, s, i;
    for (s = 0; s < n.length; s++)
        if (i = n[s],
        i !== ".")
            if (i === "..")
                a > 1 && a--;
            else
                break;
    return r.slice(0, a).join("/") + "/" + n.slice(s).join("/")
}
const START_LOCATION_NORMALIZED = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var NavigationType;
(function(e) {
    e.pop = "pop",
    e.push = "push"
}
)(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(e) {
    e.back = "back",
    e.forward = "forward",
    e.unknown = ""
}
)(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(e) {
    if (!e)
        if (isBrowser) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/",
            e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
    removeTrailingSlash(e)
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(e, t) {
    return e.replace(BEFORE_HASH_RE, "#") + t
}
function getElementPosition(e, t) {
    const r = document.documentElement.getBoundingClientRect()
      , n = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: n.left - r.left - (t.left || 0),
        top: n.top - r.top - (t.top || 0)
    }
}
const computeScrollPosition = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function scrollToPosition(e) {
    let t;
    if ("el"in e) {
        const r = e.el
          , n = typeof r == "string" && r.startsWith("#")
          , o = typeof r == "string" ? n ? document.getElementById(r.slice(1)) : document.querySelector(r) : r;
        if (!o)
            return;
        t = getElementPosition(o, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function getScrollKey(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const scrollPositions = new Map;
function saveScrollPosition(e, t) {
    scrollPositions.set(e, t)
}
function getSavedScrollPosition(e) {
    const t = scrollPositions.get(e);
    return scrollPositions.delete(e),
    t
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation$1(e, t) {
    const {pathname: r, search: n, hash: o} = t
      , a = e.indexOf("#");
    if (a > -1) {
        let i = o.includes(e.slice(a)) ? e.slice(a).length : 1
          , l = o.slice(i);
        return l[0] !== "/" && (l = "/" + l),
        stripBase(l, "")
    }
    return stripBase(r, e) + n + o
}
function useHistoryListeners(e, t, r, n) {
    let o = []
      , a = []
      , s = null;
    const i = ({state: d}) => {
        const p = createCurrentLocation$1(e, location)
          , m = r.value
          , g = t.value;
        let _ = 0;
        if (d) {
            if (r.value = p,
            t.value = d,
            s && s === m) {
                s = null;
                return
            }
            _ = g ? d.position - g.position : 0
        } else
            n(p);
        o.forEach(b => {
            b(r.value, m, {
                delta: _,
                type: NavigationType.pop,
                direction: _ ? _ > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
            })
        }
        )
    }
    ;
    function l() {
        s = r.value
    }
    function u(d) {
        o.push(d);
        const p = () => {
            const m = o.indexOf(d);
            m > -1 && o.splice(m, 1)
        }
        ;
        return a.push(p),
        p
    }
    function c() {
        const {history: d} = window;
        d.state && d.replaceState(assign$1({}, d.state, {
            scroll: computeScrollPosition()
        }), "")
    }
    function f() {
        for (const d of a)
            d();
        a = [],
        window.removeEventListener("popstate", i),
        window.removeEventListener("beforeunload", c)
    }
    return window.addEventListener("popstate", i),
    window.addEventListener("beforeunload", c, {
        passive: !0
    }),
    {
        pauseListeners: l,
        listen: u,
        destroy: f
    }
}
function buildState(e, t, r, n=!1, o=!1) {
    return {
        back: e,
        current: t,
        forward: r,
        replaced: n,
        position: window.history.length,
        scroll: o ? computeScrollPosition() : null
    }
}
function useHistoryStateNavigation(e) {
    const {history: t, location: r} = window
      , n = {
        value: createCurrentLocation$1(e, r)
    }
      , o = {
        value: t.state
    };
    o.value || a(n.value, {
        back: null,
        current: n.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function a(l, u, c) {
        const f = e.indexOf("#")
          , d = f > -1 ? (r.host && document.querySelector("base") ? e : e.slice(f)) + l : createBaseLocation() + e + l;
        try {
            t[c ? "replaceState" : "pushState"](u, "", d),
            o.value = u
        } catch (p) {
            console.error(p),
            r[c ? "replace" : "assign"](d)
        }
    }
    function s(l, u) {
        const c = assign$1({}, t.state, buildState(o.value.back, l, o.value.forward, !0), u, {
            position: o.value.position
        });
        a(l, c, !0),
        n.value = l
    }
    function i(l, u) {
        const c = assign$1({}, o.value, t.state, {
            forward: l,
            scroll: computeScrollPosition()
        });
        a(c.current, c, !0);
        const f = assign$1({}, buildState(n.value, l, null), {
            position: c.position + 1
        }, u);
        a(l, f, !1),
        n.value = l
    }
    return {
        location: n,
        state: o,
        push: i,
        replace: s
    }
}
function createWebHistory(e) {
    e = normalizeBase(e);
    const t = useHistoryStateNavigation(e)
      , r = useHistoryListeners(e, t.state, t.location, t.replace);
    function n(a, s=!0) {
        s || r.pauseListeners(),
        history.go(a)
    }
    const o = assign$1({
        location: "",
        base: e,
        go: n,
        createHref: createHref.bind(null, e)
    }, t, r);
    return Object.defineProperty(o, "location", {
        enumerable: !0,
        get: () => t.location.value
    }),
    Object.defineProperty(o, "state", {
        enumerable: !0,
        get: () => t.state.value
    }),
    o
}
function createWebHashHistory(e) {
    return e = location.host ? e || location.pathname + location.search : "",
    e.includes("#") || (e += "#"),
    createWebHistory(e)
}
function isRouteLocation(e) {
    return typeof e == "string" || e && typeof e == "object"
}
function isRouteName(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(e) {
    e[e.aborted = 4] = "aborted",
    e[e.cancelled = 8] = "cancelled",
    e[e.duplicated = 16] = "duplicated"
}
)(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(e, t) {
    return assign$1(new Error, {
        type: e,
        [NavigationFailureSymbol]: !0
    }, t)
}
function isNavigationFailure(e, t) {
    return e instanceof Error && NavigationFailureSymbol in e && (t == null || !!(e.type & t))
}
const BASE_PARAM_PATTERN = "[^/]+?"
  , BASE_PATH_PARSER_OPTIONS = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(e, t) {
    const r = assign$1({}, BASE_PATH_PARSER_OPTIONS, t)
      , n = [];
    let o = r.start ? "^" : "";
    const a = [];
    for (const u of e) {
        const c = u.length ? [] : [90];
        r.strict && !u.length && (o += "/");
        for (let f = 0; f < u.length; f++) {
            const d = u[f];
            let p = 40 + (r.sensitive ? .25 : 0);
            if (d.type === 0)
                f || (o += "/"),
                o += d.value.replace(REGEX_CHARS_RE, "\\$&"),
                p += 40;
            else if (d.type === 1) {
                const {value: m, repeatable: g, optional: _, regexp: b} = d;
                a.push({
                    name: m,
                    repeatable: g,
                    optional: _
                });
                const y = b || BASE_PARAM_PATTERN;
                if (y !== BASE_PARAM_PATTERN) {
                    p += 10;
                    try {
                        new RegExp(`(${y})`)
                    } catch (S) {
                        throw new Error(`Invalid custom RegExp for param "${m}" (${y}): ` + S.message)
                    }
                }
                let v = g ? `((?:${y})(?:/(?:${y}))*)` : `(${y})`;
                f || (v = _ && u.length < 2 ? `(?:/${v})` : "/" + v),
                _ && (v += "?"),
                o += v,
                p += 20,
                _ && (p += -8),
                g && (p += -20),
                y === ".*" && (p += -50)
            }
            c.push(p)
        }
        n.push(c)
    }
    if (r.strict && r.end) {
        const u = n.length - 1;
        n[u][n[u].length - 1] += .7000000000000001
    }
    r.strict || (o += "/?"),
    r.end ? o += "$" : r.strict && (o += "(?:/|$)");
    const s = new RegExp(o,r.sensitive ? "" : "i");
    function i(u) {
        const c = u.match(s)
          , f = {};
        if (!c)
            return null;
        for (let d = 1; d < c.length; d++) {
            const p = c[d] || ""
              , m = a[d - 1];
            f[m.name] = p && m.repeatable ? p.split("/") : p
        }
        return f
    }
    function l(u) {
        let c = ""
          , f = !1;
        for (const d of e) {
            (!f || !c.endsWith("/")) && (c += "/"),
            f = !1;
            for (const p of d)
                if (p.type === 0)
                    c += p.value;
                else if (p.type === 1) {
                    const {value: m, repeatable: g, optional: _} = p
                      , b = m in u ? u[m] : "";
                    if (isArray$6(b) && !g)
                        throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);
                    const y = isArray$6(b) ? b.join("/") : b;
                    if (!y)
                        if (_)
                            d.length < 2 && (c.endsWith("/") ? c = c.slice(0, -1) : f = !0);
                        else
                            throw new Error(`Missing required param "${m}"`);
                    c += y
                }
        }
        return c || "/"
    }
    return {
        re: s,
        score: n,
        keys: a,
        parse: i,
        stringify: l
    }
}
function compareScoreArray(e, t) {
    let r = 0;
    for (; r < e.length && r < t.length; ) {
        const n = t[r] - e[r];
        if (n)
            return n;
        r++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}
function comparePathParserScore(e, t) {
    let r = 0;
    const n = e.score
      , o = t.score;
    for (; r < n.length && r < o.length; ) {
        const a = compareScoreArray(n[r], o[r]);
        if (a)
            return a;
        r++
    }
    if (Math.abs(o.length - n.length) === 1) {
        if (isLastScoreNegative(n))
            return 1;
        if (isLastScoreNegative(o))
            return -1
    }
    return o.length - n.length
}
function isLastScoreNegative(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const ROOT_TOKEN = {
    type: 0,
    value: ""
}
  , VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(e) {
    if (!e)
        return [[]];
    if (e === "/")
        return [[ROOT_TOKEN]];
    if (!e.startsWith("/"))
        throw new Error(`Invalid path "${e}"`);
    function t(p) {
        throw new Error(`ERR (${r})/"${u}": ${p}`)
    }
    let r = 0
      , n = r;
    const o = [];
    let a;
    function s() {
        a && o.push(a),
        a = []
    }
    let i = 0, l, u = "", c = "";
    function f() {
        u && (r === 0 ? a.push({
            type: 0,
            value: u
        }) : r === 1 || r === 2 || r === 3 ? (a.length > 1 && (l === "*" || l === "+") && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),
        a.push({
            type: 1,
            value: u,
            regexp: c,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : t("Invalid state to consume buffer"),
        u = "")
    }
    function d() {
        u += l
    }
    for (; i < e.length; ) {
        if (l = e[i++],
        l === "\\" && r !== 2) {
            n = r,
            r = 4;
            continue
        }
        switch (r) {
        case 0:
            l === "/" ? (u && f(),
            s()) : l === ":" ? (f(),
            r = 1) : d();
            break;
        case 4:
            d(),
            r = n;
            break;
        case 1:
            l === "(" ? r = 2 : VALID_PARAM_RE.test(l) ? d() : (f(),
            r = 0,
            l !== "*" && l !== "?" && l !== "+" && i--);
            break;
        case 2:
            l === ")" ? c[c.length - 1] == "\\" ? c = c.slice(0, -1) + l : r = 3 : c += l;
            break;
        case 3:
            f(),
            r = 0,
            l !== "*" && l !== "?" && l !== "+" && i--,
            c = "";
            break;
        default:
            t("Unknown state");
            break
        }
    }
    return r === 2 && t(`Unfinished custom RegExp for param "${u}"`),
    f(),
    s(),
    o
}
function createRouteRecordMatcher(e, t, r) {
    const n = tokensToParser(tokenizePath(e.path), r)
      , o = assign$1(n, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o),
    o
}
function createRouterMatcher(e, t) {
    const r = []
      , n = new Map;
    t = mergeOptions({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function o(f) {
        return n.get(f)
    }
    function a(f, d, p) {
        const m = !p
          , g = normalizeRouteRecord(f);
        g.aliasOf = p && p.record;
        const _ = mergeOptions(t, f)
          , b = [g];
        if ("alias"in f) {
            const S = typeof f.alias == "string" ? [f.alias] : f.alias;
            for (const C of S)
                b.push(normalizeRouteRecord(assign$1({}, g, {
                    components: p ? p.record.components : g.components,
                    path: C,
                    aliasOf: p ? p.record : g
                })))
        }
        let y, v;
        for (const S of b) {
            const {path: C} = S;
            if (d && C[0] !== "/") {
                const x = d.record.path
                  , E = x[x.length - 1] === "/" ? "" : "/";
                S.path = d.record.path + (C && E + C)
            }
            if (y = createRouteRecordMatcher(S, d, _),
            p ? p.alias.push(y) : (v = v || y,
            v !== y && v.alias.push(y),
            m && f.name && !isAliasRecord(y) && s(f.name)),
            isMatchable(y) && l(y),
            g.children) {
                const x = g.children;
                for (let E = 0; E < x.length; E++)
                    a(x[E], y, p && p.children[E])
            }
            p = p || y
        }
        return v ? () => {
            s(v)
        }
        : noop$2
    }
    function s(f) {
        if (isRouteName(f)) {
            const d = n.get(f);
            d && (n.delete(f),
            r.splice(r.indexOf(d), 1),
            d.children.forEach(s),
            d.alias.forEach(s))
        } else {
            const d = r.indexOf(f);
            d > -1 && (r.splice(d, 1),
            f.record.name && n.delete(f.record.name),
            f.children.forEach(s),
            f.alias.forEach(s))
        }
    }
    function i() {
        return r
    }
    function l(f) {
        const d = findInsertionIndex(f, r);
        r.splice(d, 0, f),
        f.record.name && !isAliasRecord(f) && n.set(f.record.name, f)
    }
    function u(f, d) {
        let p, m = {}, g, _;
        if ("name"in f && f.name) {
            if (p = n.get(f.name),
            !p)
                throw createRouterError(1, {
                    location: f
                });
            _ = p.record.name,
            m = assign$1(paramsFromLocation(d.params, p.keys.filter(v => !v.optional).concat(p.parent ? p.parent.keys.filter(v => v.optional) : []).map(v => v.name)), f.params && paramsFromLocation(f.params, p.keys.map(v => v.name))),
            g = p.stringify(m)
        } else if (f.path != null)
            g = f.path,
            p = r.find(v => v.re.test(g)),
            p && (m = p.parse(g),
            _ = p.record.name);
        else {
            if (p = d.name ? n.get(d.name) : r.find(v => v.re.test(d.path)),
            !p)
                throw createRouterError(1, {
                    location: f,
                    currentLocation: d
                });
            _ = p.record.name,
            m = assign$1({}, d.params, f.params),
            g = p.stringify(m)
        }
        const b = [];
        let y = p;
        for (; y; )
            b.unshift(y.record),
            y = y.parent;
        return {
            name: _,
            path: g,
            params: m,
            matched: b,
            meta: mergeMetaFields(b)
        }
    }
    e.forEach(f => a(f));
    function c() {
        r.length = 0,
        n.clear()
    }
    return {
        addRoute: a,
        resolve: u,
        removeRoute: s,
        clearRoutes: c,
        getRoutes: i,
        getRecordMatcher: o
    }
}
function paramsFromLocation(e, t) {
    const r = {};
    for (const n of t)
        n in e && (r[n] = e[n]);
    return r
}
function normalizeRouteRecord(e) {
    const t = {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: e.aliasOf,
        beforeEnter: e.beforeEnter,
        props: normalizeRecordProps(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    };
    return Object.defineProperty(t, "mods", {
        value: {}
    }),
    t
}
function normalizeRecordProps(e) {
    const t = {}
      , r = e.props || !1;
    if ("component"in e)
        t.default = r;
    else
        for (const n in e.components)
            t[n] = typeof r == "object" ? r[n] : r;
    return t
}
function isAliasRecord(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function mergeMetaFields(e) {
    return e.reduce( (t, r) => assign$1(t, r.meta), {})
}
function mergeOptions(e, t) {
    const r = {};
    for (const n in e)
        r[n] = n in t ? t[n] : e[n];
    return r
}
function findInsertionIndex(e, t) {
    let r = 0
      , n = t.length;
    for (; r !== n; ) {
        const a = r + n >> 1;
        comparePathParserScore(e, t[a]) < 0 ? n = a : r = a + 1
    }
    const o = getInsertionAncestor(e);
    return o && (n = t.lastIndexOf(o, n - 1)),
    n
}
function getInsertionAncestor(e) {
    let t = e;
    for (; t = t.parent; )
        if (isMatchable(t) && comparePathParserScore(e, t) === 0)
            return t
}
function isMatchable({record: e}) {
    return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}
function parseQuery(e) {
    const t = {};
    if (e === "" || e === "?")
        return t;
    const n = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let o = 0; o < n.length; ++o) {
        const a = n[o].replace(PLUS_RE, " ")
          , s = a.indexOf("=")
          , i = decode$1(s < 0 ? a : a.slice(0, s))
          , l = s < 0 ? null : decode$1(a.slice(s + 1));
        if (i in t) {
            let u = t[i];
            isArray$6(u) || (u = t[i] = [u]),
            u.push(l)
        } else
            t[i] = l
    }
    return t
}
function stringifyQuery(e) {
    let t = "";
    for (let r in e) {
        const n = e[r];
        if (r = encodeQueryKey(r),
        n == null) {
            n !== void 0 && (t += (t.length ? "&" : "") + r);
            continue
        }
        (isArray$6(n) ? n.map(a => a && encodeQueryValue(a)) : [n && encodeQueryValue(n)]).forEach(a => {
            a !== void 0 && (t += (t.length ? "&" : "") + r,
            a != null && (t += "=" + a))
        }
        )
    }
    return t
}
function normalizeQuery(e) {
    const t = {};
    for (const r in e) {
        const n = e[r];
        n !== void 0 && (t[r] = isArray$6(n) ? n.map(o => o == null ? null : "" + o) : n == null ? n : "" + n)
    }
    return t
}
const matchedRouteKey = Symbol("")
  , viewDepthKey = Symbol("")
  , routerKey = Symbol("")
  , routeLocationKey = Symbol("")
  , routerViewLocationKey = Symbol("");
function useCallbacks() {
    let e = [];
    function t(n) {
        return e.push(n),
        () => {
            const o = e.indexOf(n);
            o > -1 && e.splice(o, 1)
        }
    }
    function r() {
        e = []
    }
    return {
        add: t,
        list: () => e.slice(),
        reset: r
    }
}
function guardToPromiseFn(e, t, r, n, o, a=s => s()) {
    const s = n && (n.enterCallbacks[o] = n.enterCallbacks[o] || []);
    return () => new Promise( (i, l) => {
        const u = d => {
            d === !1 ? l(createRouterError(4, {
                from: r,
                to: t
            })) : d instanceof Error ? l(d) : isRouteLocation(d) ? l(createRouterError(2, {
                from: t,
                to: d
            })) : (s && n.enterCallbacks[o] === s && typeof d == "function" && s.push(d),
            i())
        }
          , c = a( () => e.call(n && n.instances[o], t, r, u));
        let f = Promise.resolve(c);
        e.length < 3 && (f = f.then(u)),
        f.catch(d => l(d))
    }
    )
}
function extractComponentsGuards(e, t, r, n, o=a => a()) {
    const a = [];
    for (const s of e)
        for (const i in s.components) {
            let l = s.components[i];
            if (!(t !== "beforeRouteEnter" && !s.instances[i]))
                if (isRouteComponent(l)) {
                    const c = (l.__vccOpts || l)[t];
                    c && a.push(guardToPromiseFn(c, r, n, s, i, o))
                } else {
                    let u = l();
                    a.push( () => u.then(c => {
                        if (!c)
                            throw new Error(`Couldn't resolve component "${i}" at "${s.path}"`);
                        const f = isESModule(c) ? c.default : c;
                        s.mods[i] = c,
                        s.components[i] = f;
                        const p = (f.__vccOpts || f)[t];
                        return p && guardToPromiseFn(p, r, n, s, i, o)()
                    }
                    ))
                }
        }
    return a
}
function useLink(e) {
    const t = inject(routerKey)
      , r = inject(routeLocationKey)
      , n = computed( () => {
        const l = unref(e.to);
        return t.resolve(l)
    }
    )
      , o = computed( () => {
        const {matched: l} = n.value
          , {length: u} = l
          , c = l[u - 1]
          , f = r.matched;
        if (!c || !f.length)
            return -1;
        const d = f.findIndex(isSameRouteRecord.bind(null, c));
        if (d > -1)
            return d;
        const p = getOriginalPath(l[u - 2]);
        return u > 1 && getOriginalPath(c) === p && f[f.length - 1].path !== p ? f.findIndex(isSameRouteRecord.bind(null, l[u - 2])) : d
    }
    )
      , a = computed( () => o.value > -1 && includesParams(r.params, n.value.params))
      , s = computed( () => o.value > -1 && o.value === r.matched.length - 1 && isSameRouteLocationParams(r.params, n.value.params));
    function i(l={}) {
        return guardEvent(l) ? t[unref(e.replace) ? "replace" : "push"](unref(e.to)).catch(noop$2) : Promise.resolve()
    }
    return {
        route: n,
        href: computed( () => n.value.href),
        isActive: a,
        isExactActive: s,
        navigate: i
    }
}
const RouterLinkImpl = defineComponent({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink,
    setup(e, {slots: t}) {
        const r = reactive(useLink(e))
          , {options: n} = inject(routerKey)
          , o = computed( () => ({
            [getLinkClass(e.activeClass, n.linkActiveClass, "router-link-active")]: r.isActive,
            [getLinkClass(e.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: r.isExactActive
        }));
        return () => {
            const a = t.default && t.default(r);
            return e.custom ? a : h("a", {
                "aria-current": r.isExactActive ? e.ariaCurrentValue : null,
                href: r.href,
                onClick: r.navigate,
                class: o.value
            }, a)
        }
    }
})
  , RouterLink = RouterLinkImpl;
function guardEvent(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
        !0
    }
}
function includesParams(e, t) {
    for (const r in t) {
        const n = t[r]
          , o = e[r];
        if (typeof n == "string") {
            if (n !== o)
                return !1
        } else if (!isArray$6(o) || o.length !== n.length || n.some( (a, s) => a !== o[s]))
            return !1
    }
    return !0
}
function getOriginalPath(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const getLinkClass = (e, t, r) => e ?? t ?? r
  , RouterViewImpl = defineComponent({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: r}) {
        const n = inject(routerViewLocationKey)
          , o = computed( () => e.route || n.value)
          , a = inject(viewDepthKey, 0)
          , s = computed( () => {
            let u = unref(a);
            const {matched: c} = o.value;
            let f;
            for (; (f = c[u]) && !f.components; )
                u++;
            return u
        }
        )
          , i = computed( () => o.value.matched[s.value]);
        provide(viewDepthKey, computed( () => s.value + 1)),
        provide(matchedRouteKey, i),
        provide(routerViewLocationKey, o);
        const l = ref();
        return watch( () => [l.value, i.value, e.name], ([u,c,f], [d,p,m]) => {
            c && (c.instances[f] = u,
            p && p !== c && u && u === d && (c.leaveGuards.size || (c.leaveGuards = p.leaveGuards),
            c.updateGuards.size || (c.updateGuards = p.updateGuards))),
            u && c && (!p || !isSameRouteRecord(c, p) || !d) && (c.enterCallbacks[f] || []).forEach(g => g(u))
        }
        , {
            flush: "post"
        }),
        () => {
            const u = o.value
              , c = e.name
              , f = i.value
              , d = f && f.components[c];
            if (!d)
                return normalizeSlot(r.default, {
                    Component: d,
                    route: u
                });
            const p = f.props[c]
              , m = p ? p === !0 ? u.params : typeof p == "function" ? p(u) : p : null
              , _ = h(d, assign$1({}, m, t, {
                onVnodeUnmounted: b => {
                    b.component.isUnmounted && (f.instances[c] = null)
                }
                ,
                ref: l
            }));
            return normalizeSlot(r.default, {
                Component: _,
                route: u
            }) || _
        }
    }
});
function normalizeSlot(e, t) {
    if (!e)
        return null;
    const r = e(t);
    return r.length === 1 ? r[0] : r
}
const RouterView = RouterViewImpl;
function createRouter(e) {
    const t = createRouterMatcher(e.routes, e)
      , r = e.parseQuery || parseQuery
      , n = e.stringifyQuery || stringifyQuery
      , o = e.history
      , a = useCallbacks()
      , s = useCallbacks()
      , i = useCallbacks()
      , l = shallowRef(START_LOCATION_NORMALIZED);
    let u = START_LOCATION_NORMALIZED;
    isBrowser && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const c = applyToParams.bind(null, O => "" + O)
      , f = applyToParams.bind(null, encodeParam)
      , d = applyToParams.bind(null, decode$1);
    function p(O, j) {
        let U, z;
        return isRouteName(O) ? (U = t.getRecordMatcher(O),
        z = j) : z = O,
        t.addRoute(z, U)
    }
    function m(O) {
        const j = t.getRecordMatcher(O);
        j && t.removeRoute(j)
    }
    function g() {
        return t.getRoutes().map(O => O.record)
    }
    function _(O) {
        return !!t.getRecordMatcher(O)
    }
    function b(O, j) {
        if (j = assign$1({}, j || l.value),
        typeof O == "string") {
            const K = parseURL(r, O, j.path)
              , Q = t.resolve({
                path: K.path
            }, j)
              , re = o.createHref(K.fullPath);
            return assign$1(K, Q, {
                params: d(Q.params),
                hash: decode$1(K.hash),
                redirectedFrom: void 0,
                href: re
            })
        }
        let U;
        if (O.path != null)
            U = assign$1({}, O, {
                path: parseURL(r, O.path, j.path).path
            });
        else {
            const K = assign$1({}, O.params);
            for (const Q in K)
                K[Q] == null && delete K[Q];
            U = assign$1({}, O, {
                params: f(K)
            }),
            j.params = f(j.params)
        }
        const z = t.resolve(U, j)
          , q = O.hash || "";
        z.params = c(d(z.params));
        const Y = stringifyURL(n, assign$1({}, O, {
            hash: encodeHash(q),
            path: z.path
        }))
          , W = o.createHref(Y);
        return assign$1({
            fullPath: Y,
            hash: q,
            query: n === stringifyQuery ? normalizeQuery(O.query) : O.query || {}
        }, z, {
            redirectedFrom: void 0,
            href: W
        })
    }
    function y(O) {
        return typeof O == "string" ? parseURL(r, O, l.value.path) : assign$1({}, O)
    }
    function v(O, j) {
        if (u !== O)
            return createRouterError(8, {
                from: j,
                to: O
            })
    }
    function S(O) {
        return E(O)
    }
    function C(O) {
        return S(assign$1(y(O), {
            replace: !0
        }))
    }
    function x(O) {
        const j = O.matched[O.matched.length - 1];
        if (j && j.redirect) {
            const {redirect: U} = j;
            let z = typeof U == "function" ? U(O) : U;
            return typeof z == "string" && (z = z.includes("?") || z.includes("#") ? z = y(z) : {
                path: z
            },
            z.params = {}),
            assign$1({
                query: O.query,
                hash: O.hash,
                params: z.path != null ? {} : O.params
            }, z)
        }
    }
    function E(O, j) {
        const U = u = b(O)
          , z = l.value
          , q = O.state
          , Y = O.force
          , W = O.replace === !0
          , K = x(U);
        if (K)
            return E(assign$1(y(K), {
                state: typeof K == "object" ? assign$1({}, q, K.state) : q,
                force: Y,
                replace: W
            }), j || U);
        const Q = U;
        Q.redirectedFrom = j;
        let re;
        return !Y && isSameRouteLocation(n, z, U) && (re = createRouterError(16, {
            to: Q,
            from: z
        }),
        R(z, z, !0, !1)),
        (re ? Promise.resolve(re) : w(Q, z)).catch(te => isNavigationFailure(te) ? isNavigationFailure(te, 2) ? te : X(te) : H(te, Q, z)).then(te => {
            if (te) {
                if (isNavigationFailure(te, 2))
                    return E(assign$1({
                        replace: W
                    }, y(te.to), {
                        state: typeof te.to == "object" ? assign$1({}, q, te.to.state) : q,
                        force: Y
                    }), j || Q)
            } else
                te = k(Q, z, !0, W, q);
            return T(Q, z, te),
            te
        }
        )
    }
    function I(O, j) {
        const U = v(O, j);
        return U ? Promise.reject(U) : Promise.resolve()
    }
    function M(O) {
        const j = D.values().next().value;
        return j && typeof j.runWithContext == "function" ? j.runWithContext(O) : O()
    }
    function w(O, j) {
        let U;
        const [z,q,Y] = extractChangingRecords(O, j);
        U = extractComponentsGuards(z.reverse(), "beforeRouteLeave", O, j);
        for (const K of z)
            K.leaveGuards.forEach(Q => {
                U.push(guardToPromiseFn(Q, O, j))
            }
            );
        const W = I.bind(null, O, j);
        return U.push(W),
        Z(U).then( () => {
            U = [];
            for (const K of a.list())
                U.push(guardToPromiseFn(K, O, j));
            return U.push(W),
            Z(U)
        }
        ).then( () => {
            U = extractComponentsGuards(q, "beforeRouteUpdate", O, j);
            for (const K of q)
                K.updateGuards.forEach(Q => {
                    U.push(guardToPromiseFn(Q, O, j))
                }
                );
            return U.push(W),
            Z(U)
        }
        ).then( () => {
            U = [];
            for (const K of Y)
                if (K.beforeEnter)
                    if (isArray$6(K.beforeEnter))
                        for (const Q of K.beforeEnter)
                            U.push(guardToPromiseFn(Q, O, j));
                    else
                        U.push(guardToPromiseFn(K.beforeEnter, O, j));
            return U.push(W),
            Z(U)
        }
        ).then( () => (O.matched.forEach(K => K.enterCallbacks = {}),
        U = extractComponentsGuards(Y, "beforeRouteEnter", O, j, M),
        U.push(W),
        Z(U))).then( () => {
            U = [];
            for (const K of s.list())
                U.push(guardToPromiseFn(K, O, j));
            return U.push(W),
            Z(U)
        }
        ).catch(K => isNavigationFailure(K, 8) ? K : Promise.reject(K))
    }
    function T(O, j, U) {
        i.list().forEach(z => M( () => z(O, j, U)))
    }
    function k(O, j, U, z, q) {
        const Y = v(O, j);
        if (Y)
            return Y;
        const W = j === START_LOCATION_NORMALIZED
          , K = isBrowser ? history.state : {};
        U && (z || W ? o.replace(O.fullPath, assign$1({
            scroll: W && K && K.scroll
        }, q)) : o.push(O.fullPath, q)),
        l.value = O,
        R(O, j, U, W),
        X()
    }
    let A;
    function B() {
        A || (A = o.listen( (O, j, U) => {
            if (!ee.listening)
                return;
            const z = b(O)
              , q = x(z);
            if (q) {
                E(assign$1(q, {
                    replace: !0
                }), z).catch(noop$2);
                return
            }
            u = z;
            const Y = l.value;
            isBrowser && saveScrollPosition(getScrollKey(Y.fullPath, U.delta), computeScrollPosition()),
            w(z, Y).catch(W => isNavigationFailure(W, 12) ? W : isNavigationFailure(W, 2) ? (E(W.to, z).then(K => {
                isNavigationFailure(K, 20) && !U.delta && U.type === NavigationType.pop && o.go(-1, !1)
            }
            ).catch(noop$2),
            Promise.reject()) : (U.delta && o.go(-U.delta, !1),
            H(W, z, Y))).then(W => {
                W = W || k(z, Y, !1),
                W && (U.delta && !isNavigationFailure(W, 8) ? o.go(-U.delta, !1) : U.type === NavigationType.pop && isNavigationFailure(W, 20) && o.go(-1, !1)),
                T(z, Y, W)
            }
            ).catch(noop$2)
        }
        ))
    }
    let $ = useCallbacks(), P = useCallbacks(), N;
    function H(O, j, U) {
        X(O);
        const z = P.list();
        return z.length ? z.forEach(q => q(O, j, U)) : console.error(O),
        Promise.reject(O)
    }
    function G() {
        return N && l.value !== START_LOCATION_NORMALIZED ? Promise.resolve() : new Promise( (O, j) => {
            $.add([O, j])
        }
        )
    }
    function X(O) {
        return N || (N = !O,
        B(),
        $.list().forEach( ([j,U]) => O ? U(O) : j()),
        $.reset()),
        O
    }
    function R(O, j, U, z) {
        const {scrollBehavior: q} = e;
        if (!isBrowser || !q)
            return Promise.resolve();
        const Y = !U && getSavedScrollPosition(getScrollKey(O.fullPath, 0)) || (z || !U) && history.state && history.state.scroll || null;
        return nextTick().then( () => q(O, j, Y)).then(W => W && scrollToPosition(W)).catch(W => H(W, O, j))
    }
    const F = O => o.go(O);
    let L;
    const D = new Set
      , ee = {
        currentRoute: l,
        listening: !0,
        addRoute: p,
        removeRoute: m,
        clearRoutes: t.clearRoutes,
        hasRoute: _,
        getRoutes: g,
        resolve: b,
        options: e,
        push: S,
        replace: C,
        go: F,
        back: () => F(-1),
        forward: () => F(1),
        beforeEach: a.add,
        beforeResolve: s.add,
        afterEach: i.add,
        onError: P.add,
        isReady: G,
        install(O) {
            const j = this;
            O.component("RouterLink", RouterLink),
            O.component("RouterView", RouterView),
            O.config.globalProperties.$router = j,
            Object.defineProperty(O.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => unref(l)
            }),
            isBrowser && !L && l.value === START_LOCATION_NORMALIZED && (L = !0,
            S(o.location).catch(q => {}
            ));
            const U = {};
            for (const q in START_LOCATION_NORMALIZED)
                Object.defineProperty(U, q, {
                    get: () => l.value[q],
                    enumerable: !0
                });
            O.provide(routerKey, j),
            O.provide(routeLocationKey, shallowReactive(U)),
            O.provide(routerViewLocationKey, l);
            const z = O.unmount;
            D.add(O),
            O.unmount = function() {
                D.delete(O),
                D.size < 1 && (u = START_LOCATION_NORMALIZED,
                A && A(),
                A = null,
                l.value = START_LOCATION_NORMALIZED,
                L = !1,
                N = !1),
                z()
            }
        }
    };
    function Z(O) {
        return O.reduce( (j, U) => j.then( () => M(U)), Promise.resolve())
    }
    return ee
}
function extractChangingRecords(e, t) {
    const r = []
      , n = []
      , o = []
      , a = Math.max(t.matched.length, e.matched.length);
    for (let s = 0; s < a; s++) {
        const i = t.matched[s];
        i && (e.matched.find(u => isSameRouteRecord(u, i)) ? n.push(i) : r.push(i));
        const l = e.matched[s];
        l && (t.matched.find(u => isSameRouteRecord(u, l)) || o.push(l))
    }
    return [r, n, o]
}
function useRoute(e) {
    return inject(routeLocationKey)
}
const interpolatePath = (e, t) => t.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, r => {
    var n;
    return ((n = e.params[r.slice(1)]) == null ? void 0 : n.toString()) || ""
}
)
  , generateRouteKey$1 = (e, t) => {
    const r = e.route.matched.find(o => {
        var a;
        return ((a = o.components) == null ? void 0 : a.default) === e.Component.type
    }
    )
      , n = t ?? (r == null ? void 0 : r.meta.key) ?? (r && interpolatePath(e.route, r));
    return typeof n == "function" ? n(e.route) : n
}
  , wrapInKeepAlive = (e, t) => ({
    default: () => e ? h(KeepAlive, e === !0 ? {} : e, t) : t
});
function toArray(e) {
    return Array.isArray(e) ? e : [e]
}
const scriptRel = "modulepreload"
  , assetsURL = function(e, t) {
    return new URL(e,t).href
}
  , seen = {}
  , __vitePreload = function(t, r, n) {
    let o = Promise.resolve();
    if (r && r.length > 0) {
        const s = document.getElementsByTagName("link")
          , i = document.querySelector("meta[property=csp-nonce]")
          , l = (i == null ? void 0 : i.nonce) || (i == null ? void 0 : i.getAttribute("nonce"));
        o = Promise.allSettled(r.map(u => {
            if (u = assetsURL(u, n),
            u in seen)
                return;
            seen[u] = !0;
            const c = u.endsWith(".css")
              , f = c ? '[rel="stylesheet"]' : "";
            if (!!n)
                for (let m = s.length - 1; m >= 0; m--) {
                    const g = s[m];
                    if (g.href === u && (!c || g.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${u}"]${f}`))
                return;
            const p = document.createElement("link");
            if (p.rel = c ? "stylesheet" : scriptRel,
            c || (p.as = "script"),
            p.crossOrigin = "",
            p.href = u,
            l && p.setAttribute("nonce", l),
            document.head.appendChild(p),
            c)
                return new Promise( (m, g) => {
                    p.addEventListener("load", m),
                    p.addEventListener("error", () => g(new Error(`Unable to preload CSS for ${u}`)))
                }
                )
        }
        ))
    }
    function a(s) {
        const i = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (i.payload = s,
        window.dispatchEvent(i),
        !i.defaultPrevented)
            throw s
    }
    return o.then(s => {
        for (const i of s || [])
            i.status === "rejected" && a(i.reason);
        return t().catch(a)
    }
    )
};
var freeGlobal = typeof global == "object" && global && global.Object === Object && global
  , freeSelf = typeof self == "object" && self && self.Object === Object && self
  , root = freeGlobal || freeSelf || Function("return this")()
  , Symbol$1 = root.Symbol
  , objectProto$c = Object.prototype
  , hasOwnProperty$a = objectProto$c.hasOwnProperty
  , nativeObjectToString$1 = objectProto$c.toString
  , symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(e) {
    var t = hasOwnProperty$a.call(e, symToStringTag$1)
      , r = e[symToStringTag$1];
    try {
        e[symToStringTag$1] = void 0;
        var n = !0
    } catch {}
    var o = nativeObjectToString$1.call(e);
    return n && (t ? e[symToStringTag$1] = r : delete e[symToStringTag$1]),
    o
}
var objectProto$b = Object.prototype
  , nativeObjectToString = objectProto$b.toString;
function objectToString$2(e) {
    return nativeObjectToString.call(e)
}
var nullTag = "[object Null]"
  , undefinedTag = "[object Undefined]"
  , symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(e) {
    return e == null ? e === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(e) ? getRawTag(e) : objectToString$2(e)
}
function isObjectLike(e) {
    return e != null && typeof e == "object"
}
var symbolTag$2 = "[object Symbol]";
function isSymbol$1(e) {
    return typeof e == "symbol" || isObjectLike(e) && baseGetTag(e) == symbolTag$2
}
function arrayMap(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, o = Array(n); ++r < n; )
        o[r] = t(e[r], r, e);
    return o
}
var isArray$5 = Array.isArray
  , INFINITY$1 = 1 / 0
  , symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0
  , symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(e) {
    if (typeof e == "string")
        return e;
    if (isArray$5(e))
        return arrayMap(e, baseToString) + "";
    if (isSymbol$1(e))
        return symbolToString ? symbolToString.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -INFINITY$1 ? "-0" : t
}
function isObject$2(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
function identity$1(e) {
    return e
}
var asyncTag = "[object AsyncFunction]"
  , funcTag$2 = "[object Function]"
  , genTag$1 = "[object GeneratorFunction]"
  , proxyTag = "[object Proxy]";
function isFunction$1(e) {
    if (!isObject$2(e))
        return !1;
    var t = baseGetTag(e);
    return t == funcTag$2 || t == genTag$1 || t == asyncTag || t == proxyTag
}
var coreJsData = root["__core-js_shared__"]
  , maskSrcKey = function() {
    var e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : ""
}();
function isMasked(e) {
    return !!maskSrcKey && maskSrcKey in e
}
var funcProto$1 = Function.prototype
  , funcToString$1 = funcProto$1.toString;
function toSource(e) {
    if (e != null) {
        try {
            return funcToString$1.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g
  , reIsHostCtor = /^\[object .+?Constructor\]$/
  , funcProto = Function.prototype
  , objectProto$a = Object.prototype
  , funcToString = funcProto.toString
  , hasOwnProperty$9 = objectProto$a.hasOwnProperty
  , reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(e) {
    if (!isObject$2(e) || isMasked(e))
        return !1;
    var t = isFunction$1(e) ? reIsNative : reIsHostCtor;
    return t.test(toSource(e))
}
function getValue(e, t) {
    return e == null ? void 0 : e[t]
}
function getNative(e, t) {
    var r = getValue(e, t);
    return baseIsNative(r) ? r : void 0
}
var WeakMap$1 = getNative(root, "WeakMap")
  , objectCreate = Object.create
  , baseCreate = function() {
    function e() {}
    return function(t) {
        if (!isObject$2(t))
            return {};
        if (objectCreate)
            return objectCreate(t);
        e.prototype = t;
        var r = new e;
        return e.prototype = void 0,
        r
    }
}();
function apply(e, t, r) {
    switch (r.length) {
    case 0:
        return e.call(t);
    case 1:
        return e.call(t, r[0]);
    case 2:
        return e.call(t, r[0], r[1]);
    case 3:
        return e.call(t, r[0], r[1], r[2])
    }
    return e.apply(t, r)
}
function copyArray(e, t) {
    var r = -1
      , n = e.length;
    for (t || (t = Array(n)); ++r < n; )
        t[r] = e[r];
    return t
}
var HOT_COUNT = 800
  , HOT_SPAN = 16
  , nativeNow = Date.now;
function shortOut(e) {
    var t = 0
      , r = 0;
    return function() {
        var n = nativeNow()
          , o = HOT_SPAN - (n - r);
        if (r = n,
        o > 0) {
            if (++t >= HOT_COUNT)
                return arguments[0]
        } else
            t = 0;
        return e.apply(void 0, arguments)
    }
}
function constant(e) {
    return function() {
        return e
    }
}
var defineProperty = function() {
    try {
        var e = getNative(Object, "defineProperty");
        return e({}, "", {}),
        e
    } catch {}
}()
  , baseSetToString = defineProperty ? function(e, t) {
    return defineProperty(e, "toString", {
        configurable: !0,
        enumerable: !1,
        value: constant(t),
        writable: !0
    })
}
: identity$1
  , setToString = shortOut(baseSetToString);
function arrayEach(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n && t(e[r], r, e) !== !1; )
        ;
    return e
}
var MAX_SAFE_INTEGER$1 = 9007199254740991
  , reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(e, t) {
    var r = typeof e;
    return t = t ?? MAX_SAFE_INTEGER$1,
    !!t && (r == "number" || r != "symbol" && reIsUint.test(e)) && e > -1 && e % 1 == 0 && e < t
}
function baseAssignValue(e, t, r) {
    t == "__proto__" && defineProperty ? defineProperty(e, t, {
        configurable: !0,
        enumerable: !0,
        value: r,
        writable: !0
    }) : e[t] = r
}
function eq(e, t) {
    return e === t || e !== e && t !== t
}
var objectProto$9 = Object.prototype
  , hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function assignValue(e, t, r) {
    var n = e[t];
    (!(hasOwnProperty$8.call(e, t) && eq(n, r)) || r === void 0 && !(t in e)) && baseAssignValue(e, t, r)
}
function copyObject(e, t, r, n) {
    var o = !r;
    r || (r = {});
    for (var a = -1, s = t.length; ++a < s; ) {
        var i = t[a]
          , l = void 0;
        l === void 0 && (l = e[i]),
        o ? baseAssignValue(r, i, l) : assignValue(r, i, l)
    }
    return r
}
var nativeMax = Math.max;
function overRest(e, t, r) {
    return t = nativeMax(t === void 0 ? e.length - 1 : t, 0),
    function() {
        for (var n = arguments, o = -1, a = nativeMax(n.length - t, 0), s = Array(a); ++o < a; )
            s[o] = n[t + o];
        o = -1;
        for (var i = Array(t + 1); ++o < t; )
            i[o] = n[o];
        return i[t] = r(s),
        apply(e, this, i)
    }
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= MAX_SAFE_INTEGER
}
function isArrayLike(e) {
    return e != null && isLength(e.length) && !isFunction$1(e)
}
var objectProto$8 = Object.prototype;
function isPrototype(e) {
    var t = e && e.constructor
      , r = typeof t == "function" && t.prototype || objectProto$8;
    return e === r
}
function baseTimes(e, t) {
    for (var r = -1, n = Array(e); ++r < e; )
        n[r] = t(r);
    return n
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(e) {
    return isObjectLike(e) && baseGetTag(e) == argsTag$2
}
var objectProto$7 = Object.prototype
  , hasOwnProperty$7 = objectProto$7.hasOwnProperty
  , propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable
  , isArguments = baseIsArguments(function() {
    return arguments
}()) ? baseIsArguments : function(e) {
    return isObjectLike(e) && hasOwnProperty$7.call(e, "callee") && !propertyIsEnumerable$1.call(e, "callee")
}
;
function stubFalse() {
    return !1
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports
  , freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module
  , moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2
  , Buffer$2 = moduleExports$2 ? root.Buffer : void 0
  , nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0
  , isBuffer$1 = nativeIsBuffer || stubFalse
  , argsTag$1 = "[object Arguments]"
  , arrayTag$1 = "[object Array]"
  , boolTag$2 = "[object Boolean]"
  , dateTag$2 = "[object Date]"
  , errorTag$1 = "[object Error]"
  , funcTag$1 = "[object Function]"
  , mapTag$4 = "[object Map]"
  , numberTag$3 = "[object Number]"
  , objectTag$2 = "[object Object]"
  , regexpTag$2 = "[object RegExp]"
  , setTag$4 = "[object Set]"
  , stringTag$2 = "[object String]"
  , weakMapTag$2 = "[object WeakMap]"
  , arrayBufferTag$2 = "[object ArrayBuffer]"
  , dataViewTag$3 = "[object DataView]"
  , float32Tag$2 = "[object Float32Array]"
  , float64Tag$2 = "[object Float64Array]"
  , int8Tag$2 = "[object Int8Array]"
  , int16Tag$2 = "[object Int16Array]"
  , int32Tag$2 = "[object Int32Array]"
  , uint8Tag$2 = "[object Uint8Array]"
  , uint8ClampedTag$2 = "[object Uint8ClampedArray]"
  , uint16Tag$2 = "[object Uint16Array]"
  , uint32Tag$2 = "[object Uint32Array]"
  , typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(e) {
    return isObjectLike(e) && isLength(e.length) && !!typedArrayTags[baseGetTag(e)]
}
function baseUnary(e) {
    return function(t) {
        return e(t)
    }
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports
  , freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module
  , moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1
  , freeProcess = moduleExports$1 && freeGlobal.process
  , nodeUtil = function() {
    try {
        var e = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        return e || freeProcess && freeProcess.binding && freeProcess.binding("util")
    } catch {}
}()
  , nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
  , isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray
  , objectProto$6 = Object.prototype
  , hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(e, t) {
    var r = isArray$5(e)
      , n = !r && isArguments(e)
      , o = !r && !n && isBuffer$1(e)
      , a = !r && !n && !o && isTypedArray(e)
      , s = r || n || o || a
      , i = s ? baseTimes(e.length, String) : []
      , l = i.length;
    for (var u in e)
        (t || hasOwnProperty$6.call(e, u)) && !(s && (u == "length" || o && (u == "offset" || u == "parent") || a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || isIndex(u, l))) && i.push(u);
    return i
}
function overArg(e, t) {
    return function(r) {
        return e(t(r))
    }
}
var nativeKeys = overArg(Object.keys, Object)
  , objectProto$5 = Object.prototype
  , hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeys(e) {
    if (!isPrototype(e))
        return nativeKeys(e);
    var t = [];
    for (var r in Object(e))
        hasOwnProperty$5.call(e, r) && r != "constructor" && t.push(r);
    return t
}
function keys(e) {
    return isArrayLike(e) ? arrayLikeKeys(e) : baseKeys(e)
}
function nativeKeysIn(e) {
    var t = [];
    if (e != null)
        for (var r in Object(e))
            t.push(r);
    return t
}
var objectProto$4 = Object.prototype
  , hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseKeysIn(e) {
    if (!isObject$2(e))
        return nativeKeysIn(e);
    var t = isPrototype(e)
      , r = [];
    for (var n in e)
        n == "constructor" && (t || !hasOwnProperty$4.call(e, n)) || r.push(n);
    return r
}
function keysIn(e) {
    return isArrayLike(e) ? arrayLikeKeys(e, !0) : baseKeysIn(e)
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , reIsPlainProp = /^\w*$/;
function isKey(e, t) {
    if (isArray$5(e))
        return !1;
    var r = typeof e;
    return r == "number" || r == "symbol" || r == "boolean" || e == null || isSymbol$1(e) ? !0 : reIsPlainProp.test(e) || !reIsDeepProp.test(e) || t != null && e in Object(t)
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {},
    this.size = 0
}
function hashDelete(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
    t
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__"
  , objectProto$3 = Object.prototype
  , hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function hashGet(e) {
    var t = this.__data__;
    if (nativeCreate) {
        var r = t[e];
        return r === HASH_UNDEFINED$1 ? void 0 : r
    }
    return hasOwnProperty$3.call(t, e) ? t[e] : void 0
}
var objectProto$2 = Object.prototype
  , hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function hashHas(e) {
    var t = this.__data__;
    return nativeCreate ? t[e] !== void 0 : hasOwnProperty$2.call(t, e)
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
    r[e] = nativeCreate && t === void 0 ? HASH_UNDEFINED : t,
    this
}
function Hash(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var n = e[t];
        this.set(n[0], n[1])
    }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
    this.__data__ = [],
    this.size = 0
}
function assocIndexOf(e, t) {
    for (var r = e.length; r--; )
        if (eq(e[r][0], t))
            return r;
    return -1
}
var arrayProto = Array.prototype
  , splice = arrayProto.splice;
function listCacheDelete(e) {
    var t = this.__data__
      , r = assocIndexOf(t, e);
    if (r < 0)
        return !1;
    var n = t.length - 1;
    return r == n ? t.pop() : splice.call(t, r, 1),
    --this.size,
    !0
}
function listCacheGet(e) {
    var t = this.__data__
      , r = assocIndexOf(t, e);
    return r < 0 ? void 0 : t[r][1]
}
function listCacheHas(e) {
    return assocIndexOf(this.__data__, e) > -1
}
function listCacheSet(e, t) {
    var r = this.__data__
      , n = assocIndexOf(r, e);
    return n < 0 ? (++this.size,
    r.push([e, t])) : r[n][1] = t,
    this
}
function ListCache(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var n = e[t];
        this.set(n[0], n[1])
    }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
    this.size = 0,
    this.__data__ = {
        hash: new Hash,
        map: new (Map$1 || ListCache),
        string: new Hash
    }
}
function isKeyable(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
function getMapData(e, t) {
    var r = e.__data__;
    return isKeyable(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map
}
function mapCacheDelete(e) {
    var t = getMapData(this, e).delete(e);
    return this.size -= t ? 1 : 0,
    t
}
function mapCacheGet(e) {
    return getMapData(this, e).get(e)
}
function mapCacheHas(e) {
    return getMapData(this, e).has(e)
}
function mapCacheSet(e, t) {
    var r = getMapData(this, e)
      , n = r.size;
    return r.set(e, t),
    this.size += r.size == n ? 0 : 1,
    this
}
function MapCache(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var n = e[t];
        this.set(n[0], n[1])
    }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
        throw new TypeError(FUNC_ERROR_TEXT);
    var r = function() {
        var n = arguments
          , o = t ? t.apply(this, n) : n[0]
          , a = r.cache;
        if (a.has(o))
            return a.get(o);
        var s = e.apply(this, n);
        return r.cache = a.set(o, s) || a,
        s
    };
    return r.cache = new (memoize.Cache || MapCache),
    r
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(e) {
    var t = memoize(e, function(n) {
        return r.size === MAX_MEMOIZE_SIZE && r.clear(),
        n
    })
      , r = t.cache;
    return t
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , reEscapeChar$1 = /\\(\\)?/g
  , stringToPath$1 = memoizeCapped(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""),
    e.replace(rePropName$1, function(r, n, o, a) {
        t.push(o ? a.replace(reEscapeChar$1, "$1") : n || r)
    }),
    t
});
function toString$1(e) {
    return e == null ? "" : baseToString(e)
}
function castPath(e, t) {
    return isArray$5(e) ? e : isKey(e, t) ? [e] : stringToPath$1(toString$1(e))
}
var INFINITY = 1 / 0;
function toKey(e) {
    if (typeof e == "string" || isSymbol$1(e))
        return e;
    var t = e + "";
    return t == "0" && 1 / e == -INFINITY ? "-0" : t
}
function baseGet(e, t) {
    t = castPath(t, e);
    for (var r = 0, n = t.length; e != null && r < n; )
        e = e[toKey(t[r++])];
    return r && r == n ? e : void 0
}
function get(e, t, r) {
    var n = e == null ? void 0 : baseGet(e, t);
    return n === void 0 ? r : n
}
function arrayPush(e, t) {
    for (var r = -1, n = t.length, o = e.length; ++r < n; )
        e[o + r] = t[r];
    return e
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(e) {
    return isArray$5(e) || isArguments(e) || !!(spreadableSymbol && e && e[spreadableSymbol])
}
function baseFlatten(e, t, r, n, o) {
    var a = -1
      , s = e.length;
    for (r || (r = isFlattenable),
    o || (o = []); ++a < s; ) {
        var i = e[a];
        r(i) ? arrayPush(o, i) : o[o.length] = i
    }
    return o
}
function flatten(e) {
    var t = e == null ? 0 : e.length;
    return t ? baseFlatten(e) : []
}
function flatRest(e) {
    return setToString(overRest(e, void 0, flatten), e + "")
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
function stackClear() {
    this.__data__ = new ListCache,
    this.size = 0
}
function stackDelete(e) {
    var t = this.__data__
      , r = t.delete(e);
    return this.size = t.size,
    r
}
function stackGet(e) {
    return this.__data__.get(e)
}
function stackHas(e) {
    return this.__data__.has(e)
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(e, t) {
    var r = this.__data__;
    if (r instanceof ListCache) {
        var n = r.__data__;
        if (!Map$1 || n.length < LARGE_ARRAY_SIZE - 1)
            return n.push([e, t]),
            this.size = ++r.size,
            this;
        r = this.__data__ = new MapCache(n)
    }
    return r.set(e, t),
    this.size = r.size,
    this
}
function Stack(e) {
    var t = this.__data__ = new ListCache(e);
    this.size = t.size
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(e, t) {
    return e && copyObject(t, keys(t), e)
}
function baseAssignIn(e, t) {
    return e && copyObject(t, keysIn(t), e)
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports
  , freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module
  , moduleExports = freeModule && freeModule.exports === freeExports
  , Buffer$1 = moduleExports ? root.Buffer : void 0
  , allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(e, t) {
    if (t)
        return e.slice();
    var r = e.length
      , n = allocUnsafe ? allocUnsafe(r) : new e.constructor(r);
    return e.copy(n),
    n
}
function arrayFilter(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, o = 0, a = []; ++r < n; ) {
        var s = e[r];
        t(s, r, e) && (a[o++] = s)
    }
    return a
}
function stubArray() {
    return []
}
var objectProto$1 = Object.prototype
  , propertyIsEnumerable = objectProto$1.propertyIsEnumerable
  , nativeGetSymbols$1 = Object.getOwnPropertySymbols
  , getSymbols = nativeGetSymbols$1 ? function(e) {
    return e == null ? [] : (e = Object(e),
    arrayFilter(nativeGetSymbols$1(e), function(t) {
        return propertyIsEnumerable.call(e, t)
    }))
}
: stubArray;
function copySymbols(e, t) {
    return copyObject(e, getSymbols(e), t)
}
var nativeGetSymbols = Object.getOwnPropertySymbols
  , getSymbolsIn = nativeGetSymbols ? function(e) {
    for (var t = []; e; )
        arrayPush(t, getSymbols(e)),
        e = getPrototype(e);
    return t
}
: stubArray;
function copySymbolsIn(e, t) {
    return copyObject(e, getSymbolsIn(e), t)
}
function baseGetAllKeys(e, t, r) {
    var n = t(e);
    return isArray$5(e) ? n : arrayPush(n, r(e))
}
function getAllKeys(e) {
    return baseGetAllKeys(e, keys, getSymbols)
}
function getAllKeysIn(e) {
    return baseGetAllKeys(e, keysIn, getSymbolsIn)
}
var DataView$1 = getNative(root, "DataView")
  , Promise$1 = getNative(root, "Promise")
  , Set$1 = getNative(root, "Set")
  , mapTag$3 = "[object Map]"
  , objectTag$1 = "[object Object]"
  , promiseTag = "[object Promise]"
  , setTag$3 = "[object Set]"
  , weakMapTag$1 = "[object WeakMap]"
  , dataViewTag$2 = "[object DataView]"
  , dataViewCtorString = toSource(DataView$1)
  , mapCtorString = toSource(Map$1)
  , promiseCtorString = toSource(Promise$1)
  , setCtorString = toSource(Set$1)
  , weakMapCtorString = toSource(WeakMap$1)
  , getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1) && (getTag = function(e) {
    var t = baseGetTag(e)
      , r = t == objectTag$1 ? e.constructor : void 0
      , n = r ? toSource(r) : "";
    if (n)
        switch (n) {
        case dataViewCtorString:
            return dataViewTag$2;
        case mapCtorString:
            return mapTag$3;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag$3;
        case weakMapCtorString:
            return weakMapTag$1
        }
    return t
}
);
var objectProto = Object.prototype
  , hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray(e) {
    var t = e.length
      , r = new e.constructor(t);
    return t && typeof e[0] == "string" && hasOwnProperty$1.call(e, "index") && (r.index = e.index,
    r.input = e.input),
    r
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(e) {
    var t = new e.constructor(e.byteLength);
    return new Uint8Array$1(t).set(new Uint8Array$1(e)),
    t
}
function cloneDataView(e, t) {
    var r = t ? cloneArrayBuffer(e.buffer) : e.buffer;
    return new e.constructor(r,e.byteOffset,e.byteLength)
}
var reFlags = /\w*$/;
function cloneRegExp(e) {
    var t = new e.constructor(e.source,reFlags.exec(e));
    return t.lastIndex = e.lastIndex,
    t
}
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0
  , symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(e) {
    return symbolValueOf ? Object(symbolValueOf.call(e)) : {}
}
function cloneTypedArray(e, t) {
    var r = t ? cloneArrayBuffer(e.buffer) : e.buffer;
    return new e.constructor(r,e.byteOffset,e.length)
}
var boolTag$1 = "[object Boolean]"
  , dateTag$1 = "[object Date]"
  , mapTag$2 = "[object Map]"
  , numberTag$2 = "[object Number]"
  , regexpTag$1 = "[object RegExp]"
  , setTag$2 = "[object Set]"
  , stringTag$1 = "[object String]"
  , symbolTag$1 = "[object Symbol]"
  , arrayBufferTag$1 = "[object ArrayBuffer]"
  , dataViewTag$1 = "[object DataView]"
  , float32Tag$1 = "[object Float32Array]"
  , float64Tag$1 = "[object Float64Array]"
  , int8Tag$1 = "[object Int8Array]"
  , int16Tag$1 = "[object Int16Array]"
  , int32Tag$1 = "[object Int32Array]"
  , uint8Tag$1 = "[object Uint8Array]"
  , uint8ClampedTag$1 = "[object Uint8ClampedArray]"
  , uint16Tag$1 = "[object Uint16Array]"
  , uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(e, t, r) {
    var n = e.constructor;
    switch (t) {
    case arrayBufferTag$1:
        return cloneArrayBuffer(e);
    case boolTag$1:
    case dateTag$1:
        return new n(+e);
    case dataViewTag$1:
        return cloneDataView(e, r);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
        return cloneTypedArray(e, r);
    case mapTag$2:
        return new n;
    case numberTag$2:
    case stringTag$1:
        return new n(e);
    case regexpTag$1:
        return cloneRegExp(e);
    case setTag$2:
        return new n;
    case symbolTag$1:
        return cloneSymbol(e)
    }
}
function initCloneObject(e) {
    return typeof e.constructor == "function" && !isPrototype(e) ? baseCreate(getPrototype(e)) : {}
}
var mapTag$1 = "[object Map]";
function baseIsMap(e) {
    return isObjectLike(e) && getTag(e) == mapTag$1
}
var nodeIsMap = nodeUtil && nodeUtil.isMap
  , isMap$1 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap
  , setTag$1 = "[object Set]";
function baseIsSet(e) {
    return isObjectLike(e) && getTag(e) == setTag$1
}
var nodeIsSet = nodeUtil && nodeUtil.isSet
  , isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet
  , CLONE_DEEP_FLAG$1 = 1
  , CLONE_FLAT_FLAG = 2
  , CLONE_SYMBOLS_FLAG$1 = 4
  , argsTag = "[object Arguments]"
  , arrayTag = "[object Array]"
  , boolTag = "[object Boolean]"
  , dateTag = "[object Date]"
  , errorTag = "[object Error]"
  , funcTag = "[object Function]"
  , genTag = "[object GeneratorFunction]"
  , mapTag = "[object Map]"
  , numberTag$1 = "[object Number]"
  , objectTag = "[object Object]"
  , regexpTag = "[object RegExp]"
  , setTag = "[object Set]"
  , stringTag = "[object String]"
  , symbolTag = "[object Symbol]"
  , weakMapTag = "[object WeakMap]"
  , arrayBufferTag = "[object ArrayBuffer]"
  , dataViewTag = "[object DataView]"
  , float32Tag = "[object Float32Array]"
  , float64Tag = "[object Float64Array]"
  , int8Tag = "[object Int8Array]"
  , int16Tag = "[object Int16Array]"
  , int32Tag = "[object Int32Array]"
  , uint8Tag = "[object Uint8Array]"
  , uint8ClampedTag = "[object Uint8ClampedArray]"
  , uint16Tag = "[object Uint16Array]"
  , uint32Tag = "[object Uint32Array]"
  , cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
function baseClone(e, t, r, n, o, a) {
    var s, i = t & CLONE_DEEP_FLAG$1, l = t & CLONE_FLAT_FLAG, u = t & CLONE_SYMBOLS_FLAG$1;
    if (r && (s = o ? r(e, n, o, a) : r(e)),
    s !== void 0)
        return s;
    if (!isObject$2(e))
        return e;
    var c = isArray$5(e);
    if (c) {
        if (s = initCloneArray(e),
        !i)
            return copyArray(e, s)
    } else {
        var f = getTag(e)
          , d = f == funcTag || f == genTag;
        if (isBuffer$1(e))
            return cloneBuffer(e, i);
        if (f == objectTag || f == argsTag || d && !o) {
            if (s = l || d ? {} : initCloneObject(e),
            !i)
                return l ? copySymbolsIn(e, baseAssignIn(s, e)) : copySymbols(e, baseAssign(s, e))
        } else {
            if (!cloneableTags[f])
                return o ? e : {};
            s = initCloneByTag(e, f, i)
        }
    }
    a || (a = new Stack);
    var p = a.get(e);
    if (p)
        return p;
    a.set(e, s),
    isSet$1(e) ? e.forEach(function(_) {
        s.add(baseClone(_, t, r, _, e, a))
    }) : isMap$1(e) && e.forEach(function(_, b) {
        s.set(b, baseClone(_, t, r, b, e, a))
    });
    var m = u ? l ? getAllKeysIn : getAllKeys : l ? keysIn : keys
      , g = c ? void 0 : m(e);
    return arrayEach(g || e, function(_, b) {
        g && (b = _,
        _ = e[b]),
        assignValue(s, b, baseClone(_, t, r, b, e, a))
    }),
    s
}
var CLONE_DEEP_FLAG = 1
  , CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(e) {
    return baseClone(e, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
}
function baseHasIn(e, t) {
    return e != null && t in Object(e)
}
function hasPath(e, t, r) {
    t = castPath(t, e);
    for (var n = -1, o = t.length, a = !1; ++n < o; ) {
        var s = toKey(t[n]);
        if (!(a = e != null && r(e, s)))
            break;
        e = e[s]
    }
    return a || ++n != o ? a : (o = e == null ? 0 : e.length,
    !!o && isLength(o) && isIndex(s, o) && (isArray$5(e) || isArguments(e)))
}
function hasIn(e, t) {
    return e != null && hasPath(e, t, baseHasIn)
}
function fromPairs(e) {
    for (var t = -1, r = e == null ? 0 : e.length, n = {}; ++t < r; ) {
        var o = e[t];
        n[o[0]] = o[1]
    }
    return n
}
var numberTag = "[object Number]";
function isNumber$2(e) {
    return typeof e == "number" || isObjectLike(e) && baseGetTag(e) == numberTag
}
function isNaN$1(e) {
    return isNumber$2(e) && e != +e
}
function isNil(e) {
    return e == null
}
function baseSet(e, t, r, n) {
    if (!isObject$2(e))
        return e;
    t = castPath(t, e);
    for (var o = -1, a = t.length, s = a - 1, i = e; i != null && ++o < a; ) {
        var l = toKey(t[o])
          , u = r;
        if (l === "__proto__" || l === "constructor" || l === "prototype")
            return e;
        if (o != s) {
            var c = i[l];
            u = void 0,
            u === void 0 && (u = isObject$2(c) ? c : isIndex(t[o + 1]) ? [] : {})
        }
        assignValue(i, l, u),
        i = i[l]
    }
    return e
}
function basePickBy(e, t, r) {
    for (var n = -1, o = t.length, a = {}; ++n < o; ) {
        var s = t[n]
          , i = baseGet(e, s);
        r(i, s) && baseSet(a, castPath(s, e), i)
    }
    return a
}
function basePick(e, t) {
    return basePickBy(e, t, function(r, n) {
        return hasIn(e, n)
    })
}
var pick = flatRest(function(e, t) {
    return e == null ? {} : basePick(e, t)
});
function set(e, t, r) {
    return e == null ? e : baseSet(e, t, r)
}
let config = null;
function uXpConfig() {
    if (!config) {
        let e = function({str: o, suffix: a, domain: s}) {
            return `https://${o}${a || t.suffix}.${s || "simuwang"}.com`
        };
        const t = useRuntimeConfig().public
          , r = e({
            str: "static"
        })
          , n = e({
            suffix: t.suffix === "-pre" ? "-test" : t.suffix,
            str: "static"
        }) + "/web-static";
        config = {
            ...t,
            apiHost: e({
                str: "sppwapi"
            }),
            oldApiHost: e({
                str: "ppwapi"
            }),
            appApiHost: e({
                str: "ppwapp"
            }),
            staticHost: r,
            staticFolder: n,
            staticImgFolder: n + "/ppw/image",
            mainHost: e({
                str: "www"
            }),
            dcHost: e({
                str: "dc"
            }),
            lyHost: e({
                str: "ly"
            }),
            mobileWealthHost: e({
                str: "mobile",
                domain: "ppwfund"
            }),
            mobileHost: e({
                str: "mobile"
            }),
            searchHost: e({
                str: "s"
            }),
            fofHost: e({
                str: t.suffix ? "fofpro" : "fof",
                suffix: t.suffix === "-pre" ? "-uat" : t.suffix
            })
        }
    }
    return config
}
function tryOnScopeDispose$1(e) {
    return getCurrentScope() ? (onScopeDispose(e),
    !0) : !1
}
function extendRef(e, t, {enumerable: r=!1, unwrap: n=!0}={}) {
    for (const [o,a] of Object.entries(t))
        o !== "value" && (isRef(a) && n ? Object.defineProperty(e, o, {
            get() {
                return a.value
            },
            set(s) {
                a.value = s
            },
            enumerable: r
        }) : Object.defineProperty(e, o, {
            value: a,
            enumerable: r
        }));
    return e
}
function makeDestructurable(e, t) {
    if (typeof Symbol < "u") {
        const r = {
            ...e
        };
        return Object.defineProperty(r, Symbol.iterator, {
            enumerable: !1,
            value() {
                let n = 0;
                return {
                    next: () => ({
                        value: t[n++],
                        done: n > t.length
                    })
                }
            }
        }),
        r
    } else
        return Object.assign([...t], e)
}
function toValue(e) {
    return typeof e == "function" ? e() : unref(e)
}
function toReactive(e) {
    if (!isRef(e))
        return reactive(e);
    const t = new Proxy({},{
        get(r, n, o) {
            return unref(Reflect.get(e.value, n, o))
        },
        set(r, n, o) {
            return isRef(e.value[n]) && !isRef(o) ? e.value[n].value = o : e.value[n] = o,
            !0
        },
        deleteProperty(r, n) {
            return Reflect.deleteProperty(e.value, n)
        },
        has(r, n) {
            return Reflect.has(e.value, n)
        },
        ownKeys() {
            return Object.keys(e.value)
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: !0,
                configurable: !0
            }
        }
    });
    return reactive(t)
}
function reactiveComputed(e) {
    return toReactive(computed(e))
}
const isClient$1 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const isDef = e => typeof e < "u"
  , notNullish = e => e != null
  , toString = Object.prototype.toString
  , isObject$1 = e => toString.call(e) === "[object Object]"
  , timestamp = () => +Date.now()
  , noop$1 = () => {}
  , isIOS$1 = getIsIOS();
function getIsIOS() {
    var e, t;
    return isClient$1 && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}
function createFilterWrapper$1(e, t) {
    function r(...n) {
        return new Promise( (o, a) => {
            Promise.resolve(e( () => t.apply(this, n), {
                fn: t,
                thisArg: this,
                args: n
            })).then(o).catch(a)
        }
        )
    }
    return r
}
const bypassFilter = e => e();
function debounceFilter$1(e, t={}) {
    let r, n, o = noop$1;
    const a = i => {
        clearTimeout(i),
        o(),
        o = noop$1
    }
    ;
    return i => {
        const l = toValue(e)
          , u = toValue(t.maxWait);
        return r && a(r),
        l <= 0 || u !== void 0 && u <= 0 ? (n && (a(n),
        n = null),
        Promise.resolve(i())) : new Promise( (c, f) => {
            o = t.rejectOnCancel ? f : c,
            u && !n && (n = setTimeout( () => {
                r && a(r),
                n = null,
                c(i())
            }
            , u)),
            r = setTimeout( () => {
                n && a(n),
                n = null,
                c(i())
            }
            , l)
        }
        )
    }
}
function throttleFilter$1(...e) {
    let t = 0, r, n = !0, o = noop$1, a, s, i, l, u;
    !isRef(e[0]) && typeof e[0] == "object" ? {delay: s, trailing: i=!0, leading: l=!0, rejectOnCancel: u=!1} = e[0] : [s,i=!0,l=!0,u=!1] = e;
    const c = () => {
        r && (clearTimeout(r),
        r = void 0,
        o(),
        o = noop$1)
    }
    ;
    return d => {
        const p = toValue(s)
          , m = Date.now() - t
          , g = () => a = d();
        return c(),
        p <= 0 ? (t = Date.now(),
        g()) : (m > p && (l || !n) ? (t = Date.now(),
        g()) : i && (a = new Promise( (_, b) => {
            o = u ? b : _,
            r = setTimeout( () => {
                t = Date.now(),
                n = !0,
                _(g()),
                c()
            }
            , Math.max(0, p - m))
        }
        )),
        !l && !r && (r = setTimeout( () => n = !0, p)),
        n = !1,
        a)
    }
}
function pausableFilter(e=bypassFilter) {
    const t = ref(!0);
    function r() {
        t.value = !1
    }
    function n() {
        t.value = !0
    }
    const o = (...a) => {
        t.value && e(...a)
    }
    ;
    return {
        isActive: readonly(t),
        pause: r,
        resume: n,
        eventFilter: o
    }
}
function cacheStringFunction$1(e) {
    const t = Object.create(null);
    return r => t[r] || (t[r] = e(r))
}
const camelizeRE$1 = /-(\w)/g
  , camelize$1 = cacheStringFunction$1(e => e.replace(camelizeRE$1, (t, r) => r ? r.toUpperCase() : ""));
function promiseTimeout(e, t=!1, r="Timeout") {
    return new Promise( (n, o) => {
        setTimeout(t ? () => o(r) : n, e)
    }
    )
}
function getLifeCycleTarget(e) {
    return getCurrentInstance()
}
function useDebounceFn$1(e, t=200, r={}) {
    return createFilterWrapper$1(debounceFilter$1(t, r), e)
}
function useThrottleFn$1(e, t=200, r=!1, n=!0, o=!1) {
    return createFilterWrapper$1(throttleFilter$1(t, r, n, o), e)
}
function watchWithFilter(e, t, r={}) {
    const {eventFilter: n=bypassFilter, ...o} = r;
    return watch(e, createFilterWrapper$1(n, t), o)
}
function watchPausable(e, t, r={}) {
    const {eventFilter: n, ...o} = r
      , {eventFilter: a, pause: s, resume: i, isActive: l} = pausableFilter(n);
    return {
        stop: watchWithFilter(e, t, {
            ...o,
            eventFilter: a
        }),
        pause: s,
        resume: i,
        isActive: l
    }
}
function tryOnMounted$1(e, t=!0, r) {
    getLifeCycleTarget() ? onMounted(e, r) : t ? e() : nextTick(e)
}
function tryOnUnmounted(e, t) {
    getLifeCycleTarget() && onUnmounted(e, t)
}
function createUntil(e, t=!1) {
    function r(f, {flush: d="sync", deep: p=!1, timeout: m, throwOnTimeout: g}={}) {
        let _ = null;
        const y = [new Promise(v => {
            _ = watch(e, S => {
                f(S) !== t && (_ == null || _(),
                v(S))
            }
            , {
                flush: d,
                deep: p,
                immediate: !0
            })
        }
        )];
        return m != null && y.push(promiseTimeout(m, g).then( () => toValue(e)).finally( () => _ == null ? void 0 : _())),
        Promise.race(y)
    }
    function n(f, d) {
        if (!isRef(f))
            return r(S => S === f, d);
        const {flush: p="sync", deep: m=!1, timeout: g, throwOnTimeout: _} = d ?? {};
        let b = null;
        const v = [new Promise(S => {
            b = watch([e, f], ([C,x]) => {
                t !== (C === x) && (b == null || b(),
                S(C))
            }
            , {
                flush: p,
                deep: m,
                immediate: !0
            })
        }
        )];
        return g != null && v.push(promiseTimeout(g, _).then( () => toValue(e)).finally( () => (b == null || b(),
        toValue(e)))),
        Promise.race(v)
    }
    function o(f) {
        return r(d => !!d, f)
    }
    function a(f) {
        return n(null, f)
    }
    function s(f) {
        return n(void 0, f)
    }
    function i(f) {
        return r(Number.isNaN, f)
    }
    function l(f, d) {
        return r(p => {
            const m = Array.from(p);
            return m.includes(f) || m.includes(toValue(f))
        }
        , d)
    }
    function u(f) {
        return c(1, f)
    }
    function c(f=1, d) {
        let p = -1;
        return r( () => (p += 1,
        p >= f), d)
    }
    return Array.isArray(toValue(e)) ? {
        toMatch: r,
        toContains: l,
        changed: u,
        changedTimes: c,
        get not() {
            return createUntil(e, !t)
        }
    } : {
        toMatch: r,
        toBe: n,
        toBeTruthy: o,
        toBeNull: a,
        toBeNaN: i,
        toBeUndefined: s,
        changed: u,
        changedTimes: c,
        get not() {
            return createUntil(e, !t)
        }
    }
}
function until(e) {
    return createUntil(e)
}
const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i
  , REGEX_FORMAT = /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
function defaultMeridiem(e, t, r, n) {
    let o = e < 12 ? "AM" : "PM";
    return n && (o = o.split("").reduce( (a, s) => a += `${s}.`, "")),
    r ? o.toLowerCase() : o
}
function formatOrdinal(e) {
    const t = ["th", "st", "nd", "rd"]
      , r = e % 100;
    return e + (t[(r - 20) % 10] || t[r] || t[0])
}
function formatDate(e, t, r={}) {
    var n;
    const o = e.getFullYear()
      , a = e.getMonth()
      , s = e.getDate()
      , i = e.getHours()
      , l = e.getMinutes()
      , u = e.getSeconds()
      , c = e.getMilliseconds()
      , f = e.getDay()
      , d = (n = r.customMeridiem) != null ? n : defaultMeridiem
      , p = {
        Yo: () => formatOrdinal(o),
        YY: () => String(o).slice(-2),
        YYYY: () => o,
        M: () => a + 1,
        Mo: () => formatOrdinal(a + 1),
        MM: () => `${a + 1}`.padStart(2, "0"),
        MMM: () => e.toLocaleDateString(r.locales, {
            month: "short"
        }),
        MMMM: () => e.toLocaleDateString(r.locales, {
            month: "long"
        }),
        D: () => String(s),
        Do: () => formatOrdinal(s),
        DD: () => `${s}`.padStart(2, "0"),
        H: () => String(i),
        Ho: () => formatOrdinal(i),
        HH: () => `${i}`.padStart(2, "0"),
        h: () => `${i % 12 || 12}`.padStart(1, "0"),
        ho: () => formatOrdinal(i % 12 || 12),
        hh: () => `${i % 12 || 12}`.padStart(2, "0"),
        m: () => String(l),
        mo: () => formatOrdinal(l),
        mm: () => `${l}`.padStart(2, "0"),
        s: () => String(u),
        so: () => formatOrdinal(u),
        ss: () => `${u}`.padStart(2, "0"),
        SSS: () => `${c}`.padStart(3, "0"),
        d: () => f,
        dd: () => e.toLocaleDateString(r.locales, {
            weekday: "narrow"
        }),
        ddd: () => e.toLocaleDateString(r.locales, {
            weekday: "short"
        }),
        dddd: () => e.toLocaleDateString(r.locales, {
            weekday: "long"
        }),
        A: () => d(i, l),
        AA: () => d(i, l, !1, !0),
        a: () => d(i, l, !0),
        aa: () => d(i, l, !0, !0)
    };
    return t.replace(REGEX_FORMAT, (m, g) => {
        var _, b;
        return (b = g ?? ((_ = p[m]) == null ? void 0 : _.call(p))) != null ? b : m
    }
    )
}
function normalizeDate(e) {
    if (e === null)
        return new Date(Number.NaN);
    if (e === void 0)
        return new Date;
    if (e instanceof Date)
        return new Date(e);
    if (typeof e == "string" && !/Z$/i.test(e)) {
        const t = e.match(REGEX_PARSE);
        if (t) {
            const r = t[2] - 1 || 0
              , n = (t[7] || "0").substring(0, 3);
            return new Date(t[1],r,t[3] || 1,t[4] || 0,t[5] || 0,t[6] || 0,n)
        }
    }
    return new Date(e)
}
function useDateFormat(e, t="HH:mm:ss", r={}) {
    return computed( () => formatDate(normalizeDate(toValue(e)), toValue(t), r))
}
function useIntervalFn(e, t=1e3, r={}) {
    const {immediate: n=!0, immediateCallback: o=!1} = r;
    let a = null;
    const s = ref(!1);
    function i() {
        a && (clearInterval(a),
        a = null)
    }
    function l() {
        s.value = !1,
        i()
    }
    function u() {
        const c = toValue(t);
        c <= 0 || (s.value = !0,
        o && e(),
        i(),
        a = setInterval(e, c))
    }
    if (n && isClient$1 && u(),
    isRef(t) || typeof t == "function") {
        const c = watch(t, () => {
            s.value && isClient$1 && u()
        }
        );
        tryOnScopeDispose$1(c)
    }
    return tryOnScopeDispose$1(l),
    {
        isActive: s,
        pause: l,
        resume: u
    }
}
function watchDebounced(e, t, r={}) {
    const {debounce: n=0, maxWait: o=void 0, ...a} = r;
    return watchWithFilter(e, t, {
        ...a,
        eventFilter: debounceFilter$1(n, {
            maxWait: o
        })
    })
}
function watchDeep(e, t, r) {
    return watch(e, t, {
        ...r,
        deep: !0
    })
}
function watchImmediate(e, t, r) {
    return watch(e, t, {
        ...r,
        immediate: !0
    })
}
function watchOnce(e, t, r) {
    const n = watch(e, (...o) => (nextTick( () => n()),
    t(...o)), r);
    return n
}
function createReusableTemplate(e={}) {
    const {inheritAttrs: t=!0} = e
      , r = shallowRef()
      , n = defineComponent({
        setup(a, {slots: s}) {
            return () => {
                r.value = s.default
            }
        }
    })
      , o = defineComponent({
        inheritAttrs: t,
        setup(a, {attrs: s, slots: i}) {
            return () => {
                var l;
                r.value;
                const u = (l = r.value) == null ? void 0 : l.call(r, {
                    ...keysToCamelKebabCase(s),
                    $slots: i
                });
                return t && (u == null ? void 0 : u.length) === 1 ? u[0] : u
            }
        }
    });
    return makeDestructurable({
        define: n,
        reuse: o
    }, [n, o])
}
function keysToCamelKebabCase(e) {
    const t = {};
    for (const r in e)
        t[camelize$1(r)] = e[r];
    return t
}
function unrefElement$1(e) {
    var t;
    const r = toValue(e);
    return (t = r == null ? void 0 : r.$el) != null ? t : r
}
const defaultWindow$1 = isClient$1 ? window : void 0
  , defaultDocument = isClient$1 ? window.document : void 0;
function useEventListener$1(...e) {
    let t, r, n, o;
    if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([r,n,o] = e,
    t = defaultWindow$1) : [t,r,n,o] = e,
    !t)
        return noop$1;
    Array.isArray(r) || (r = [r]),
    Array.isArray(n) || (n = [n]);
    const a = []
      , s = () => {
        a.forEach(c => c()),
        a.length = 0
    }
      , i = (c, f, d, p) => (c.addEventListener(f, d, p),
    () => c.removeEventListener(f, d, p))
      , l = watch( () => [unrefElement$1(t), toValue(o)], ([c,f]) => {
        if (s(),
        !c)
            return;
        const d = isObject$1(f) ? {
            ...f
        } : f;
        a.push(...r.flatMap(p => n.map(m => i(c, p, m, d))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => {
        l(),
        s()
    }
    ;
    return tryOnScopeDispose$1(u),
    u
}
let _iOSWorkaround$1 = !1;
function onClickOutside$1(e, t, r={}) {
    const {window: n=defaultWindow$1, ignore: o=[], capture: a=!0, detectIframe: s=!1} = r;
    if (!n)
        return noop$1;
    isIOS$1 && !_iOSWorkaround$1 && (_iOSWorkaround$1 = !0,
    Array.from(n.document.body.children).forEach(d => d.addEventListener("click", noop$1)),
    n.document.documentElement.addEventListener("click", noop$1));
    let i = !0;
    const l = d => o.some(p => {
        if (typeof p == "string")
            return Array.from(n.document.querySelectorAll(p)).some(m => m === d.target || d.composedPath().includes(m));
        {
            const m = unrefElement$1(p);
            return m && (d.target === m || d.composedPath().includes(m))
        }
    }
    )
      , c = [useEventListener$1(n, "click", d => {
        const p = unrefElement$1(e);
        if (!(!p || p === d.target || d.composedPath().includes(p))) {
            if (d.detail === 0 && (i = !l(d)),
            !i) {
                i = !0;
                return
            }
            t(d)
        }
    }
    , {
        passive: !0,
        capture: a
    }), useEventListener$1(n, "pointerdown", d => {
        const p = unrefElement$1(e);
        i = !l(d) && !!(p && !d.composedPath().includes(p))
    }
    , {
        passive: !0
    }), s && useEventListener$1(n, "blur", d => {
        setTimeout( () => {
            var p;
            const m = unrefElement$1(e);
            ((p = n.document.activeElement) == null ? void 0 : p.tagName) === "IFRAME" && !(m != null && m.contains(n.document.activeElement)) && t(d)
        }
        , 0)
    }
    )].filter(Boolean);
    return () => c.forEach(d => d())
}
function useMounted() {
    const e = ref(!1)
      , t = getCurrentInstance();
    return t && onMounted( () => {
        e.value = !0
    }
    , t),
    e
}
function useSupported$1(e) {
    const t = useMounted();
    return computed( () => (t.value,
    !!e()))
}
function useMutationObserver$1(e, t, r={}) {
    const {window: n=defaultWindow$1, ...o} = r;
    let a;
    const s = useSupported$1( () => n && "MutationObserver"in n)
      , i = () => {
        a && (a.disconnect(),
        a = void 0)
    }
      , l = computed( () => {
        const d = toValue(e)
          , p = (Array.isArray(d) ? d : [d]).map(unrefElement$1).filter(notNullish);
        return new Set(p)
    }
    )
      , u = watch( () => l.value, d => {
        i(),
        s.value && d.size && (a = new MutationObserver(t),
        d.forEach(p => a.observe(p, o)))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => a == null ? void 0 : a.takeRecords()
      , f = () => {
        i(),
        u()
    }
    ;
    return tryOnScopeDispose$1(f),
    {
        isSupported: s,
        stop: f,
        takeRecords: c
    }
}
function useRafFn(e, t={}) {
    const {immediate: r=!0, fpsLimit: n=void 0, window: o=defaultWindow$1} = t
      , a = ref(!1)
      , s = n ? 1e3 / n : null;
    let i = 0
      , l = null;
    function u(d) {
        if (!a.value || !o)
            return;
        i || (i = d);
        const p = d - i;
        if (s && p < s) {
            l = o.requestAnimationFrame(u);
            return
        }
        i = d,
        e({
            delta: p,
            timestamp: d
        }),
        l = o.requestAnimationFrame(u)
    }
    function c() {
        !a.value && o && (a.value = !0,
        i = 0,
        l = o.requestAnimationFrame(u))
    }
    function f() {
        a.value = !1,
        l != null && o && (o.cancelAnimationFrame(l),
        l = null)
    }
    return r && c(),
    tryOnScopeDispose$1(f),
    {
        isActive: readonly(a),
        pause: f,
        resume: c
    }
}
function useMediaQuery(e, t={}) {
    const {window: r=defaultWindow$1} = t
      , n = useSupported$1( () => r && "matchMedia"in r && typeof r.matchMedia == "function");
    let o;
    const a = ref(!1)
      , s = u => {
        a.value = u.matches
    }
      , i = () => {
        o && ("removeEventListener"in o ? o.removeEventListener("change", s) : o.removeListener(s))
    }
      , l = watchEffect( () => {
        n.value && (i(),
        o = r.matchMedia(toValue(e)),
        "addEventListener"in o ? o.addEventListener("change", s) : o.addListener(s),
        a.value = o.matches)
    }
    );
    return tryOnScopeDispose$1( () => {
        l(),
        i(),
        o = void 0
    }
    ),
    a
}
function cloneFnJSON(e) {
    return JSON.parse(JSON.stringify(e))
}
const _global$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , globalKey$1 = "__vueuse_ssr_handlers__"
  , handlers = getHandlers();
function getHandlers() {
    return globalKey$1 in _global$1 || (_global$1[globalKey$1] = _global$1[globalKey$1] || {}),
    _global$1[globalKey$1]
}
function getSSRHandler(e, t) {
    return handlers[e] || t
}
function guessSerializerType(e) {
    return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number"
}
const StorageSerializers = {
    boolean: {
        read: e => e === "true",
        write: e => String(e)
    },
    object: {
        read: e => JSON.parse(e),
        write: e => JSON.stringify(e)
    },
    number: {
        read: e => Number.parseFloat(e),
        write: e => String(e)
    },
    any: {
        read: e => e,
        write: e => String(e)
    },
    string: {
        read: e => e,
        write: e => String(e)
    },
    map: {
        read: e => new Map(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e.entries()))
    },
    set: {
        read: e => new Set(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e))
    },
    date: {
        read: e => new Date(e),
        write: e => e.toISOString()
    }
}
  , customStorageEventName = "vueuse-storage";
function useStorage(e, t, r, n={}) {
    var o;
    const {flush: a="pre", deep: s=!0, listenToStorageChanges: i=!0, writeDefaults: l=!0, mergeDefaults: u=!1, shallow: c, window: f=defaultWindow$1, eventFilter: d, onError: p=w => {
        console.error(w)
    }
    , initOnMounted: m} = n
      , g = (c ? shallowRef : ref)(typeof t == "function" ? t() : t);
    if (!r)
        try {
            r = getSSRHandler("getDefaultStorage", () => {
                var w;
                return (w = defaultWindow$1) == null ? void 0 : w.localStorage
            }
            )()
        } catch (w) {
            p(w)
        }
    if (!r)
        return g;
    const _ = toValue(t)
      , b = guessSerializerType(_)
      , y = (o = n.serializer) != null ? o : StorageSerializers[b]
      , {pause: v, resume: S} = watchPausable(g, () => x(g.value), {
        flush: a,
        deep: s,
        eventFilter: d
    });
    f && i && tryOnMounted$1( () => {
        useEventListener$1(f, "storage", I),
        useEventListener$1(f, customStorageEventName, M),
        m && I()
    }
    ),
    m || I();
    function C(w, T) {
        f && f.dispatchEvent(new CustomEvent(customStorageEventName,{
            detail: {
                key: e,
                oldValue: w,
                newValue: T,
                storageArea: r
            }
        }))
    }
    function x(w) {
        try {
            const T = r.getItem(e);
            if (w == null)
                C(T, null),
                r.removeItem(e);
            else {
                const k = y.write(w);
                T !== k && (r.setItem(e, k),
                C(T, k))
            }
        } catch (T) {
            p(T)
        }
    }
    function E(w) {
        const T = w ? w.newValue : r.getItem(e);
        if (T == null)
            return l && _ != null && r.setItem(e, y.write(_)),
            _;
        if (!w && u) {
            const k = y.read(T);
            return typeof u == "function" ? u(k, _) : b === "object" && !Array.isArray(k) ? {
                ..._,
                ...k
            } : k
        } else
            return typeof T != "string" ? T : y.read(T)
    }
    function I(w) {
        if (!(w && w.storageArea !== r)) {
            if (w && w.key == null) {
                g.value = _;
                return
            }
            if (!(w && w.key !== e)) {
                v();
                try {
                    (w == null ? void 0 : w.newValue) !== y.write(g.value) && (g.value = E(w))
                } catch (T) {
                    p(T)
                } finally {
                    w ? nextTick(S) : S()
                }
            }
        }
    }
    function M(w) {
        I(w.detail)
    }
    return g
}
function useResizeObserver$1(e, t, r={}) {
    const {window: n=defaultWindow$1, ...o} = r;
    let a;
    const s = useSupported$1( () => n && "ResizeObserver"in n)
      , i = () => {
        a && (a.disconnect(),
        a = void 0)
    }
      , l = computed( () => Array.isArray(e) ? e.map(f => unrefElement$1(f)) : [unrefElement$1(e)])
      , u = watch(l, f => {
        if (i(),
        s.value && n) {
            a = new ResizeObserver(t);
            for (const d of f)
                d && a.observe(d, o)
        }
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        i(),
        u()
    }
    ;
    return tryOnScopeDispose$1(c),
    {
        isSupported: s,
        stop: c
    }
}
function useElementBounding(e, t={}) {
    const {reset: r=!0, windowResize: n=!0, windowScroll: o=!0, immediate: a=!0} = t
      , s = ref(0)
      , i = ref(0)
      , l = ref(0)
      , u = ref(0)
      , c = ref(0)
      , f = ref(0)
      , d = ref(0)
      , p = ref(0);
    function m() {
        const g = unrefElement$1(e);
        if (!g) {
            r && (s.value = 0,
            i.value = 0,
            l.value = 0,
            u.value = 0,
            c.value = 0,
            f.value = 0,
            d.value = 0,
            p.value = 0);
            return
        }
        const _ = g.getBoundingClientRect();
        s.value = _.height,
        i.value = _.bottom,
        l.value = _.left,
        u.value = _.right,
        c.value = _.top,
        f.value = _.width,
        d.value = _.x,
        p.value = _.y
    }
    return useResizeObserver$1(e, m),
    watch( () => unrefElement$1(e), g => !g && m()),
    useMutationObserver$1(e, m, {
        attributeFilter: ["style", "class"]
    }),
    o && useEventListener$1("scroll", m, {
        capture: !0,
        passive: !0
    }),
    n && useEventListener$1("resize", m, {
        passive: !0
    }),
    tryOnMounted$1( () => {
        a && m()
    }
    ),
    {
        height: s,
        bottom: i,
        left: l,
        right: u,
        top: c,
        width: f,
        x: d,
        y: p,
        update: m
    }
}
function useElementHover(e, t={}) {
    const {delayEnter: r=0, delayLeave: n=0, window: o=defaultWindow$1} = t
      , a = ref(!1);
    let s;
    const i = l => {
        const u = l ? r : n;
        s && (clearTimeout(s),
        s = void 0),
        u ? s = setTimeout( () => a.value = l, u) : a.value = l
    }
    ;
    return o && (useEventListener$1(e, "mouseenter", () => i(!0), {
        passive: !0
    }),
    useEventListener$1(e, "mouseleave", () => i(!1), {
        passive: !0
    })),
    a
}
function useElementSize(e, t={
    width: 0,
    height: 0
}, r={}) {
    const {window: n=defaultWindow$1, box: o="content-box"} = r
      , a = computed( () => {
        var f, d;
        return (d = (f = unrefElement$1(e)) == null ? void 0 : f.namespaceURI) == null ? void 0 : d.includes("svg")
    }
    )
      , s = ref(t.width)
      , i = ref(t.height)
      , {stop: l} = useResizeObserver$1(e, ([f]) => {
        const d = o === "border-box" ? f.borderBoxSize : o === "content-box" ? f.contentBoxSize : f.devicePixelContentBoxSize;
        if (n && a.value) {
            const p = unrefElement$1(e);
            if (p) {
                const m = p.getBoundingClientRect();
                s.value = m.width,
                i.value = m.height
            }
        } else if (d) {
            const p = Array.isArray(d) ? d : [d];
            s.value = p.reduce( (m, {inlineSize: g}) => m + g, 0),
            i.value = p.reduce( (m, {blockSize: g}) => m + g, 0)
        } else
            s.value = f.contentRect.width,
            i.value = f.contentRect.height
    }
    , r);
    tryOnMounted$1( () => {
        const f = unrefElement$1(e);
        f && (s.value = "offsetWidth"in f ? f.offsetWidth : t.width,
        i.value = "offsetHeight"in f ? f.offsetHeight : t.height)
    }
    );
    const u = watch( () => unrefElement$1(e), f => {
        s.value = f ? t.width : 0,
        i.value = f ? t.height : 0
    }
    );
    function c() {
        l(),
        u()
    }
    return {
        width: s,
        height: i,
        stop: c
    }
}
function useIntersectionObserver(e, t, r={}) {
    const {root: n, rootMargin: o="0px", threshold: a=.1, window: s=defaultWindow$1, immediate: i=!0} = r
      , l = useSupported$1( () => s && "IntersectionObserver"in s)
      , u = computed( () => {
        const m = toValue(e);
        return (Array.isArray(m) ? m : [m]).map(unrefElement$1).filter(notNullish)
    }
    );
    let c = noop$1;
    const f = ref(i)
      , d = l.value ? watch( () => [u.value, unrefElement$1(n), f.value], ([m,g]) => {
        if (c(),
        !f.value || !m.length)
            return;
        const _ = new IntersectionObserver(t,{
            root: unrefElement$1(g),
            rootMargin: o,
            threshold: a
        });
        m.forEach(b => b && _.observe(b)),
        c = () => {
            _.disconnect(),
            c = noop$1
        }
    }
    , {
        immediate: i,
        flush: "post"
    }) : noop$1
      , p = () => {
        c(),
        d(),
        f.value = !1
    }
    ;
    return tryOnScopeDispose$1(p),
    {
        isSupported: l,
        isActive: f,
        pause() {
            c(),
            f.value = !1
        },
        resume() {
            f.value = !0
        },
        stop: p
    }
}
function useElementVisibility(e, t={}) {
    const {window: r=defaultWindow$1, scrollTarget: n, threshold: o=0} = t
      , a = ref(!1);
    return useIntersectionObserver(e, s => {
        let i = a.value
          , l = 0;
        for (const u of s)
            u.time >= l && (l = u.time,
            i = u.isIntersecting);
        a.value = i
    }
    , {
        root: n,
        window: r,
        threshold: o
    }),
    a
}
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(e, t={}) {
    const {throttle: r=0, idle: n=200, onStop: o=noop$1, onScroll: a=noop$1, offset: s={
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    }, eventListenerOptions: i={
        capture: !1,
        passive: !0
    }, behavior: l="auto", window: u=defaultWindow$1, onError: c=E => {
        console.error(E)
    }
    } = t
      , f = ref(0)
      , d = ref(0)
      , p = computed({
        get() {
            return f.value
        },
        set(E) {
            g(E, void 0)
        }
    })
      , m = computed({
        get() {
            return d.value
        },
        set(E) {
            g(void 0, E)
        }
    });
    function g(E, I) {
        var M, w, T, k;
        if (!u)
            return;
        const A = toValue(e);
        if (!A)
            return;
        (T = A instanceof Document ? u.document.body : A) == null || T.scrollTo({
            top: (M = toValue(I)) != null ? M : m.value,
            left: (w = toValue(E)) != null ? w : p.value,
            behavior: toValue(l)
        });
        const B = ((k = A == null ? void 0 : A.document) == null ? void 0 : k.documentElement) || (A == null ? void 0 : A.documentElement) || A;
        p != null && (f.value = B.scrollLeft),
        m != null && (d.value = B.scrollTop)
    }
    const _ = ref(!1)
      , b = reactive({
        left: !0,
        right: !1,
        top: !0,
        bottom: !1
    })
      , y = reactive({
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
    })
      , v = E => {
        _.value && (_.value = !1,
        y.left = !1,
        y.right = !1,
        y.top = !1,
        y.bottom = !1,
        o(E))
    }
      , S = useDebounceFn$1(v, r + n)
      , C = E => {
        var I;
        if (!u)
            return;
        const M = ((I = E == null ? void 0 : E.document) == null ? void 0 : I.documentElement) || (E == null ? void 0 : E.documentElement) || unrefElement$1(E)
          , {display: w, flexDirection: T} = getComputedStyle(M)
          , k = M.scrollLeft;
        y.left = k < f.value,
        y.right = k > f.value;
        const A = Math.abs(k) <= (s.left || 0)
          , B = Math.abs(k) + M.clientWidth >= M.scrollWidth - (s.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
        w === "flex" && T === "row-reverse" ? (b.left = B,
        b.right = A) : (b.left = A,
        b.right = B),
        f.value = k;
        let $ = M.scrollTop;
        E === u.document && !$ && ($ = u.document.body.scrollTop),
        y.top = $ < d.value,
        y.bottom = $ > d.value;
        const P = Math.abs($) <= (s.top || 0)
          , N = Math.abs($) + M.clientHeight >= M.scrollHeight - (s.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
        w === "flex" && T === "column-reverse" ? (b.top = N,
        b.bottom = P) : (b.top = P,
        b.bottom = N),
        d.value = $
    }
      , x = E => {
        var I;
        if (!u)
            return;
        const M = (I = E.target.documentElement) != null ? I : E.target;
        C(M),
        _.value = !0,
        S(E),
        a(E)
    }
    ;
    return useEventListener$1(e, "scroll", r ? useThrottleFn$1(x, r, !0, !1) : x, i),
    tryOnMounted$1( () => {
        try {
            const E = toValue(e);
            if (!E)
                return;
            C(E)
        } catch (E) {
            c(E)
        }
    }
    ),
    useEventListener$1(e, "scrollend", v, i),
    {
        x: p,
        y: m,
        isScrolling: _,
        arrivedState: b,
        directions: y,
        measure() {
            const E = toValue(e);
            u && E && C(E)
        }
    }
}
function resolveElement(e) {
    return typeof Window < "u" && e instanceof Window ? e.document.documentElement : typeof Document < "u" && e instanceof Document ? e.documentElement : e
}
function useInfiniteScroll(e, t, r={}) {
    var n;
    const {direction: o="bottom", interval: a=100, canLoadMore: s= () => !0} = r
      , i = reactive(useScroll(e, {
        ...r,
        offset: {
            [o]: (n = r.distance) != null ? n : 0,
            ...r.offset
        }
    }))
      , l = ref()
      , u = computed( () => !!l.value)
      , c = computed( () => resolveElement(toValue(e)))
      , f = useElementVisibility(c);
    function d() {
        if (i.measure(),
        !c.value || !f.value || !s(c.value))
            return;
        const {scrollHeight: p, clientHeight: m, scrollWidth: g, clientWidth: _} = c.value
          , b = o === "bottom" || o === "top" ? p <= m : g <= _;
        (i.arrivedState[o] || b) && (l.value || (l.value = Promise.all([t(i), new Promise(y => setTimeout(y, a))]).finally( () => {
            l.value = null,
            nextTick( () => d())
        }
        )))
    }
    return watch( () => [i.arrivedState[o], f.value], d, {
        immediate: !0
    }),
    {
        isLoading: u
    }
}
function useLocalStorage(e, t, r={}) {
    const {window: n=defaultWindow$1} = r;
    return useStorage(e, t, n == null ? void 0 : n.localStorage, r)
}
function useMemoize(e, t) {
    const n = shallowReactive(new Map)
      , o = (...c) => JSON.stringify(c)
      , a = (c, ...f) => (n.set(c, e(...f)),
    n.get(c))
      , s = (...c) => a(o(...c), ...c)
      , i = (...c) => {
        n.delete(o(...c))
    }
      , l = () => {
        n.clear()
    }
      , u = (...c) => {
        const f = o(...c);
        return n.has(f) ? n.get(f) : a(f, ...c)
    }
    ;
    return u.load = s,
    u.delete = i,
    u.clear = l,
    u.generateKey = o,
    u.cache = n,
    u
}
function useNow(e={}) {
    const {controls: t=!1, interval: r="requestAnimationFrame"} = e
      , n = ref(new Date)
      , o = () => n.value = new Date
      , a = r === "requestAnimationFrame" ? useRafFn(o, {
        immediate: !0
    }) : useIntervalFn(o, r, {
        immediate: !0
    });
    return t ? {
        now: n,
        ...a
    } : n
}
function useScriptTag(e, t=noop$1, r={}) {
    const {immediate: n=!0, manual: o=!1, type: a="text/javascript", async: s=!0, crossOrigin: i, referrerPolicy: l, noModule: u, defer: c, document: f=defaultDocument, attrs: d={}} = r
      , p = ref(null);
    let m = null;
    const g = y => new Promise( (v, S) => {
        const C = I => (p.value = I,
        v(I),
        I);
        if (!f) {
            v(!1);
            return
        }
        let x = !1
          , E = f.querySelector(`script[src="${toValue(e)}"]`);
        E ? E.hasAttribute("data-loaded") && C(E) : (E = f.createElement("script"),
        E.type = a,
        E.async = s,
        E.src = toValue(e),
        c && (E.defer = c),
        i && (E.crossOrigin = i),
        u && (E.noModule = u),
        l && (E.referrerPolicy = l),
        Object.entries(d).forEach( ([I,M]) => E == null ? void 0 : E.setAttribute(I, M)),
        x = !0),
        E.addEventListener("error", I => S(I)),
        E.addEventListener("abort", I => S(I)),
        E.addEventListener("load", () => {
            E.setAttribute("data-loaded", "true"),
            t(E),
            C(E)
        }
        ),
        x && (E = f.head.appendChild(E)),
        y || C(E)
    }
    )
      , _ = (y=!0) => (m || (m = g(y)),
    m)
      , b = () => {
        if (!f)
            return;
        m = null,
        p.value && (p.value = null);
        const y = f.querySelector(`script[src="${toValue(e)}"]`);
        y && f.head.removeChild(y)
    }
    ;
    return n && !o && tryOnMounted$1(_),
    o || tryOnUnmounted(b),
    {
        scriptTag: p,
        load: _,
        unload: b
    }
}
function useSessionStorage(e, t, r={}) {
    const {window: n=defaultWindow$1} = r;
    return useStorage(e, t, n == null ? void 0 : n.sessionStorage, r)
}
function useTimestamp(e={}) {
    const {controls: t=!1, offset: r=0, immediate: n=!0, interval: o="requestAnimationFrame", callback: a} = e
      , s = ref(timestamp() + r)
      , i = () => s.value = timestamp() + r
      , l = a ? () => {
        i(),
        a(s.value)
    }
    : i
      , u = o === "requestAnimationFrame" ? useRafFn(l, {
        immediate: n
    }) : useIntervalFn(l, o, {
        immediate: n
    });
    return t ? {
        timestamp: s,
        ...u
    } : s
}
function useUrlSearchParams(e="history", t={}) {
    const {initialValue: r={}, removeNullishValues: n=!0, removeFalsyValues: o=!1, write: a=!0, window: s=defaultWindow$1} = t;
    if (!s)
        return reactive(r);
    const i = reactive({});
    function l() {
        if (e === "history")
            return s.location.search || "";
        if (e === "hash") {
            const b = s.location.hash || ""
              , y = b.indexOf("?");
            return y > 0 ? b.slice(y) : ""
        } else
            return (s.location.hash || "").replace(/^#/, "")
    }
    function u(b) {
        const y = b.toString();
        if (e === "history")
            return `${y ? `?${y}` : ""}${s.location.hash || ""}`;
        if (e === "hash-params")
            return `${s.location.search || ""}${y ? `#${y}` : ""}`;
        const v = s.location.hash || "#"
          , S = v.indexOf("?");
        return S > 0 ? `${v.slice(0, S)}${y ? `?${y}` : ""}` : `${v}${y ? `?${y}` : ""}`
    }
    function c() {
        return new URLSearchParams(l())
    }
    function f(b) {
        const y = new Set(Object.keys(i));
        for (const v of b.keys()) {
            const S = b.getAll(v);
            i[v] = S.length > 1 ? S : b.get(v) || "",
            y.delete(v)
        }
        Array.from(y).forEach(v => delete i[v])
    }
    const {pause: d, resume: p} = watchPausable(i, () => {
        const b = new URLSearchParams("");
        Object.keys(i).forEach(y => {
            const v = i[y];
            Array.isArray(v) ? v.forEach(S => b.append(y, S)) : n && v == null || o && !v ? b.delete(y) : b.set(y, v)
        }
        ),
        m(b)
    }
    , {
        deep: !0
    });
    function m(b, y) {
        d(),
        y && f(b),
        s.history.replaceState(s.history.state, s.document.title, s.location.pathname + u(b)),
        p()
    }
    function g() {
        a && m(c(), !0)
    }
    useEventListener$1(s, "popstate", g, !1),
    e !== "history" && useEventListener$1(s, "hashchange", g, !1);
    const _ = c();
    return _.keys().next().value ? f(_) : Object.assign(i, r),
    i
}
function useVModel(e, t, r, n={}) {
    var o, a, s;
    const {clone: i=!1, passive: l=!1, eventName: u, deep: c=!1, defaultValue: f, shouldEmit: d} = n
      , p = getCurrentInstance()
      , m = (p == null ? void 0 : p.emit) || ((o = p == null ? void 0 : p.$emit) == null ? void 0 : o.bind(p)) || ((s = (a = p == null ? void 0 : p.proxy) == null ? void 0 : a.$emit) == null ? void 0 : s.bind(p == null ? void 0 : p.proxy));
    let g = u;
    g = g || `update:${t.toString()}`;
    const _ = v => i ? typeof i == "function" ? i(v) : cloneFnJSON(v) : v
      , b = () => isDef(e[t]) ? _(e[t]) : f
      , y = v => {
        d ? d(v) && m(g, v) : m(g, v)
    }
    ;
    if (l) {
        const v = b()
          , S = ref(v);
        let C = !1;
        return watch( () => e[t], x => {
            C || (C = !0,
            S.value = _(x),
            nextTick( () => C = !1))
        }
        ),
        watch(S, x => {
            !C && (x !== e[t] || c) && y(x)
        }
        , {
            deep: c
        }),
        S
    } else
        return computed({
            get() {
                return b()
            },
            set(v) {
                y(v)
            }
        })
}
function useWindowSize(e={}) {
    const {window: t=defaultWindow$1, initialWidth: r=Number.POSITIVE_INFINITY, initialHeight: n=Number.POSITIVE_INFINITY, listenOrientation: o=!0, includeScrollbar: a=!0} = e
      , s = ref(r)
      , i = ref(n)
      , l = () => {
        t && (a ? (s.value = t.innerWidth,
        i.value = t.innerHeight) : (s.value = t.document.documentElement.clientWidth,
        i.value = t.document.documentElement.clientHeight))
    }
    ;
    if (l(),
    tryOnMounted$1(l),
    useEventListener$1("resize", l, {
        passive: !0
    }),
    o) {
        const u = useMediaQuery("(orientation: portrait)");
        watch(u, () => l())
    }
    return {
        width: s,
        height: i
    }
}
const uXpPlusClass = "profit-plus"
  , uXpMinusClass = "profit-minus"
  , uXpPlusBgClass = "profit-bg-plus"
  , uXpMinusBgClass = "profit-bg-minus"
  , uXpDefaultBgClass = "profit-bg-default";
function uXpProfitClass(e) {
    return parseFloat(e) < 0 ? uXpMinusClass : parseFloat(e) > 0 ? uXpPlusClass : ""
}
function uXpProfitBgClass(e) {
    return parseFloat(e) < 0 ? uXpMinusBgClass : parseFloat(e) > 0 ? uXpPlusBgClass : uXpDefaultBgClass
}
function uXpProfitValue(e, t=2, r="--", n=!1) {
    return isNaN$1(parseFloat(e)) ? e || r : `${Number(e).toFixed(t)}${n ? "" : "%"}`
}
function uXpAppleDateExchange(e, t="-") {
    return e.replace(new RegExp(t,"g"), "/")
}
function uXpWorkTime(e, t="年") {
    if (!Array.isArray(e) || !e[0])
        return "--";
    const r = +new Date(uXpAppleDateExchange(e[0]))
      , n = e[1] ? +new Date(uXpAppleDateExchange(e[1])) : +new Date
      , a = (+new Date(n - r) / 1e3 / 3600 / 24 / 365).toFixed(1);
    return a ? a + t : "--"
}
function uXpStatic(e, t="folder") {
    return {
        root: uXpConfig().staticHost,
        folder: uXpConfig().staticFolder,
        img: uXpConfig().staticImgFolder
    }[t] + e
}
function uXpTypeJud(e, t) {
    return Object.prototype.toString.call(e).slice(8, -1).toLowerCase() === t.toLowerCase()
}
function uXpIsEmpty(e, t) {
    return e === void 0 || uXpTypeJud(e, "null") || isNaN$1(e) || t != null && t.includes(e) ? !0 : !Object.keys(e).length
}
function uXpCallBySex(e, t) {
    const r = ["欧阳", "太史", "端木", "上官", "司马", "东方", "独孤", "南宫", "万俟", "闻人", "夏侯", "诸葛", "尉迟", "公羊", "赫连", "澹台", "皇甫", "宗政", "濮阳", "公冶", "太叔", "申屠", "公孙", "慕容", "仲孙", "钟离", "长孙", "宇文", "司徒", "鲜于", "司空", "闾丘", "子车", "亓官", "司寇", "巫马", "公西", "颛孙", "壤驷", "公良", "漆雕", "乐正", "宰父", "谷梁", "拓跋", "夹谷", "轩辕", "令狐", "段干", "百里", "呼延", "东郭", "南门", "羊舌", "微生", "公户", "公玉", "公仪", "梁丘", "公仲", "公上", "公门", "公山", "公坚", "左丘", "公伯", "西门", "公祖", "第五", "公乘", "贯丘", "公皙", "南荣", "东里", "东宫", "仲长", "子书", "子桑", "即墨", "达奚", "褚师", "吴铭"];
    let n = e.slice(0, 2);
    return r.includes(n) || (n = e.slice(0, 1)),
    n + (t !== 2 ? "先生" : "女士")
}
function uXpGreeting() {
    return computed( () => {
        const e = new Date().getHours();
        return e < 5 ? "晚上好" : e < 9 ? "早上好" : e < 12 ? "上午好" : e < 18 ? "下午好" : "晚上好"
    }
    )
}
function uXpCollectType(e) {
    return uXpFundIs(e, "pri") ? 2 : uXpFundIs(e, "pub") ? 11 : uXpThisIdIs(e, "company") ? 4 : uXpThisIdIs(e, "manager") ? 3 : null
}
function dateIsNotNull(e) {
    return !(e != null && e.includes("NaN")) && !!(e && e !== "--" && e !== "认证可见")
}
function formatChineseDate(e) {
    return new Date(e.replace(/[年月]/g, "-").replace("日", ""))
}
function uXpBaiduDateScript(e, t, r, n) {
    const o = i => dateIsNotNull(i) ? formatChineseDate(i).toISOString().split(".")[0] : void 0
      , a = {
        title: e,
        "@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
        "@id": t,
        upDate: void 0,
        pubDate: void 0
    };
    return a.upDate = o(r),
    n && (a.pubDate = o(n)),
    [{
        type: "application/ld+json",
        innerHTML: JSON.stringify(a)
    }]
}
function uXpDateMeta(e, t) {
    return [dateIsNotNull(e) && {
        itemprop: "dateUpdate",
        content: useDateFormat(formatChineseDate(e), "YYYY-MM-DD HH:mm:ss").value
    }, dateIsNotNull(t) && {
        itemprop: "datePublished",
        content: useDateFormat(formatChineseDate(t), "YYYY-MM-DD HH:mm:ss").value
    }].filter(Boolean)
}
function uXpFundIs(e, t) {
    const r = {
        pub: /^MF.{8}/i.test(e),
        pri: /^HF.{8}/i.test(e)
    };
    if (!t) {
        if (r.pub)
            return "pub";
        if (r.pri)
            return "pri";
        throw new Error("[FundIs]id不为产品")
    }
    return r[t]
}
function uXpThisIdIs(e, t) {
    let r = null;
    if (/^CO.{8}/i.test(e) ? r = "company" : /^PL.{8}/i.test(e) ? r = "manager" : /^(HF|MF).{8}/i.test(e) ? r = "fund" : /^PO.{8}/i.test(e) && (r = "comb"),
    t)
        return r === t;
    if (!r)
        throw new Error("[ThisIdIs]id校验失败");
    return r
}
function uXpDomQs(e) {
    return document.querySelector(e)
}
const uXpIsNumber = e => /^(-)?[0-9.]+$/.test(e);
function uXpUrlParamsJoin(e, t) {
    return t ? e + (e.includes("?") ? "&" : "?") + t : e
}
function uXpUrlQueryExchange(e) {
    if (!e)
        return "";
    const t = `?${Object.entries(e).filter(r => r[1] !== void 0).map(r => `${r[0]}=${r[1]}`).join("&")}`;
    return t === "?" ? "" : t
}
function uXpUrlParamsExchange(e, t) {
    return t ? e.replace(/\{(.*)}/g, (r, n) => t[n]) : e
}
function uXpAssetExchange(e, t="元") {
    const r = +e;
    return isNaN$1(r) ? "--" : r < 1e4 ? r + t : r >= 1e4 && r < 1e8 ? +(r / 1e4).toFixed(2) + "万" + t : +(r / 1e8).toFixed(2) + "亿" + t
}
const uXpSeoPriority = {
    DK: 11,
    CANONICAL: 12
}
  , __nuxt_page_meta$b = {
    validate: e => uXpThisIdIs(e.params.id, "company"),
    minPageWidth: "1583px",
    PMRedirectPath: !0,
    disableReport: !0
}
  , __nuxt_page_meta$a = {
    MRedirectPath: !0,
    alias: ["/comparison/index.html"],
    minPageWidth: "1600px"
}
  , __nuxt_page_meta$9 = {
    name: "gsph-condition",
    belong: ["gsph", "index"],
    canonical: !0,
    PMRedirectPath: !0
}
  , __nuxt_page_meta$8 = {
    name: "smph",
    PMRedirectPath: "/smph"
}
  , __nuxt_page_meta$7 = {
    name: "jjpm-condition",
    belong: ["jjpm", "index"],
    PMRedirectPath: "/jjpm"
}
  , __nuxt_page_meta$6 = {
    name: "jlph-condition",
    belong: ["jlph", "index"],
    canonical: !0,
    PMRedirectPath: !0
}
  , __nuxt_page_meta$5 = {
    validate: e => uXpThisIdIs(e.params.id, "manager"),
    minPageWidth: "1583px",
    PMRedirectPath: !0,
    disableReport: !0
}
  , __nuxt_page_meta$4 = {
    name: "marketIndex",
    alias: ["/Index/marketIndex.html", "/Index/marketIndex"],
    PMRedirectPath: "/barometer"
}
  , __nuxt_page_meta$3 = {
    validate: e => uXpThisIdIs(e.params.id, "fund"),
    minPageWidth: "1600px",
    PMRedirectPath: !0,
    disableReport: !0
}
  , __nuxt_page_meta$2 = {
    name: "smph-condition",
    belong: ["smph", "index"],
    PMRedirectPath: !0
}
  , __nuxt_page_meta$1 = {
    name: "zgph-condition",
    belong: ["zgph", "index"],
    redirect: () => ({
        path: "/"
    })
}
  , __nuxt_page_meta = null
  , component_45stubCWCMGOPgF4 = {}
  , _routes = [{
    name: "announce-id",
    path: "/announce/:id()",
    component: () => __vitePreload( () => import("./CdUQ4k_6.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5]), import.meta.url)
}, {
    name: "company-id",
    path: "/company/:id()",
    meta: __nuxt_page_meta$b || {},
    component: () => __vitePreload( () => import("./CU8OBk3R.js"), __vite__mapDeps([6, 7, 8, 2, 3, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1, 4, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66]), import.meta.url)
}, {
    name: "comparison",
    path: "/comparison",
    meta: __nuxt_page_meta$a || {},
    alias: ["/comparison/index.html"],
    component: () => __vitePreload( () => import("./BUdQuuf9.js"), __vite__mapDeps([67, 68, 2, 3, 35, 29, 20, 12, 13, 14, 21, 22, 23, 15, 16, 24, 1, 4, 30, 31, 10, 40, 27, 69, 70, 71, 72, 33, 34, 73, 47, 28, 74]), import.meta.url)
}, {
    name: "gsph-condition",
    path: "/gsph/:area?/:conditionStr?",
    meta: __nuxt_page_meta$9 || {},
    component: () => __vitePreload( () => import("./BfjFKN33.js"), __vite__mapDeps([75, 76, 15, 12, 2, 3, 13, 14, 16, 10, 77, 20, 21, 22, 23, 24, 78, 17, 38, 39, 79, 80, 81, 63, 28, 82, 83, 84, 41, 42, 85, 73, 58, 59, 86, 87, 88]), import.meta.url)
}, {
    name: "smph",
    path: "/",
    meta: __nuxt_page_meta$8 || {},
    component: () => __vitePreload( () => import("./nNW3gU2p.js"), __vite__mapDeps([89, 90, 76, 15, 12, 2, 3, 13, 14, 16, 10, 77, 20, 21, 22, 23, 24, 78, 17, 38, 39, 79, 80, 81, 91, 41, 42, 83, 84, 63, 85, 73, 92, 9, 11, 18, 19, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40, 43, 44, 93, 49, 94, 87, 95, 96]), import.meta.url)
}, {
    name: "jjpm-condition",
    path: "/jjpm/:area?/:conditionStr?",
    meta: __nuxt_page_meta$7 || {},
    component: () => __vitePreload( () => import("./C87toilZ.js"), __vite__mapDeps([97, 76, 15, 12, 2, 3, 13, 14, 16, 10, 77, 20, 21, 22, 23, 24, 78, 17, 38, 39, 79, 80, 81, 91, 41, 42, 83, 84, 63, 85, 73, 92, 9, 11, 18, 19, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40, 43, 44, 93, 49, 94, 87, 95, 98]), import.meta.url)
}, {
    name: "jlph-condition",
    path: "/jlph/:area?/:conditionStr?",
    meta: __nuxt_page_meta$6 || {},
    component: () => __vitePreload( () => import("./Dz_D3GaN.js"), __vite__mapDeps([99, 76, 15, 12, 2, 3, 13, 14, 16, 10, 77, 20, 21, 22, 23, 24, 78, 17, 38, 39, 79, 80, 81, 82, 83, 84, 41, 42, 63, 85, 73, 58, 59, 86, 87, 28, 100]), import.meta.url)
}, {
    name: "manager-id",
    path: "/manager/:id()",
    meta: __nuxt_page_meta$5 || {},
    component: () => __vitePreload( () => import("./JGmMoj3g.js"), __vite__mapDeps([101, 7, 8, 2, 3, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1, 4, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 102, 103]), import.meta.url)
}, {
    name: "marketIndex",
    path: "/marketIndex",
    meta: __nuxt_page_meta$4 || {},
    alias: ["/Index/marketIndex.html", "/Index/marketIndex"],
    component: () => __vitePreload( () => import("./d6IJZqUx.js"), __vite__mapDeps([104, 83, 2, 3, 84, 78, 12, 13, 14, 17, 23, 21, 38, 39, 22, 79, 10, 29, 105, 70, 36, 95, 63, 28, 106]), import.meta.url)
}, {
    name: "product-id",
    path: "/product/:id()",
    meta: __nuxt_page_meta$3 || {},
    component: () => __vitePreload( () => import("./CLit5r1o.js"), __vite__mapDeps([107, 2, 3, 10, 20, 12, 13, 14, 21, 22, 23, 15, 16, 24, 7, 8, 9, 11, 17, 18, 19, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1, 4, 50, 60, 61, 108, 109, 58, 59, 83, 84, 110, 93, 62, 63, 64, 65, 52, 53, 77, 78, 79, 80, 69, 70, 102, 103, 105, 111]), import.meta.url)
}, {
    name: "smph-condition",
    path: "/smph/:area?/:conditionStr?",
    meta: __nuxt_page_meta$2 || {},
    component: () => __vitePreload( () => import("./Ar2nHDFq.js"), __vite__mapDeps([112, 90, 76, 15, 12, 2, 3, 13, 14, 16, 10, 77, 20, 21, 22, 23, 24, 78, 17, 38, 39, 79, 80, 81, 91, 41, 42, 83, 84, 63, 85, 73, 92, 9, 11, 18, 19, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40, 43, 44, 93, 49, 94, 87, 95, 96]), import.meta.url)
}, {
    name: "zgph-condition",
    path: "/zgph/:area?/:conditionStr?",
    meta: __nuxt_page_meta$1 || {},
    redirect: __nuxt_page_meta$1 == null ? void 0 : __nuxt_page_meta$1.redirect,
    component: () => __vitePreload( () => import("./CpzqOiG9.js"), __vite__mapDeps([113, 91, 2, 3, 41, 23, 42, 83, 84, 20, 12, 13, 14, 21, 22, 15, 16, 24, 10, 78, 17, 38, 39, 79, 77, 80, 63, 85, 73, 92, 9, 11, 18, 19, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40, 43, 44, 93, 49, 94, 87, 95, 114]), import.meta.url)
}, {
    name: __nuxt_page_meta == null ? void 0 : __nuxt_page_meta.name,
    path: "/manager",
    component: component_45stubCWCMGOPgF4
}]
  , _wrapIf = (e, t, r) => (t = t === !0 ? {} : t,
{
    default: () => {
        var n;
        return t ? h(e, t, r) : (n = r.default) == null ? void 0 : n.call(r)
    }
});
function generateRouteKey(e) {
    const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, r => {
        var n;
        return ((n = e.params[r.slice(1)]) == null ? void 0 : n.toString()) || ""
    }
    );
    return typeof t == "function" ? t(e) : t
}
function isChangingPage(e, t) {
    return e === t || t === START_LOCATION_NORMALIZED ? !1 : generateRouteKey(e) !== generateRouteKey(t) ? !0 : !e.matched.every( (n, o) => {
        var a, s;
        return n.components && n.components.default === ((s = (a = t.matched[o]) == null ? void 0 : a.components) == null ? void 0 : s.default)
    }
    )
}
function getFragmentHTML(e, t=!1) {
    if (e) {
        if (e.nodeName === "#comment" && e.nodeValue === "[")
            return getFragmentChildren(e, [], t);
        if (t) {
            const r = e.cloneNode(!0);
            return r.querySelectorAll("[data-island-slot]").forEach(n => {
                n.innerHTML = ""
            }
            ),
            [r.outerHTML]
        }
        return [e.outerHTML]
    }
    return null
}
function getFragmentChildren(e, t=[], r=!1) {
    if (e && e.nodeName) {
        if (isEndFragment(e))
            return t;
        if (!isStartFragment(e)) {
            const n = e.cloneNode(!0);
            r && n.querySelectorAll("[data-island-slot]").forEach(o => {
                o.innerHTML = ""
            }
            ),
            t.push(n.outerHTML)
        }
        getFragmentChildren(e.nextSibling, t, r)
    }
    return t
}
function isStartFragment(e) {
    return e.nodeName === "#comment" && e.nodeValue === "["
}
function isEndFragment(e) {
    return e.nodeName === "#comment" && e.nodeValue === "]"
}
const routerOptions0 = {
    scrollBehavior(e, t, r) {
        var u;
        const n = useNuxtApp()
          , o = ((u = useRouter().options) == null ? void 0 : u.scrollBehaviorType) ?? "auto";
        let a = r || void 0;
        const s = typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop;
        if (!a && t && e && s !== !1 && isChangingPage(e, t) && (a = {
            left: 0,
            top: 0
        }),
        e.path === t.path)
            return t.hash && !e.hash ? {
                left: 0,
                top: 0
            } : e.hash ? {
                el: e.hash,
                top: _getHashElementScrollMarginTop(e.hash),
                behavior: o
            } : !1;
        const i = c => !!(c.meta.pageTransition ?? appPageTransition)
          , l = i(t) && i(e) ? "page:transition:finish" : "page:finish";
        return new Promise(c => {
            n.hooks.hookOnce(l, async () => {
                await new Promise(f => setTimeout(f, 0)),
                e.hash && (a = {
                    el: e.hash,
                    top: _getHashElementScrollMarginTop(e.hash),
                    behavior: o
                }),
                c(a)
            }
            )
        }
        )
    }
};
function _getHashElementScrollMarginTop(e) {
    try {
        const t = document.querySelector(e);
        if (t)
            return (Number.parseFloat(getComputedStyle(t).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0)
    } catch {}
    return 0
}
function recursiveHandler(e) {
    return e.forEach(t => {
        t.children && recursiveHandler(t.children),
        t.alias || (t.alias = []),
        Array.isArray(t.alias) ? t.alias = [...t.alias, t.path + ".html"] : t.alias = [t.alias, t.path + ".html"]
    }
    ),
    e
}
function htmlSuffixHandler(e) {
    const t = cloneDeep(e);
    return recursiveHandler(t)
}
const routerOptions1 = {
    routes: e => htmlSuffixHandler(e),
    scrollBehavior(e, t, r) {
        return r || {
            top: 0
        }
    }
}
  , configRouterOptions = {
    hashMode: !1,
    scrollBehaviorType: "auto"
}
  , routerOptions = {
    ...configRouterOptions,
    ...routerOptions0,
    ...routerOptions1
}
  , validate = async e => {
    var l;
    let t, r;
    if (!((l = e.meta) != null && l.validate))
        return;
    const n = useNuxtApp()
      , o = useRouter()
      , a = ([t,r] = executeAsync( () => Promise.resolve(e.meta.validate(e))),
    t = await t,
    r(),
    t);
    if (a === !0)
        return;
    const s = createError({
        statusCode: a && a.statusCode || 404,
        statusMessage: a && a.statusMessage || `Page Not Found: ${e.fullPath}`,
        data: {
            path: e.fullPath
        }
    })
      , i = o.beforeResolve(u => {
        if (i(),
        u === e) {
            const c = o.afterEach(async () => {
                c(),
                await n.runWithContext( () => showError(s)),
                window == null || window.history.pushState({}, "", e.fullPath)
            }
            );
            return !1
        }
    }
    )
}
  , manifest_45route_45rule = async e => {
    let t, r;
    const n = ([t,r] = executeAsync( () => getRouteRules(e.path)),
    t = await t,
    r(),
    t);
    if (n.redirect)
        return hasProtocol(n.redirect, {
            acceptRelative: !0
        }) ? (window.location.href = n.redirect,
        !1) : n.redirect
}
  , globalMiddleware = [validate, manifest_45route_45rule]
  , namedMiddleware = {};
function createCurrentLocation(e, t, r) {
    const {pathname: n, search: o, hash: a} = t
      , s = e.indexOf("#");
    if (s > -1) {
        const u = a.includes(e.slice(s)) ? e.slice(s).length : 1;
        let c = a.slice(u);
        return c[0] !== "/" && (c = "/" + c),
        withoutBase(c, "")
    }
    const i = withoutBase(n, e)
      , l = !r || isEqual$1(i, r, {
        trailingSlash: !0
    }) ? i : r;
    return l + (l.includes("?") ? "" : o) + a
}
const plugin$1 = defineNuxtPlugin({
    name: "nuxt:router",
    enforce: "pre",
    async setup(e) {
        var _;
        let t, r, n = useRuntimeConfig().app.baseURL;
        routerOptions.hashMode && !n.includes("#") && (n += "#");
        const o = ((_ = routerOptions.history) == null ? void 0 : _.call(routerOptions, n)) ?? (routerOptions.hashMode ? createWebHashHistory(n) : createWebHistory(n))
          , a = routerOptions.routes ? ([t,r] = executeAsync( () => routerOptions.routes(_routes)),
        t = await t,
        r(),
        t ?? _routes) : _routes;
        let s;
        const i = createRouter({
            ...routerOptions,
            scrollBehavior: (b, y, v) => {
                if (y === START_LOCATION_NORMALIZED) {
                    s = v;
                    return
                }
                if (routerOptions.scrollBehavior) {
                    if (i.options.scrollBehavior = routerOptions.scrollBehavior,
                    "scrollRestoration"in window.history) {
                        const S = i.beforeEach( () => {
                            S(),
                            window.history.scrollRestoration = "manual"
                        }
                        )
                    }
                    return routerOptions.scrollBehavior(b, START_LOCATION_NORMALIZED, s || v)
                }
            }
            ,
            history: o,
            routes: a
        });
        "scrollRestoration"in window.history && (window.history.scrollRestoration = "auto"),
        e.vueApp.use(i);
        const l = shallowRef(i.currentRoute.value);
        i.afterEach( (b, y) => {
            l.value = y
        }
        ),
        Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
            get: () => l.value
        });
        const u = createCurrentLocation(n, window.location, e.payload.path)
          , c = shallowRef(i.currentRoute.value)
          , f = () => {
            c.value = i.currentRoute.value
        }
        ;
        e.hook("page:finish", f),
        i.afterEach( (b, y) => {
            var v, S, C, x;
            ((S = (v = b.matched[0]) == null ? void 0 : v.components) == null ? void 0 : S.default) === ((x = (C = y.matched[0]) == null ? void 0 : C.components) == null ? void 0 : x.default) && f()
        }
        );
        const d = {};
        for (const b in c.value)
            Object.defineProperty(d, b, {
                get: () => c.value[b],
                enumerable: !0
            });
        e._route = shallowReactive(d),
        e._middleware = e._middleware || {
            global: [],
            named: {}
        };
        const p = useError();
        i.afterEach(async (b, y, v) => {
            delete e._processingMiddleware,
            !e.isHydrating && p.value && await e.runWithContext(clearError),
            v && await e.callHook("page:loading:end"),
            b.matched.length === 0 && await e.runWithContext( () => showError(createError$1({
                statusCode: 404,
                fatal: !1,
                statusMessage: `Page not found: ${b.fullPath}`,
                data: {
                    path: b.fullPath
                }
            })))
        }
        );
        try {
            [t,r] = executeAsync( () => i.isReady()),
            await t,
            r()
        } catch (b) {
            [t,r] = executeAsync( () => e.runWithContext( () => showError(b))),
            await t,
            r()
        }
        const m = u !== i.currentRoute.value.fullPath ? i.resolve(u) : i.currentRoute.value;
        f();
        const g = e.payload.state._layout;
        return i.beforeEach(async (b, y) => {
            var v;
            await e.callHook("page:loading:start"),
            b.meta = reactive(b.meta),
            e.isHydrating && g && !isReadonly(b.meta.layout) && (b.meta.layout = g),
            e._processingMiddleware = !0;
            {
                const S = new Set([...globalMiddleware, ...e._middleware.global]);
                for (const C of b.matched) {
                    const x = C.meta.middleware;
                    if (x)
                        for (const E of toArray(x))
                            S.add(E)
                }
                {
                    const C = await e.runWithContext( () => getRouteRules(b.path));
                    if (C.appMiddleware)
                        for (const x in C.appMiddleware)
                            C.appMiddleware[x] ? S.add(x) : S.delete(x)
                }
                for (const C of S) {
                    const x = typeof C == "string" ? e._middleware.named[C] || await ((v = namedMiddleware[C]) == null ? void 0 : v.call(namedMiddleware).then(I => I.default || I)) : C;
                    if (!x)
                        throw new Error(`Unknown route middleware: '${C}'.`);
                    const E = await e.runWithContext( () => x(b, y));
                    if (!e.payload.serverRendered && e.isHydrating && (E === !1 || E instanceof Error)) {
                        const I = E || createError$1({
                            statusCode: 404,
                            statusMessage: `Page Not Found: ${u}`
                        });
                        return await e.runWithContext( () => showError(I)),
                        !1
                    }
                    if (E !== !0 && (E || E === !1))
                        return E
                }
            }
        }
        ),
        i.onError(async () => {
            delete e._processingMiddleware,
            await e.callHook("page:loading:end")
        }
        ),
        e.hooks.hookOnce("app:created", async () => {
            try {
                "name"in m && (m.name = void 0),
                await i.replace({
                    ...m,
                    force: !0
                }),
                i.options.scrollBehavior = routerOptions.scrollBehavior
            } catch (b) {
                await e.runWithContext( () => showError(b))
            }
        }
        ),
        {
            provide: {
                router: i
            }
        }
    }
})
  , requestIdleCallback = globalThis.requestIdleCallback || (e => {
    const t = Date.now()
      , r = {
        didTimeout: !1,
        timeRemaining: () => Math.max(0, 50 - (Date.now() - t))
    };
    return setTimeout( () => {
        e(r)
    }
    , 1)
}
)
  , cancelIdleCallback = globalThis.cancelIdleCallback || (e => {
    clearTimeout(e)
}
)
  , onNuxtReady = e => {
    const t = useNuxtApp();
    t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => {
        requestIdleCallback( () => e())
    }
    ) : requestIdleCallback( () => e())
}
  , payload_client_lPSv2tCcmY = defineNuxtPlugin({
    name: "nuxt:payload",
    setup(e) {
        useRouter().beforeResolve(async (t, r) => {
            if (t.path === r.path)
                return;
            const n = await loadPayload(t.path);
            n && Object.assign(e.static.data, n.data)
        }
        ),
        onNuxtReady( () => {
            var t;
            e.hooks.hook("link:prefetch", async r => {
                const {hostname: n} = new URL(r,window.location.href);
                n === window.location.hostname && await loadPayload(r)
            }
            ),
            ((t = navigator.connection) == null ? void 0 : t.effectiveType) !== "slow-2g" && setTimeout(getAppManifest, 1e3)
        }
        )
    }
})
  , navigation_repaint_client_h7iwmAtPle = defineNuxtPlugin( () => {
    const e = useRouter();
    onNuxtReady( () => {
        e.beforeResolve(async () => {
            await new Promise(t => {
                setTimeout(t, 100),
                requestAnimationFrame( () => {
                    setTimeout(t, 0)
                }
                )
            }
            )
        }
        )
    }
    )
}
)
  , check_outdated_build_client_uUlFLFLDzj = defineNuxtPlugin(e => {
    let t;
    async function r() {
        const n = await getAppManifest();
        t && clearTimeout(t),
        t = setTimeout(r, outdatedBuildInterval);
        try {
            const o = await $fetch(buildAssetsURL("builds/latest.json") + `?${Date.now()}`);
            o.id !== n.id && e.hooks.callHook("app:manifest:update", o)
        } catch {}
    }
    onNuxtReady( () => {
        t = setTimeout(r, outdatedBuildInterval)
    }
    )
}
);
function reloadNuxtApp(e={}) {
    const t = e.path || window.location.pathname;
    let r = {};
    try {
        r = destr(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (r == null ? void 0 : r.path) !== t || (r == null ? void 0 : r.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ?? 1e4)
            }))
        } catch {}
        if (e.persistState)
            try {
                sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                    state: useNuxtApp().payload.state
                }))
            } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const chunk_reload_client_v4j2JHeOxa = defineNuxtPlugin({
    name: "nuxt:chunk-reload",
    setup(e) {
        const t = useRouter()
          , r = useRuntimeConfig()
          , n = new Set;
        t.beforeEach( () => {
            n.clear()
        }
        ),
        e.hook("app:chunkError", ({error: a}) => {
            n.add(a)
        }
        );
        function o(a) {
            const i = "href"in a && a.href[0] === "#" ? r.app.baseURL + a.href : joinURL(r.app.baseURL, a.fullPath);
            reloadNuxtApp({
                path: i,
                persistState: !0
            })
        }
        e.hook("app:manifest:update", () => {
            t.beforeResolve(o)
        }
        ),
        t.onError( (a, s) => {
            n.has(a) && o(s)
        }
        )
    }
})
  , useStateKeyPrefix = "$s";
function useState(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [r,n] = e;
    if (!r || typeof r != "string")
        throw new TypeError("[nuxt] [useState] key must be a string: " + r);
    if (n !== void 0 && typeof n != "function")
        throw new Error("[nuxt] [useState] init must be a function: " + n);
    const o = useStateKeyPrefix + r
      , a = useNuxtApp()
      , s = toRef(a.payload.state, o);
    if (s.value === void 0 && n) {
        const i = n();
        if (isRef(i))
            return a.payload.state[o] = i,
            i;
        s.value = i
    }
    return s
}
function klona(e) {
    if (typeof e != "object")
        return e;
    var t, r, n = Object.prototype.toString.call(e);
    if (n === "[object Object]") {
        if (e.constructor !== Object && typeof e.constructor == "function") {
            r = new e.constructor;
            for (t in e)
                e.hasOwnProperty(t) && r[t] !== e[t] && (r[t] = klona(e[t]))
        } else {
            r = {};
            for (t in e)
                t === "__proto__" ? Object.defineProperty(r, t, {
                    value: klona(e[t]),
                    configurable: !0,
                    enumerable: !0,
                    writable: !0
                }) : r[t] = klona(e[t])
        }
        return r
    }
    if (n === "[object Array]") {
        for (t = e.length,
        r = Array(t); t--; )
            r[t] = klona(e[t]);
        return r
    }
    return n === "[object Set]" ? (r = new Set,
    e.forEach(function(o) {
        r.add(klona(o))
    }),
    r) : n === "[object Map]" ? (r = new Map,
    e.forEach(function(o, a) {
        r.set(klona(a), klona(o))
    }),
    r) : n === "[object Date]" ? new Date(+e) : n === "[object RegExp]" ? (r = new RegExp(e.source,e.flags),
    r.lastIndex = e.lastIndex,
    r) : n === "[object DataView]" ? new e.constructor(klona(e.buffer)) : n === "[object ArrayBuffer]" ? e.slice(0) : n.slice(-6) === "Array]" ? new e.constructor(e) : e
}
const CookieDefaults = {
    path: "/",
    watch: !0,
    decode: e => destr(decodeURIComponent(e)),
    encode: e => encodeURIComponent(typeof e == "string" ? e : JSON.stringify(e))
}
  , store = window.cookieStore;
function useCookie(e, t) {
    var l;
    const r = {
        ...CookieDefaults,
        ...t
    };
    r.filter ?? (r.filter = u => u === e);
    const n = readRawCookies(r) || {};
    let o;
    r.maxAge !== void 0 ? o = r.maxAge * 1e3 : r.expires && (o = r.expires.getTime() - Date.now());
    const a = o !== void 0 && o <= 0
      , s = klona(a ? void 0 : n[e] ?? ((l = r.default) == null ? void 0 : l.call(r)))
      , i = o && !a ? cookieRef(s, o, r.watch && r.watch !== "shallow") : ref(s);
    {
        let u = null;
        try {
            !store && typeof BroadcastChannel < "u" && (u = new BroadcastChannel(`nuxt:cookies:${e}`))
        } catch {}
        const c = () => {
            r.readonly || isEqual(i.value, n[e]) || (writeClientCookie(e, i.value, r),
            n[e] = klona(i.value),
            u == null || u.postMessage({
                value: r.encode(i.value)
            }))
        }
          , f = m => {
            var _;
            const g = m.refresh ? (_ = readRawCookies(r)) == null ? void 0 : _[e] : r.decode(m.value);
            d = !0,
            i.value = g,
            n[e] = klona(g),
            nextTick( () => {
                d = !1
            }
            )
        }
        ;
        let d = !1;
        const p = !!getCurrentScope();
        if (p && onScopeDispose( () => {
            d = !0,
            c(),
            u == null || u.close()
        }
        ),
        store) {
            const m = g => {
                const _ = g.changed.find(y => y.name === e)
                  , b = g.deleted.find(y => y.name === e);
                _ && f({
                    value: _.value
                }),
                b && f({
                    value: null
                })
            }
            ;
            store.addEventListener("change", m),
            p && onScopeDispose( () => store.removeEventListener("change", m))
        } else
            u && (u.onmessage = ({data: m}) => f(m));
        r.watch ? watch(i, () => {
            d || c()
        }
        , {
            deep: r.watch !== "shallow"
        }) : c()
    }
    return i
}
function readRawCookies(e={}) {
    return parse$3(document.cookie, e)
}
function serializeCookie(e, t, r={}) {
    return t == null ? serialize(e, t, {
        ...r,
        maxAge: -1
    }) : serialize(e, t, r)
}
function writeClientCookie(e, t, r={}) {
    document.cookie = serializeCookie(e, t, r)
}
const MAX_TIMEOUT_DELAY = 2147483647;
function cookieRef(e, t, r) {
    let n, o, a = 0;
    const s = r ? ref(e) : {
        value: e
    };
    return getCurrentScope() && onScopeDispose( () => {
        o == null || o(),
        clearTimeout(n)
    }
    ),
    customRef( (i, l) => {
        r && (o = watch(s, l));
        function u() {
            a = 0,
            clearTimeout(n);
            const c = t - a
              , f = c < MAX_TIMEOUT_DELAY ? c : MAX_TIMEOUT_DELAY;
            n = setTimeout( () => {
                if (a += f,
                a < t)
                    return u();
                s.value = void 0,
                l()
            }
            , f)
        }
        return {
            get() {
                return i(),
                s.value
            },
            set(c) {
                u(),
                s.value = c,
                l()
            }
        }
    }
    )
}
async function preloadRouteComponents(e, t=useRouter()) {
    const {path: r, matched: n} = t.resolve(e);
    if (!n.length || (t._routePreloaded || (t._routePreloaded = new Set),
    t._routePreloaded.has(r)))
        return;
    const o = t._preloadPromises = t._preloadPromises || [];
    if (o.length > 4)
        return Promise.all(o).then( () => preloadRouteComponents(e, t));
    t._routePreloaded.add(r);
    const a = n.map(s => {
        var i;
        return (i = s.components) == null ? void 0 : i.default
    }
    ).filter(s => typeof s == "function");
    for (const s of a) {
        const i = Promise.resolve(s()).catch( () => {}
        ).finally( () => o.splice(o.indexOf(i)));
        o.push(i)
    }
    await Promise.all(o)
}
const firstNonUndefined = (...e) => e.find(t => t !== void 0);
function defineNuxtLink(e) {
    const t = e.componentName || "NuxtLink";
    function r(o, a) {
        if (!o || e.trailingSlash !== "append" && e.trailingSlash !== "remove")
            return o;
        if (typeof o == "string")
            return applyTrailingSlashBehavior(o, e.trailingSlash);
        const s = "path"in o && o.path !== void 0 ? o.path : a(o).path;
        return {
            ...o,
            name: void 0,
            path: applyTrailingSlashBehavior(s, e.trailingSlash)
        }
    }
    function n(o) {
        const a = useRouter()
          , s = useRuntimeConfig()
          , i = computed( () => !!o.target && o.target !== "_self")
          , l = computed( () => {
            const g = o.to || o.href || "";
            return typeof g == "string" && hasProtocol(g, {
                acceptRelative: !0
            })
        }
        )
          , u = resolveComponent("RouterLink")
          , c = u && typeof u != "string" ? u.useLink : void 0
          , f = computed( () => {
            if (o.external)
                return !0;
            const g = o.to || o.href || "";
            return typeof g == "object" ? !1 : g === "" || l.value
        }
        )
          , d = computed( () => {
            const g = o.to || o.href || "";
            return f.value ? g : r(g, a.resolve)
        }
        )
          , p = f.value || c == null ? void 0 : c({
            ...o,
            to: d
        })
          , m = computed( () => {
            var g;
            if (!d.value || l.value)
                return d.value;
            if (f.value) {
                const _ = typeof d.value == "object" && "path"in d.value ? resolveRouteObject(d.value) : d.value
                  , b = typeof _ == "object" ? a.resolve(_).href : _;
                return r(b, a.resolve)
            }
            return typeof d.value == "object" ? ((g = a.resolve(d.value)) == null ? void 0 : g.href) ?? null : r(joinURL(s.app.baseURL, d.value), a.resolve)
        }
        );
        return {
            to: d,
            hasTarget: i,
            isAbsoluteUrl: l,
            isExternal: f,
            href: m,
            isActive: (p == null ? void 0 : p.isActive) ?? computed( () => d.value === a.currentRoute.value.path),
            isExactActive: (p == null ? void 0 : p.isExactActive) ?? computed( () => d.value === a.currentRoute.value.path),
            route: (p == null ? void 0 : p.route) ?? computed( () => a.resolve(d.value)),
            async navigate() {
                await navigateTo(m.value, {
                    replace: o.replace,
                    external: f.value || i.value
                })
            }
        }
    }
    return defineComponent({
        name: t,
        props: {
            to: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            href: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            target: {
                type: String,
                default: void 0,
                required: !1
            },
            rel: {
                type: String,
                default: void 0,
                required: !1
            },
            noRel: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetchOn: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            noPrefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            activeClass: {
                type: String,
                default: void 0,
                required: !1
            },
            exactActiveClass: {
                type: String,
                default: void 0,
                required: !1
            },
            prefetchedClass: {
                type: String,
                default: void 0,
                required: !1
            },
            replace: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            ariaCurrentValue: {
                type: String,
                default: void 0,
                required: !1
            },
            external: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            custom: {
                type: Boolean,
                default: void 0,
                required: !1
            }
        },
        useLink: n,
        setup(o, {slots: a}) {
            const s = useRouter()
              , {to: i, href: l, navigate: u, isExternal: c, hasTarget: f, isAbsoluteUrl: d} = n(o)
              , p = ref(!1)
              , m = ref(null)
              , g = y => {
                var v;
                m.value = o.custom ? (v = y == null ? void 0 : y.$el) == null ? void 0 : v.nextElementSibling : y == null ? void 0 : y.$el
            }
            ;
            function _(y) {
                var v, S;
                return !p.value && (typeof o.prefetchOn == "string" ? o.prefetchOn === y : ((v = o.prefetchOn) == null ? void 0 : v[y]) ?? ((S = e.prefetchOn) == null ? void 0 : S[y])) && (o.prefetch ?? e.prefetch) !== !1 && o.noPrefetch !== !0 && o.target !== "_blank" && !isSlowConnection()
            }
            async function b(y=useNuxtApp()) {
                if (p.value)
                    return;
                p.value = !0;
                const v = typeof i.value == "string" ? i.value : c.value ? resolveRouteObject(i.value) : s.resolve(i.value).fullPath;
                await Promise.all([y.hooks.callHook("link:prefetch", v).catch( () => {}
                ), !c.value && !f.value && preloadRouteComponents(i.value, s).catch( () => {}
                )])
            }
            if (_("visibility")) {
                const y = useNuxtApp();
                let v, S = null;
                onMounted( () => {
                    const C = useObserver();
                    onNuxtReady( () => {
                        v = requestIdleCallback( () => {
                            var x;
                            (x = m == null ? void 0 : m.value) != null && x.tagName && (S = C.observe(m.value, async () => {
                                S == null || S(),
                                S = null,
                                await b(y)
                            }
                            ))
                        }
                        )
                    }
                    )
                }
                ),
                onBeforeUnmount( () => {
                    v && cancelIdleCallback(v),
                    S == null || S(),
                    S = null
                }
                )
            }
            return () => {
                var S;
                if (!c.value && !f.value) {
                    const C = {
                        ref: g,
                        to: i.value,
                        activeClass: o.activeClass || e.activeClass,
                        exactActiveClass: o.exactActiveClass || e.exactActiveClass,
                        replace: o.replace,
                        ariaCurrentValue: o.ariaCurrentValue,
                        custom: o.custom
                    };
                    return o.custom || (_("interaction") && (C.onPointerenter = b.bind(null, void 0),
                    C.onFocus = b.bind(null, void 0)),
                    p.value && (C.class = o.prefetchedClass || e.prefetchedClass),
                    C.rel = o.rel || void 0),
                    h(resolveComponent("RouterLink"), C, a.default)
                }
                const y = o.target || null
                  , v = firstNonUndefined(o.noRel ? "" : o.rel, e.externalRelAttribute, d.value || f.value ? "noopener noreferrer" : "") || null;
                return o.custom ? a.default ? a.default({
                    href: l.value,
                    navigate: u,
                    prefetch: b,
                    get route() {
                        if (!l.value)
                            return;
                        const C = new URL(l.value,window.location.href);
                        return {
                            path: C.pathname,
                            fullPath: C.pathname,
                            get query() {
                                return parseQuery$1(C.search)
                            },
                            hash: C.hash,
                            params: {},
                            name: void 0,
                            matched: [],
                            redirectedFrom: void 0,
                            meta: {},
                            href: l.value
                        }
                    },
                    rel: v,
                    target: y,
                    isExternal: c.value || f.value,
                    isActive: !1,
                    isExactActive: !1
                }) : null : h("a", {
                    ref: m,
                    href: l.value || null,
                    rel: v,
                    target: y
                }, (S = a.default) == null ? void 0 : S.call(a))
            }
        }
    })
}
const __nuxt_component_5 = defineNuxtLink(nuxtLinkDefaults);
function applyTrailingSlashBehavior(e, t) {
    const r = t === "append" ? withTrailingSlash : withoutTrailingSlash;
    return hasProtocol(e) && !e.startsWith("http") ? e : r(e, !0)
}
function useObserver() {
    const e = useNuxtApp();
    if (e._observer)
        return e._observer;
    let t = null;
    const r = new Map
      , n = (a, s) => (t || (t = new IntersectionObserver(i => {
        for (const l of i) {
            const u = r.get(l.target);
            (l.isIntersecting || l.intersectionRatio > 0) && u && u()
        }
    }
    )),
    r.set(a, s),
    t.observe(a),
    () => {
        r.delete(a),
        t.unobserve(a),
        r.size === 0 && (t.disconnect(),
        t = null)
    }
    );
    return e._observer = {
        observe: n
    }
}
function isSlowConnection() {
    const e = navigator.connection;
    return !!(e && (e.saveData || /2g/.test(e.effectiveType)))
}
const plugin = defineNuxtPlugin({
    name: "pinia",
    setup(e) {
        const t = createPinia();
        return e.vueApp.use(t),
        setActivePinia(t),
        e.payload && e.payload.pinia && (t.state.value = e.payload.pinia),
        {
            provide: {
                pinia: t
            }
        }
    }
})
  , LazySvgoClean = defineAsyncComponent( () => __vitePreload( () => import("./BH67grfC.js"), __vite__mapDeps([68, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoDateIcon = defineAsyncComponent( () => __vitePreload( () => import("./CQrvD4o0.js"), __vite__mapDeps([115, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoPdf = defineAsyncComponent( () => __vitePreload( () => import("./CXHl9Kcr.js"), __vite__mapDeps([116, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoProductBlueCall = defineAsyncComponent( () => __vitePreload( () => import("./DTAjFpME.js"), __vite__mapDeps([53, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoProductChartInvisible = defineAsyncComponent( () => __vitePreload( () => import("./DILW8-Rj.js"), __vite__mapDeps([117, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoProductRedCall = defineAsyncComponent( () => __vitePreload( () => import("./lq4bXooV.js"), __vite__mapDeps([52, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoProductWxCallWhite = defineAsyncComponent( () => __vitePreload( () => import("./BJqo8wzm.js"), __vite__mapDeps([54, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoProductWxCall = defineAsyncComponent( () => __vitePreload( () => import("./C8kL_wtD.js"), __vite__mapDeps([8, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , LazySvgoWatermarkPpw = defineAsyncComponent( () => __vitePreload( () => import("./DuAS-52M.js"), __vite__mapDeps([118, 2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , lazyGlobalComponents = [["SvgoClean", LazySvgoClean], ["SvgoDateIcon", LazySvgoDateIcon], ["SvgoPdf", LazySvgoPdf], ["SvgoProductBlueCall", LazySvgoProductBlueCall], ["SvgoProductChartInvisible", LazySvgoProductChartInvisible], ["SvgoProductRedCall", LazySvgoProductRedCall], ["SvgoProductWxCallWhite", LazySvgoProductWxCallWhite], ["SvgoProductWxCall", LazySvgoProductWxCall], ["SvgoWatermarkPpw", LazySvgoWatermarkPpw]]
  , components_plugin_KR1HBZs4kY = defineNuxtPlugin({
    name: "nuxt:global-components",
    setup(e) {
        for (const [t,r] of lazyGlobalComponents)
            e.vueApp.component(t, r),
            e.vueApp.component("Lazy" + t, r)
    }
})
  , layouts = {
    default: () => __vitePreload( () => import("./CSM9R8yG.js"), __vite__mapDeps([119, 2, 3, 60, 40, 61, 10, 1, 4, 48, 11, 26, 27, 63, 72, 45, 46, 110, 71, 120, 15, 12, 13, 14, 16, 25, 121]), import.meta.url)
}
  , prefetch_client_i4jq2g8RpK = defineNuxtPlugin({
    name: "nuxt:prefetch",
    setup(e) {
        const t = useRouter();
        e.hooks.hook("app:mounted", () => {
            t.beforeEach(async r => {
                var o;
                const n = (o = r == null ? void 0 : r.meta) == null ? void 0 : o.layout;
                n && typeof layouts[n] == "function" && await layouts[n]()
            }
            )
        }
        ),
        e.hooks.hook("link:prefetch", r => {
            if (hasProtocol(r))
                return;
            const n = t.resolve(r);
            if (!n)
                return;
            const o = n.meta.layout;
            let a = toArray(n.meta.middleware);
            a = a.filter(s => typeof s == "string");
            for (const s of a)
                typeof namedMiddleware[s] == "function" && namedMiddleware[s]();
            o && typeof layouts[o] == "function" && layouts[o]()
        }
        )
    }
})
  , element_plus_teleports_plugin_h4Dmekbj62 = defineNuxtPlugin(e => {
    e.hook("app:rendered", t => {
        var r;
        (r = t.ssrContext) != null && r.teleports && (t.ssrContext.teleports = renderTeleports(t.ssrContext.teleports))
    }
    )
}
);
function renderTeleports(e) {
    const t = Object.entries(e).reduce( (r, [n,o]) => n.startsWith("#el-popper-container-") || [].includes(n) ? `${r}<div id="${n.slice(1)}">${o}</div>` : r, e.body || "");
    return {
        ...e,
        body: t
    }
}
var __defProp$9 = Object.defineProperty
  , __defProps$6 = Object.defineProperties
  , __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$b = Object.getOwnPropertySymbols
  , __hasOwnProp$b = Object.prototype.hasOwnProperty
  , __propIsEnum$b = Object.prototype.propertyIsEnumerable
  , __defNormalProp$9 = (e, t, r) => t in e ? __defProp$9(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , __spreadValues$9 = (e, t) => {
    for (var r in t || (t = {}))
        __hasOwnProp$b.call(t, r) && __defNormalProp$9(e, r, t[r]);
    if (__getOwnPropSymbols$b)
        for (var r of __getOwnPropSymbols$b(t))
            __propIsEnum$b.call(t, r) && __defNormalProp$9(e, r, t[r]);
    return e
}
  , __spreadProps$6 = (e, t) => __defProps$6(e, __getOwnPropDescs$6(t));
function computedEager(e, t) {
    var r;
    const n = shallowRef();
    return watchEffect( () => {
        n.value = e()
    }
    , __spreadProps$6(__spreadValues$9({}, t), {
        flush: (r = void 0) != null ? r : "sync"
    })),
    readonly(n)
}
var _a;
const isClient = typeof window < "u"
  , isString$2 = e => typeof e == "string"
  , noop = () => {}
  , isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(e) {
    return typeof e == "function" ? e() : unref(e)
}
function createFilterWrapper(e, t) {
    function r(...n) {
        return new Promise( (o, a) => {
            Promise.resolve(e( () => t.apply(this, n), {
                fn: t,
                thisArg: this,
                args: n
            })).then(o).catch(a)
        }
        )
    }
    return r
}
function debounceFilter(e, t={}) {
    let r, n, o = noop;
    const a = i => {
        clearTimeout(i),
        o(),
        o = noop
    }
    ;
    return i => {
        const l = resolveUnref(e)
          , u = resolveUnref(t.maxWait);
        return r && a(r),
        l <= 0 || u !== void 0 && u <= 0 ? (n && (a(n),
        n = null),
        Promise.resolve(i())) : new Promise( (c, f) => {
            o = t.rejectOnCancel ? f : c,
            u && !n && (n = setTimeout( () => {
                r && a(r),
                n = null,
                c(i())
            }
            , u)),
            r = setTimeout( () => {
                n && a(n),
                n = null,
                c(i())
            }
            , l)
        }
        )
    }
}
function throttleFilter(e, t=!0, r=!0, n=!1) {
    let o = 0, a, s = !0, i = noop, l;
    const u = () => {
        a && (clearTimeout(a),
        a = void 0,
        i(),
        i = noop)
    }
    ;
    return f => {
        const d = resolveUnref(e)
          , p = Date.now() - o
          , m = () => l = f();
        return u(),
        d <= 0 ? (o = Date.now(),
        m()) : (p > d && (r || !s) ? (o = Date.now(),
        m()) : t && (l = new Promise( (g, _) => {
            i = n ? _ : g,
            a = setTimeout( () => {
                o = Date.now(),
                s = !0,
                g(m()),
                u()
            }
            , Math.max(0, d - p))
        }
        )),
        !r && !a && (a = setTimeout( () => s = !0, d)),
        s = !1,
        l)
    }
}
function identity(e) {
    return e
}
function tryOnScopeDispose(e) {
    return getCurrentScope() ? (onScopeDispose(e),
    !0) : !1
}
function useDebounceFn(e, t=200, r={}) {
    return createFilterWrapper(debounceFilter(t, r), e)
}
function refDebounced(e, t=200, r={}) {
    const n = ref(e.value)
      , o = useDebounceFn( () => {
        n.value = e.value
    }
    , t, r);
    return watch(e, () => o()),
    n
}
function useThrottleFn(e, t=200, r=!1, n=!0, o=!1) {
    return createFilterWrapper(throttleFilter(t, r, n, o), e)
}
function tryOnMounted(e, t=!0) {
    getCurrentInstance() ? onMounted(e) : t ? e() : nextTick(e)
}
function useTimeoutFn(e, t, r={}) {
    const {immediate: n=!0} = r
      , o = ref(!1);
    let a = null;
    function s() {
        a && (clearTimeout(a),
        a = null)
    }
    function i() {
        o.value = !1,
        s()
    }
    function l(...u) {
        s(),
        o.value = !0,
        a = setTimeout( () => {
            o.value = !1,
            a = null,
            e(...u)
        }
        , resolveUnref(t))
    }
    return n && (o.value = !0,
    isClient && l()),
    tryOnScopeDispose(i),
    {
        isPending: readonly(o),
        start: l,
        stop: i
    }
}
function unrefElement(e) {
    var t;
    const r = resolveUnref(e);
    return (t = r == null ? void 0 : r.$el) != null ? t : r
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...e) {
    let t, r, n, o;
    if (isString$2(e[0]) || Array.isArray(e[0]) ? ([r,n,o] = e,
    t = defaultWindow) : [t,r,n,o] = e,
    !t)
        return noop;
    Array.isArray(r) || (r = [r]),
    Array.isArray(n) || (n = [n]);
    const a = []
      , s = () => {
        a.forEach(c => c()),
        a.length = 0
    }
      , i = (c, f, d, p) => (c.addEventListener(f, d, p),
    () => c.removeEventListener(f, d, p))
      , l = watch( () => [unrefElement(t), resolveUnref(o)], ([c,f]) => {
        s(),
        c && a.push(...r.flatMap(d => n.map(p => i(c, d, p, f))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => {
        l(),
        s()
    }
    ;
    return tryOnScopeDispose(u),
    u
}
let _iOSWorkaround = !1;
function onClickOutside(e, t, r={}) {
    const {window: n=defaultWindow, ignore: o=[], capture: a=!0, detectIframe: s=!1} = r;
    if (!n)
        return;
    isIOS && !_iOSWorkaround && (_iOSWorkaround = !0,
    Array.from(n.document.body.children).forEach(d => d.addEventListener("click", noop)));
    let i = !0;
    const l = d => o.some(p => {
        if (typeof p == "string")
            return Array.from(n.document.querySelectorAll(p)).some(m => m === d.target || d.composedPath().includes(m));
        {
            const m = unrefElement(p);
            return m && (d.target === m || d.composedPath().includes(m))
        }
    }
    )
      , c = [useEventListener(n, "click", d => {
        const p = unrefElement(e);
        if (!(!p || p === d.target || d.composedPath().includes(p))) {
            if (d.detail === 0 && (i = !l(d)),
            !i) {
                i = !0;
                return
            }
            t(d)
        }
    }
    , {
        passive: !0,
        capture: a
    }), useEventListener(n, "pointerdown", d => {
        const p = unrefElement(e);
        p && (i = !d.composedPath().includes(p) && !l(d))
    }
    , {
        passive: !0
    }), s && useEventListener(n, "blur", d => {
        var p;
        const m = unrefElement(e);
        ((p = n.document.activeElement) == null ? void 0 : p.tagName) === "IFRAME" && !(m != null && m.contains(n.document.activeElement)) && t(d)
    }
    )].filter(Boolean);
    return () => c.forEach(d => d())
}
function useSupported(e, t=!1) {
    const r = ref()
      , n = () => r.value = !!e();
    return n(),
    tryOnMounted(n, t),
    r
}
const _global = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols
  , __hasOwnProp$g = Object.prototype.hasOwnProperty
  , __propIsEnum$g = Object.prototype.propertyIsEnumerable
  , __objRest$2 = (e, t) => {
    var r = {};
    for (var n in e)
        __hasOwnProp$g.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && __getOwnPropSymbols$g)
        for (var n of __getOwnPropSymbols$g(e))
            t.indexOf(n) < 0 && __propIsEnum$g.call(e, n) && (r[n] = e[n]);
    return r
}
;
function useResizeObserver(e, t, r={}) {
    const n = r
      , {window: o=defaultWindow} = n
      , a = __objRest$2(n, ["window"]);
    let s;
    const i = useSupported( () => o && "ResizeObserver"in o)
      , l = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , u = watch( () => unrefElement(e), f => {
        l(),
        i.value && o && f && (s = new ResizeObserver(t),
        s.observe(f, a))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        l(),
        u()
    }
    ;
    return tryOnScopeDispose(c),
    {
        isSupported: i,
        stop: c
    }
}
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols
  , __hasOwnProp$8 = Object.prototype.hasOwnProperty
  , __propIsEnum$8 = Object.prototype.propertyIsEnumerable
  , __objRest$1 = (e, t) => {
    var r = {};
    for (var n in e)
        __hasOwnProp$8.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && __getOwnPropSymbols$8)
        for (var n of __getOwnPropSymbols$8(e))
            t.indexOf(n) < 0 && __propIsEnum$8.call(e, n) && (r[n] = e[n]);
    return r
}
;
function useMutationObserver(e, t, r={}) {
    const n = r
      , {window: o=defaultWindow} = n
      , a = __objRest$1(n, ["window"]);
    let s;
    const i = useSupported( () => o && "MutationObserver"in o)
      , l = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , u = watch( () => unrefElement(e), f => {
        l(),
        i.value && o && f && (s = new MutationObserver(t),
        s.observe(f, a))
    }
    , {
        immediate: !0
    })
      , c = () => {
        l(),
        u()
    }
    ;
    return tryOnScopeDispose(c),
    {
        isSupported: i,
        stop: c
    }
}
var SwipeDirection;
(function(e) {
    e.UP = "UP",
    e.RIGHT = "RIGHT",
    e.DOWN = "DOWN",
    e.LEFT = "LEFT",
    e.NONE = "NONE"
}
)(SwipeDirection || (SwipeDirection = {}));
var __defProp = Object.defineProperty
  , __getOwnPropSymbols = Object.getOwnPropertySymbols
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __propIsEnum = Object.prototype.propertyIsEnumerable
  , __defNormalProp = (e, t, r) => t in e ? __defProp(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , __spreadValues = (e, t) => {
    for (var r in t || (t = {}))
        __hasOwnProp.call(t, r) && __defNormalProp(e, r, t[r]);
    if (__getOwnPropSymbols)
        for (var r of __getOwnPropSymbols(t))
            __propIsEnum.call(t, r) && __defNormalProp(e, r, t[r]);
    return e
}
;
const _TransitionPresets = {
    easeInSine: [.12, 0, .39, 0],
    easeOutSine: [.61, 1, .88, 1],
    easeInOutSine: [.37, 0, .63, 1],
    easeInQuad: [.11, 0, .5, 0],
    easeOutQuad: [.5, 1, .89, 1],
    easeInOutQuad: [.45, 0, .55, 1],
    easeInCubic: [.32, 0, .67, 0],
    easeOutCubic: [.33, 1, .68, 1],
    easeInOutCubic: [.65, 0, .35, 1],
    easeInQuart: [.5, 0, .75, 0],
    easeOutQuart: [.25, 1, .5, 1],
    easeInOutQuart: [.76, 0, .24, 1],
    easeInQuint: [.64, 0, .78, 0],
    easeOutQuint: [.22, 1, .36, 1],
    easeInOutQuint: [.83, 0, .17, 1],
    easeInExpo: [.7, 0, .84, 0],
    easeOutExpo: [.16, 1, .3, 1],
    easeInOutExpo: [.87, 0, .13, 1],
    easeInCirc: [.55, 0, 1, .45],
    easeOutCirc: [0, .55, .45, 1],
    easeInOutCirc: [.85, 0, .15, 1],
    easeInBack: [.36, 0, .66, -.56],
    easeOutBack: [.34, 1.56, .64, 1],
    easeInOutBack: [.68, -.6, .32, 1.6]
};
__spreadValues({
    linear: identity
}, _TransitionPresets);
const FOCUSABLE_ELEMENT_SELECTORS = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])'
  , isVisible = e => getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null
  , obtainAllFocusableElements$1 = e => Array.from(e.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(t => isFocusable(t) && isVisible(t))
  , isFocusable = e => {
    if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
        return !0;
    if (e.tabIndex < 0 || e.hasAttribute("disabled") || e.getAttribute("aria-disabled") === "true")
        return !1;
    switch (e.nodeName) {
    case "A":
        return !!e.href && e.rel !== "ignore";
    case "INPUT":
        return !(e.type === "hidden" || e.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
        return !0;
    default:
        return !1
    }
}
  , isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent)
  , NOOP = () => {}
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , hasOwn$2 = (e, t) => hasOwnProperty.call(e, t)
  , isArray$4 = Array.isArray
  , isDate$1 = e => toTypeString(e) === "[object Date]"
  , isFunction = e => typeof e == "function"
  , isString$1 = e => typeof e == "string"
  , isObject = e => e !== null && typeof e == "object"
  , objectToString$1 = Object.prototype.toString
  , toTypeString = e => objectToString$1.call(e)
  , toRawType = e => toTypeString(e).slice(8, -1)
  , cacheStringFunction = e => {
    const t = Object.create(null);
    return r => t[r] || (t[r] = e(r))
}
  , camelizeRE = /-(\w)/g
  , camelize = cacheStringFunction(e => e.replace(camelizeRE, (t, r) => r ? r.toUpperCase() : ""))
  , hyphenateRE = /\B([A-Z])/g
  , hyphenate = cacheStringFunction(e => e.replace(hyphenateRE, "-$1").toLowerCase())
  , isUndefined = e => e === void 0
  , isBoolean$1 = e => typeof e == "boolean"
  , isNumber$1 = e => typeof e == "number"
  , isEmpty = e => !e && e !== 0 || isArray$4(e) && e.length === 0 || isObject(e) && !Object.keys(e).length
  , isElement$1 = e => typeof Element > "u" ? !1 : e instanceof Element
  , isPropAbsent = e => isNil(e)
  , isStringNumber = e => isString$1(e) ? !Number.isNaN(Number(e)) : !1
  , keysOf = e => Object.keys(e)
  , getProp = (e, t, r) => ({
    get value() {
        return get(e, t, r)
    },
    set value(n) {
        set(e, t, n)
    }
});
class ElementPlusError extends Error {
    constructor(t) {
        super(t),
        this.name = "ElementPlusError"
    }
}
function throwError(e, t) {
    throw new ElementPlusError(`[${e}] ${t}`)
}
function debugWarn(e, t) {}
const classNameToArray = (e="") => e.split(" ").filter(t => !!t.trim())
  , hasClass = (e, t) => {
    if (!e || !t)
        return !1;
    if (t.includes(" "))
        throw new Error("className should not contain space.");
    return e.classList.contains(t)
}
  , addClass = (e, t) => {
    !e || !t.trim() || e.classList.add(...classNameToArray(t))
}
  , removeClass = (e, t) => {
    !e || !t.trim() || e.classList.remove(...classNameToArray(t))
}
  , getStyle = (e, t) => {
    var r;
    if (!isClient || !e || !t)
        return "";
    let n = camelize(t);
    n === "float" && (n = "cssFloat");
    try {
        const o = e.style[n];
        if (o)
            return o;
        const a = (r = document.defaultView) == null ? void 0 : r.getComputedStyle(e, "");
        return a ? a[n] : ""
    } catch {
        return e.style[n]
    }
}
;
function addUnit(e, t="px") {
    if (!e)
        return "";
    if (isNumber$1(e) || isStringNumber(e))
        return `${e}${t}`;
    if (isString$1(e))
        return e
}
const isScroll = (e, t) => {
    if (!isClient)
        return !1;
    const r = {
        undefined: "overflow",
        true: "overflow-y",
        false: "overflow-x"
    }[String(t)]
      , n = getStyle(e, r);
    return ["scroll", "auto", "overlay"].some(o => n.includes(o))
}
  , getScrollContainer = (e, t) => {
    if (!isClient)
        return;
    let r = e;
    for (; r; ) {
        if ([window, document, document.documentElement].includes(r))
            return window;
        if (isScroll(r, t))
            return r;
        r = r.parentNode
    }
    return r
}
;
let scrollBarWidth;
const getScrollBarWidth = e => {
    var t;
    if (!isClient)
        return 0;
    if (scrollBarWidth !== void 0)
        return scrollBarWidth;
    const r = document.createElement("div");
    r.className = `${e}-scrollbar__wrap`,
    r.style.visibility = "hidden",
    r.style.width = "100px",
    r.style.position = "absolute",
    r.style.top = "-9999px",
    document.body.appendChild(r);
    const n = r.offsetWidth;
    r.style.overflow = "scroll";
    const o = document.createElement("div");
    o.style.width = "100%",
    r.appendChild(o);
    const a = o.offsetWidth;
    return (t = r.parentNode) == null || t.removeChild(r),
    scrollBarWidth = n - a,
    scrollBarWidth
}
;
function scrollIntoView(e, t) {
    if (!isClient)
        return;
    if (!t) {
        e.scrollTop = 0;
        return
    }
    const r = [];
    let n = t.offsetParent;
    for (; n !== null && e !== n && e.contains(n); )
        r.push(n),
        n = n.offsetParent;
    const o = t.offsetTop + r.reduce( (l, u) => l + u.offsetTop, 0)
      , a = o + t.offsetHeight
      , s = e.scrollTop
      , i = s + e.clientHeight;
    o < s ? e.scrollTop = o : a > i && (e.scrollTop = a - e.clientHeight)
}
/*! Element Plus Icons Vue v2.3.1 */
var arrow_down_bold_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowDownBold",
    __name: "arrow-down-bold",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496z"
        })]))
    }
})
  , arrow_down_bold_default = arrow_down_bold_vue_vue_type_script_setup_true_lang_default
  , arrow_down_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowDown",
    __name: "arrow-down",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        })]))
    }
})
  , arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default
  , arrow_left_bold_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowLeftBold",
    __name: "arrow-left-bold",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M685.248 104.704a64 64 0 0 1 0 90.496L368.448 512l316.8 316.8a64 64 0 0 1-90.496 90.496L232.704 557.248a64 64 0 0 1 0-90.496l362.048-362.048a64 64 0 0 1 90.496 0z"
        })]))
    }
})
  , arrow_left_bold_default = arrow_left_bold_vue_vue_type_script_setup_true_lang_default
  , arrow_left_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowLeft",
    __name: "arrow-left",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
        })]))
    }
})
  , arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default
  , arrow_right_bold_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowRightBold",
    __name: "arrow-right-bold",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M338.752 104.704a64 64 0 0 0 0 90.496l316.8 316.8-316.8 316.8a64 64 0 0 0 90.496 90.496l362.048-362.048a64 64 0 0 0 0-90.496L429.248 104.704a64 64 0 0 0-90.496 0z"
        })]))
    }
})
  , arrow_right_bold_default = arrow_right_bold_vue_vue_type_script_setup_true_lang_default
  , arrow_right_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowRight",
    __name: "arrow-right",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
        })]))
    }
})
  , arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default
  , arrow_up_bold_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowUpBold",
    __name: "arrow-up-bold",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M104.704 685.248a64 64 0 0 0 90.496 0l316.8-316.8 316.8 316.8a64 64 0 0 0 90.496-90.496L557.248 232.704a64 64 0 0 0-90.496 0L104.704 594.752a64 64 0 0 0 0 90.496z"
        })]))
    }
})
  , arrow_up_bold_default = arrow_up_bold_vue_vue_type_script_setup_true_lang_default
  , arrow_up_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ArrowUp",
    __name: "arrow-up",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
        })]))
    }
})
  , arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default
  , bell_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Bell",
    __name: "bell",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a64 64 0 0 1 64 64v64H448v-64a64 64 0 0 1 64-64"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M256 768h512V448a256 256 0 1 0-512 0zm256-640a320 320 0 0 1 320 320v384H192V448a320 320 0 0 1 320-320"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M96 768h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32m352 128h128a64 64 0 0 1-128 0"
        })]))
    }
})
  , bell_default = bell_vue_vue_type_script_setup_true_lang_default
  , bottom_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Bottom",
    __name: "bottom",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M544 805.888V168a32 32 0 1 0-64 0v637.888L246.656 557.952a30.72 30.72 0 0 0-45.312 0 35.52 35.52 0 0 0 0 48.064l288 306.048a30.72 30.72 0 0 0 45.312 0l288-306.048a35.52 35.52 0 0 0 0-48 30.72 30.72 0 0 0-45.312 0L544 805.824z"
        })]))
    }
})
  , bottom_default = bottom_vue_vue_type_script_setup_true_lang_default
  , calendar_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Calendar",
    __name: "calendar",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
        })]))
    }
})
  , calendar_default = calendar_vue_vue_type_script_setup_true_lang_default
  , caret_bottom_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CaretBottom",
    __name: "caret-bottom",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m192 384 320 384 320-384z"
        })]))
    }
})
  , caret_bottom_default = caret_bottom_vue_vue_type_script_setup_true_lang_default
  , caret_right_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CaretRight",
    __name: "caret-right",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M384 192v640l384-320.064z"
        })]))
    }
})
  , caret_right_default = caret_right_vue_vue_type_script_setup_true_lang_default
  , caret_top_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CaretTop",
    __name: "caret-top",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 320 192 704h639.936z"
        })]))
    }
})
  , caret_top_default = caret_top_vue_vue_type_script_setup_true_lang_default
  , circle_check_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CircleCheck",
    __name: "circle-check",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
        })]))
    }
})
  , circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default
  , circle_close_filled_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CircleCloseFilled",
    __name: "circle-close-filled",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
        })]))
    }
})
  , circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default
  , circle_close_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CircleClose",
    __name: "circle-close",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        })]))
    }
})
  , circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default
  , clock_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Clock",
    __name: "clock",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
        })]))
    }
})
  , clock_default = clock_vue_vue_type_script_setup_true_lang_default
  , close_bold_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "CloseBold",
    __name: "close-bold",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M195.2 195.2a64 64 0 0 1 90.496 0L512 421.504 738.304 195.2a64 64 0 0 1 90.496 90.496L602.496 512 828.8 738.304a64 64 0 0 1-90.496 90.496L512 602.496 285.696 828.8a64 64 0 0 1-90.496-90.496L421.504 512 195.2 285.696a64 64 0 0 1 0-90.496z"
        })]))
    }
})
  , close_bold_default = close_bold_vue_vue_type_script_setup_true_lang_default
  , close_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Close",
    __name: "close",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        })]))
    }
})
  , close_default = close_vue_vue_type_script_setup_true_lang_default
  , d_arrow_left_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "DArrowLeft",
    __name: "d-arrow-left",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
        })]))
    }
})
  , d_arrow_left_default = d_arrow_left_vue_vue_type_script_setup_true_lang_default
  , d_arrow_right_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "DArrowRight",
    __name: "d-arrow-right",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
        })]))
    }
})
  , d_arrow_right_default = d_arrow_right_vue_vue_type_script_setup_true_lang_default
  , expand_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Expand",
    __name: "expand",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M128 192h768v128H128zm0 256h512v128H128zm0 256h768v128H128zm576-352 192 160-192 128z"
        })]))
    }
})
  , expand_default = expand_vue_vue_type_script_setup_true_lang_default
  , fold_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Fold",
    __name: "fold",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M896 192H128v128h768zm0 256H384v128h512zm0 256H128v128h768zM320 384 128 512l192 128z"
        })]))
    }
})
  , fold_default = fold_vue_vue_type_script_setup_true_lang_default
  , full_screen_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "FullScreen",
    __name: "full-screen",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
        })]))
    }
})
  , full_screen_default = full_screen_vue_vue_type_script_setup_true_lang_default
  , hide_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Hide",
    __name: "hide",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
        }), createBaseVNode("path", {
            fill: "currentColor",
            d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
        })]))
    }
})
  , hide_default = hide_vue_vue_type_script_setup_true_lang_default
  , info_filled_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "InfoFilled",
    __name: "info-filled",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
        })]))
    }
})
  , info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default
  , loading_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Loading",
    __name: "loading",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
        })]))
    }
})
  , loading_default = loading_vue_vue_type_script_setup_true_lang_default
  , minus_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Minus",
    __name: "minus",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
        })]))
    }
})
  , minus_default = minus_vue_vue_type_script_setup_true_lang_default
  , more_filled_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "MoreFilled",
    __name: "more-filled",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
        })]))
    }
})
  , more_filled_default = more_filled_vue_vue_type_script_setup_true_lang_default
  , plus_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Plus",
    __name: "plus",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
        })]))
    }
})
  , plus_default = plus_vue_vue_type_script_setup_true_lang_default
  , question_filled_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "QuestionFilled",
    __name: "question-filled",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
        })]))
    }
})
  , question_filled_default = question_filled_vue_vue_type_script_setup_true_lang_default
  , refresh_left_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "RefreshLeft",
    __name: "refresh-left",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
        })]))
    }
})
  , refresh_left_default = refresh_left_vue_vue_type_script_setup_true_lang_default
  , refresh_right_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "RefreshRight",
    __name: "refresh-right",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
        })]))
    }
})
  , refresh_right_default = refresh_right_vue_vue_type_script_setup_true_lang_default
  , scale_to_original_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ScaleToOriginal",
    __name: "scale-to-original",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
        })]))
    }
})
  , scale_to_original_default = scale_to_original_vue_vue_type_script_setup_true_lang_default
  , search_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Search",
    __name: "search",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
        })]))
    }
})
  , search_default = search_vue_vue_type_script_setup_true_lang_default
  , success_filled_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "SuccessFilled",
    __name: "success-filled",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
        })]))
    }
})
  , success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default
  , top_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Top",
    __name: "top",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M572.235 205.282v600.365a30.118 30.118 0 1 1-60.235 0V205.282L292.382 438.633a28.913 28.913 0 0 1-42.646 0 33.43 33.43 0 0 1 0-45.236l271.058-288.045a28.913 28.913 0 0 1 42.647 0L834.5 393.397a33.43 33.43 0 0 1 0 45.176 28.913 28.913 0 0 1-42.647 0l-219.618-233.23z"
        })]))
    }
})
  , top_default = top_vue_vue_type_script_setup_true_lang_default
  , view_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "View",
    __name: "view",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
        })]))
    }
})
  , view_default = view_vue_vue_type_script_setup_true_lang_default
  , warning_filled_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "WarningFilled",
    __name: "warning-filled",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
        })]))
    }
})
  , warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default
  , warning_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "Warning",
    __name: "warning",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0m-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
        })]))
    }
})
  , warning_default = warning_vue_vue_type_script_setup_true_lang_default
  , zoom_in_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ZoomIn",
    __name: "zoom-in",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
        })]))
    }
})
  , zoom_in_default = zoom_in_vue_vue_type_script_setup_true_lang_default
  , zoom_out_vue_vue_type_script_setup_true_lang_default = defineComponent({
    name: "ZoomOut",
    __name: "zoom-out",
    setup(e) {
        return (t, r) => (openBlock(),
        createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [createBaseVNode("path", {
            fill: "currentColor",
            d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
        })]))
    }
})
  , zoom_out_default = zoom_out_vue_vue_type_script_setup_true_lang_default;
const epPropKey = "__epPropKey"
  , definePropType = e => e
  , isEpProp = e => isObject(e) && !!e[epPropKey]
  , buildProp = (e, t) => {
    if (!isObject(e) || isEpProp(e))
        return e;
    const {values: r, required: n, default: o, type: a, validator: s} = e
      , l = {
        type: a,
        required: !!n,
        validator: r || s ? u => {
            let c = !1
              , f = [];
            if (r && (f = Array.from(r),
            hasOwn$2(e, "default") && f.push(o),
            c || (c = f.includes(u))),
            s && (c || (c = s(u))),
            !c && f.length > 0) {
                const d = [...new Set(f)].map(p => JSON.stringify(p)).join(", ");
                warn(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${d}], got value ${JSON.stringify(u)}.`)
            }
            return c
        }
        : void 0,
        [epPropKey]: !0
    };
    return hasOwn$2(e, "default") && (l.default = o),
    l
}
  , buildProps = e => fromPairs(Object.entries(e).map( ([t,r]) => [t, buildProp(r, t)]))
  , iconPropType = definePropType([String, Object, Function])
  , CloseComponents = {
    Close: close_default
}
  , TypeComponents = {
    Close: close_default,
    SuccessFilled: success_filled_default,
    InfoFilled: info_filled_default,
    WarningFilled: warning_filled_default,
    CircleCloseFilled: circle_close_filled_default
}
  , TypeComponentsMap = {
    success: success_filled_default,
    warning: warning_filled_default,
    error: circle_close_filled_default,
    info: info_filled_default
}
  , ValidateComponentsMap = {
    validating: loading_default,
    success: circle_check_default,
    error: circle_close_default
}
  , withInstall = (e, t) => {
    if (e.install = r => {
        for (const n of [e, ...Object.values(t ?? {})])
            r.component(n.name, n)
    }
    ,
    t)
        for (const [r,n] of Object.entries(t))
            e[r] = n;
    return e
}
  , withInstallFunction = (e, t) => (e.install = r => {
    e._context = r._context,
    r.config.globalProperties[t] = e
}
,
e)
  , withInstallDirective = (e, t) => (e.install = r => {
    r.directive(t, e)
}
,
e)
  , withNoopInstall = e => (e.install = NOOP,
e)
  , EVENT_CODE = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter",
    pageUp: "PageUp",
    pageDown: "PageDown",
    home: "Home",
    end: "End"
}
  , UPDATE_MODEL_EVENT = "update:modelValue"
  , CHANGE_EVENT = "change"
  , INPUT_EVENT = "input"
  , componentSizes = ["", "default", "small", "large"]
  , isValidComponentSize = e => ["", ...componentSizes].includes(e);
var PatchFlags = (e => (e[e.TEXT = 1] = "TEXT",
e[e.CLASS = 2] = "CLASS",
e[e.STYLE = 4] = "STYLE",
e[e.PROPS = 8] = "PROPS",
e[e.FULL_PROPS = 16] = "FULL_PROPS",
e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS",
e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT",
e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT",
e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT",
e[e.NEED_PATCH = 512] = "NEED_PATCH",
e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS",
e[e.HOISTED = -1] = "HOISTED",
e[e.BAIL = -2] = "BAIL",
e))(PatchFlags || {});
const isKorean = e => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e)
  , mutable = e => e
  , defaultNamespace = "el"
  , statePrefix = "is-"
  , _bem = (e, t, r, n, o) => {
    let a = `${e}-${t}`;
    return r && (a += `-${r}`),
    n && (a += `__${n}`),
    o && (a += `--${o}`),
    a
}
  , namespaceContextKey = Symbol("namespaceContextKey")
  , useGetDerivedNamespace = e => {
    const t = e || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
    return computed( () => unref(t) || defaultNamespace)
}
  , useNamespace = (e, t) => {
    const r = useGetDerivedNamespace(t);
    return {
        namespace: r,
        b: (g="") => _bem(r.value, e, g, "", ""),
        e: g => g ? _bem(r.value, e, "", g, "") : "",
        m: g => g ? _bem(r.value, e, "", "", g) : "",
        be: (g, _) => g && _ ? _bem(r.value, e, g, _, "") : "",
        em: (g, _) => g && _ ? _bem(r.value, e, "", g, _) : "",
        bm: (g, _) => g && _ ? _bem(r.value, e, g, "", _) : "",
        bem: (g, _, b) => g && _ && b ? _bem(r.value, e, g, _, b) : "",
        is: (g, ..._) => {
            const b = _.length >= 1 ? _[0] : !0;
            return g && b ? `${statePrefix}${g}` : ""
        }
        ,
        cssVar: g => {
            const _ = {};
            for (const b in g)
                g[b] && (_[`--${r.value}-${b}`] = g[b]);
            return _
        }
        ,
        cssVarName: g => `--${r.value}-${g}`,
        cssVarBlock: g => {
            const _ = {};
            for (const b in g)
                g[b] && (_[`--${r.value}-${e}-${b}`] = g[b]);
            return _
        }
        ,
        cssVarBlockName: g => `--${r.value}-${e}-${g}`
    }
}
  , defaultIdInjection = {
    prefix: Math.floor(Math.random() * 1e4),
    current: 0
}
  , ID_INJECTION_KEY = Symbol("elIdInjection")
  , useIdInjection = () => getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection
  , useId = e => {
    const t = useIdInjection()
      , r = useGetDerivedNamespace();
    return computedEager( () => unref(e) || `${r.value}-id-${t.prefix}-${t.current++}`)
}
  , initial = {
    current: 0
}
  , zIndex = ref(0)
  , defaultInitialZIndex = 2e3
  , ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey")
  , zIndexContextKey = Symbol("zIndexContextKey")
  , useZIndex = e => {
    const t = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial
      , r = e || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0)
      , n = computed( () => {
        const s = unref(r);
        return isNumber$1(s) ? s : defaultInitialZIndex
    }
    )
      , o = computed( () => n.value + zIndex.value)
      , a = () => (t.current++,
    zIndex.value = t.current,
    o.value);
    return !isClient && inject(ZINDEX_INJECTION_KEY),
    {
        initialZIndex: n,
        currentZIndex: o,
        nextZIndex: a
    }
}
  , element_plus_injection_plugin_1RNPi6ogby = defineNuxtPlugin(e => {
    e.vueApp.provide(ID_INJECTION_KEY, {
        prefix: 1024,
        current: 0
    }).provide(ZINDEX_INJECTION_KEY, {
        current: -500
    })
}
)
  , REGEX_CRAWLER = new RegExp(/Googlebot\/|Googlebot-Mobile|Googlebot-Image|Googlebot-News|Googlebot-Video|AdsBot-Google([^-]|$)|AdsBot-Google-Mobile|Feedfetcher-Google|Mediapartners-Google|Mediapartners \(Googlebot\)|APIs-Google|Google-InspectionTool|Storebot-Google|GoogleOther|bingbot|Slurp|[wW]get|LinkedInBot|Python-urllib|python-requests|aiohttp|httpx|libwww-perl|httpunit|Nutch|Go-http-client|phpcrawl|msnbot|jyxobot|FAST-WebCrawler|FAST Enterprise Crawler|BIGLOTRON|Teoma|convera|seekbot|Gigabot|Gigablast|exabot|ia_archiver|GingerCrawler|webmon |HTTrack|grub\.org|UsineNouvelleCrawler|antibot|netresearchserver|speedy|fluffy|findlink|msrbot|panscient|yacybot|AISearchBot|ips-agent|tagoobot|MJ12bot|woriobot|yanga|buzzbot|mlbot|yandex\.com\/bots|purebot|Linguee Bot|CyberPatrol|voilabot|Baiduspider|citeseerxbot|spbot|twengabot|postrank|Turnitin|scribdbot|page2rss|sitebot|linkdex|Adidxbot|ezooms|dotbot|Mail\.RU_Bot|discobot|heritrix|findthatfile|europarchive\.org|NerdByNature\.Bot|(sistrix|SISTRIX) [cC]rawler|Ahrefs(Bot|SiteAudit)|fuelbot|CrunchBot|IndeedBot|mappydata|woobot|ZoominfoBot|PrivacyAwareBot|Multiviewbot|SWIMGBot|Grobbot|eright|Apercite|semanticbot|Aboundex|domaincrawler|wbsearchbot|summify|CCBot|edisterbot|SeznamBot|ec2linkfinder|gslfbot|aiHitBot|intelium_bot|facebookexternalhit|Yeti|RetrevoPageAnalyzer|lb-spider|Sogou|lssbot|careerbot|wotbox|wocbot|ichiro|DuckDuckBot|lssrocketcrawler|drupact|webcompanycrawler|acoonbot|openindexspider|gnam gnam spider|web-archive-net\.com\.bot|backlinkcrawler|coccoc|integromedb|content crawler spider|toplistbot|it2media-domain-crawler|ip-web-crawler\.com|siteexplorer\.info|elisabot|proximic|changedetection|arabot|WeSEE:Search|niki-bot|CrystalSemanticsBot|rogerbot|360Spider|psbot|InterfaxScanBot|CC Metadata Scaper|g00g1e\.net|GrapeshotCrawler|urlappendbot|brainobot|fr-crawler|binlar|SimpleCrawler|Twitterbot|cXensebot|smtbot|bnf\.fr_bot|A6-Indexer|ADmantX|Facebot|OrangeBot\/|memorybot|AdvBot|MegaIndex|SemanticScholarBot|ltx71|nerdybot|xovibot|BUbiNG|Qwantify|archive\.org_bot|Applebot|TweetmemeBot|crawler4j|findxbot|S[eE][mM]rushBot|yoozBot|lipperhey|Y!J|Domain Re-Animator Bot|AddThis|Screaming Frog SEO Spider|MetaURI|Scrapy|Livelap[bB]ot|OpenHoseBot|CapsuleChecker|collection@infegy\.com|IstellaBot|DeuSu\/|betaBot|Cliqzbot\/|MojeekBot\/|netEstate NE Crawler|SafeSearch microdata crawler|Gluten Free Crawler\/|Sonic|Sysomos|Trove|deadlinkchecker|Slack-ImgProxy|Embedly|RankActiveLinkBot|iskanie|SafeDNSBot|SkypeUriPreview|Veoozbot|Slackbot|redditbot|datagnionbot|Google-Adwords-Instant|adbeat_bot|WhatsApp|contxbot|pinterest\.com\/bot|electricmonk|GarlikCrawler|BingPreview\/|vebidoobot|FemtosearchBot|Yahoo Link Preview|MetaJobBot|DomainStatsBot|mindUpBot|Daum\/|Jugendschutzprogramm-Crawler|Xenu Link Sleuth|Pcore-HTTP|moatbot|KosmioBot|[pP]ingdom|AppInsights|PhantomJS|Gowikibot|PiplBot|Discordbot|TelegramBot|Jetslide|newsharecounts|James BOT|Bark[rR]owler|TinEye|SocialRankIOBot|trendictionbot|Ocarinabot|epicbot|Primalbot|DuckDuckGo-Favicons-Bot|GnowitNewsbot|Leikibot|LinkArchiver|YaK\/|PaperLiBot|Digg Deeper|dcrawl|Snacktory|AndersPinkBot|Fyrebot|EveryoneSocialBot|Mediatoolkitbot|Luminator-robots|ExtLinksBot|SurveyBot|NING\/|okhttp|Nuzzel|omgili|PocketParser|YisouSpider|um-LN|ToutiaoSpider|MuckRack|Jamie's Spider|AHC\/|NetcraftSurveyAgent|Laserlikebot|^Apache-HttpClient|AppEngine-Google|Jetty|Upflow|Thinklab|Traackr\.com|Twurly|Mastodon|http_get|DnyzBot|botify|007ac9 Crawler|BehloolBot|BrandVerity|check_http|BDCbot|ZumBot|EZID|ICC-Crawler|ArchiveBot|^LCC |filterdb\.iss\.net\/crawler|BLP_bbot|BomboraBot|Buck\/|Companybook-Crawler|Genieo|magpie-crawler|MeltwaterNews|Moreover|newspaper\/|ScoutJet|(^| )sentry\/|StorygizeBot|UptimeRobot|OutclicksBot|seoscanners|Hatena|Google Web Preview|MauiBot|AlphaBot|SBL-BOT|IAS crawler|adscanner|Netvibes|acapbot|Baidu-YunGuanCe|bitlybot|blogmuraBot|Bot\.AraTurka\.com|bot-pge\.chlooe\.com|BoxcarBot|BTWebClient|ContextAd Bot|Digincore bot|Disqus|Feedly|Fetch\/|Fever|Flamingo_SearchEngine|FlipboardProxy|g2reader-bot|G2 Web Services|imrbot|K7MLWCBot|Kemvibot|Landau-Media-Spider|linkapediabot|vkShare|Siteimprove\.com|BLEXBot\/|DareBoost|ZuperlistBot\/|Miniflux\/|Feedspot|Diffbot\/|SEOkicks|tracemyfile|Nimbostratus-Bot|zgrab|PR-CY\.RU|AdsTxtCrawler|Datafeedwatch|Zabbix|TangibleeBot|google-xrawler|axios|Amazon CloudFront|Pulsepoint|CloudFlare-AlwaysOnline|Google-Structured-Data-Testing-Tool|WordupInfoSearch|WebDataStats|HttpUrlConnection|ZoomBot|VelenPublicWebCrawler|MoodleBot|jpg-newsbot|outbrain|W3C_Validator|Validator\.nu|W3C-checklink|W3C-mobileOK|W3C_I18n-Checker|FeedValidator|W3C_CSS_Validator|W3C_Unicorn|Google-PhysicalWeb|Blackboard|ICBot\/|BazQux|Twingly|Rivva|Experibot|awesomecrawler|Dataprovider\.com|GroupHigh\/|theoldreader\.com|AnyEvent|Uptimebot\.org|Nmap Scripting Engine|2ip\.ru|Clickagy|Caliperbot|MBCrawler|online-webceo-bot|B2B Bot|AddSearchBot|Google Favicon|HubSpot|Chrome-Lighthouse|HeadlessChrome|CheckMarkNetwork\/|www\.uptime\.com|Streamline3Bot\/|serpstatbot\/|MixnodeCache\/|^curl|SimpleScraper|RSSingBot|Jooblebot|fedoraplanet|Friendica|NextCloud|Tiny Tiny RSS|RegionStuttgartBot|Bytespider|Datanyze|Google-Site-Verification|TrendsmapResolver|tweetedtimes|NTENTbot|Gwene|SimplePie|SearchAtlas|Superfeedr|feedbot|UT-Dorkbot|Amazonbot|SerendeputyBot|Eyeotabot|officestorebot|Neticle Crawler|SurdotlyBot|LinkisBot|AwarioSmartBot|AwarioRssBot|RyteBot|FreeWebMonitoring SiteChecker|AspiegelBot|NAVER Blog Rssbot|zenback bot|SentiBot|Domains Project\/|Pandalytics|VKRobot|bidswitchbot|tigerbot|NIXStatsbot|Atom Feed Robot|[Cc]urebot|PagePeeker\/|Vigil\/|rssbot\/|startmebot\/|JobboerseBot|seewithkids|NINJA bot|Cutbot|BublupBot|BrandONbot|RidderBot|Taboolabot|Dubbotbot|FindITAnswersbot|infoobot|Refindbot|BlogTraffic\/\d\.\d+ Feed-Fetcher|SeobilityBot|Cincraw|Dragonbot|VoluumDSP-content-bot|FreshRSS|BitBot|^PHP-Curl-Class|Google-Certificates-Bridge|centurybot|Viber|e\.ventures Investment Crawler|evc-batch|PetalBot|virustotal|(^| )PTST\/|minicrawler|Cookiebot|trovitBot|seostar\.co|IonCrawl|Uptime-Kuma|Seekport|FreshpingBot|Feedbin|CriteoBot|Snap URL Preview Service|Better Uptime Bot|RuxitSynthetic|Google-Read-Aloud|Valve\/Steam|OdklBot\/|GPTBot|ChatGPT-User|YandexRenderResourcesBot\/|LightspeedSystemsCrawler|ev-crawler\/|BitSightBot\/|woorankreview\/|Google-Safety|AwarioBot|DataForSeoBot|Linespider|WellKnownBot|A Patent Crawler|StractBot|search\.marginalia\.nu|YouBot|Nicecrawler|Neevabot|BrightEdge Crawler|SiteCheckerBotCrawler|TombaPublicWebCrawler|CrawlyProjectCrawler|KomodiaBot|KStandBot|CISPA Webcrawler|MTRobot|hyscore\.io|AlexandriaOrgBot|2ip bot|Yellowbrandprotectionbot|SEOlizer|vuhuvBot|INETDEX-BOT|Synapse|t3versionsBot|deepnoc|Cocolyzebot|hypestat|ReverseEngineeringBot|sempi\.tech|Iframely|MetaInspector|node-fetch|lkxscan|python-opengraph|OpenGraphCheck|developers\.google\.com\/\+\/web\/snippet|SenutoBot|MaCoCu|NewsBlur|inoreader|NetSystemsResearch|PageThing|WordPress\/|PhxBot|ImagesiftBot|Expanse|InternetMeasurement|^BW\/|GeedoBot|Audisto Crawler|PerplexityBot\/|[cC]laude[bB]ot|Monsidobot|GroupMeBot|Vercelbot|vercel-screenshot/)
  , REGEX_MOBILE1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|FBAN|FBAV|fennec|hiptop|iemobile|ip(hone|od)|Instagram|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
  , REGEX_MOBILE2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
  , REGEX_MOBILE_OR_TABLET1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|FBAN|FBAV|fennec|hiptop|iemobile|ip(hone|od)|Instagram|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i
  , REGEX_MOBILE_OR_TABLET2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
function isMobile(e) {
    return REGEX_MOBILE1.test(e) || REGEX_MOBILE2.test(e.slice(0, 4))
}
function isMobileOrTablet(e) {
    return REGEX_MOBILE_OR_TABLET1.test(e) || REGEX_MOBILE_OR_TABLET2.test(e.slice(0, 4))
}
function isIos(e) {
    return /iPad|iPhone|iPod/.test(e)
}
function isAndroid(e) {
    return /android/i.test(e)
}
function isWindows(e) {
    return /Windows/.test(e)
}
function isMacOS(e) {
    return /Mac OS X/.test(e)
}
const browsers = [{
    name: "Samsung",
    regex: /SamsungBrowser/i
}, {
    name: "Edge",
    regex: /edg(?:[ea]|ios)?\//i
}, {
    name: "Firefox",
    regex: /firefox|iceweasel|fxios/i
}, {
    name: "Chrome",
    regex: /chrome|crios|crmo/i
}, {
    name: "Safari",
    regex: /safari|applewebkit/i
}];
function getBrowserName(e) {
    for (const t of browsers)
        if (t.regex.test(e))
            return t.name;
    return ""
}
function generateFlags(e, t={}) {
    let r = !1
      , n = !1
      , o = !1
      , a = !1;
    if (e === "Amazon CloudFront")
        t["cloudfront-is-mobile-viewer"] === "true" && (r = !0,
        n = !0),
        t["cloudfront-is-tablet-viewer"] === "true" && (r = !1,
        n = !0),
        t["cloudfront-is-desktop-viewer"] === "true" && (r = !1,
        n = !1),
        t["cloudfront-is-ios-viewer"] === "true" && (o = !0),
        t["cloudfront-is-android-viewer"] === "true" && (a = !0);
    else if (t && t["cf-device-type"])
        switch (t["cf-device-type"]) {
        case "mobile":
            r = !0,
            n = !0;
            break;
        case "tablet":
            r = !1,
            n = !0;
            break;
        case "desktop":
            r = !1,
            n = !1;
            break
        }
    else
        r = isMobile(e),
        n = isMobileOrTablet(e),
        o = isIos(e),
        a = isAndroid(e);
    const s = isWindows(e)
      , i = isMacOS(e)
      , l = getBrowserName(e)
      , u = l === "Safari"
      , c = l === "Firefox"
      , f = l === "Edge"
      , d = l === "Chrome"
      , p = l === "Samsung"
      , m = REGEX_CRAWLER.test(e);
    return {
        userAgent: e,
        isMobile: r,
        isMobileOrTablet: n,
        isTablet: !r && n,
        isDesktop: !n,
        isIos: o,
        isAndroid: a,
        isWindows: s,
        isMacOS: i,
        isApple: i || o,
        isDesktopOrTablet: !r,
        isSafari: u,
        isFirefox: c,
        isEdge: f,
        isChrome: d,
        isSamsung: p,
        isCrawler: m
    }
}
const plugin_wy0B721ODc = defineNuxtPlugin( () => {
    const e = useRuntimeConfig()
      , t = e.public.device.defaultUserAgent;
    let r;
    {
        const n = navigator.userAgent || t;
        r = reactive(generateFlags(n)),
        e.public.device.refreshOnResize && window.addEventListener("resize", () => {
            setTimeout( () => {
                const o = generateFlags(navigator.userAgent || n);
                Object.entries(o).forEach( ([a,s]) => {
                    r[a] = s
                }
                )
            }
            , 50)
        }
        )
    }
    return {
        provide: {
            device: r
        }
    }
}
)
  , unocss_MzCDxu9LMj = defineNuxtPlugin( () => {}
);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function getAugmentedNamespace(e) {
    if (e.__esModule)
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        r.prototype = t.prototype
    } else
        r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    Object.keys(e).forEach(function(n) {
        var o = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(r, n, o.get ? o : {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }),
    r
}
var shams = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
    if (typeof Symbol.iterator == "symbol")
        return !0;
    var t = {}
      , r = Symbol("test")
      , n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return !1;
    var o = 42;
    t[r] = o;
    for (r in t)
        return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
        return !1;
    var a = Object.getOwnPropertySymbols(t);
    if (a.length !== 1 || a[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
        return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
        var s = Object.getOwnPropertyDescriptor(t, r);
        if (s.value !== o || s.enumerable !== !0)
            return !1
    }
    return !0
}, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams, hasSymbols$1 = function() {
    return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham()
}, test = {
    foo: {}
}, $Object = Object, hasProto$1 = function() {
    return {
        __proto__: test
    }.foo === test.foo && !({
        __proto__: null
    }instanceof $Object)
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$1 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(t, r) {
    for (var n = [], o = 0; o < t.length; o += 1)
        n[o] = t[o];
    for (var a = 0; a < r.length; a += 1)
        n[a + t.length] = r[a];
    return n
}, slicy = function(t, r) {
    for (var n = [], o = r, a = 0; o < t.length; o += 1,
    a += 1)
        n[a] = t[o];
    return n
}, joiny = function(e, t) {
    for (var r = "", n = 0; n < e.length; n += 1)
        r += e[n],
        n + 1 < e.length && (r += t);
    return r
}, implementation$1 = function(t) {
    var r = this;
    if (typeof r != "function" || toStr$1.apply(r) !== funcType)
        throw new TypeError(ERROR_MESSAGE + r);
    for (var n = slicy(arguments, 1), o, a = function() {
        if (this instanceof o) {
            var c = r.apply(this, concatty(n, arguments));
            return Object(c) === c ? c : this
        }
        return r.apply(t, concatty(n, arguments))
    }, s = max(0, r.length - n.length), i = [], l = 0; l < s; l++)
        i[l] = "$" + l;
    if (o = Function("binder", "return function (" + joiny(i, ",") + "){ return binder.apply(this,arguments); }")(a),
    r.prototype) {
        var u = function() {};
        u.prototype = r.prototype,
        o.prototype = new u,
        u.prototype = null
    }
    return o
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call, $hasOwn), undefined$1, $SyntaxError$1 = SyntaxError, $Function = Function, $TypeError$3 = TypeError, getEvalledConstructor = function(e) {
    try {
        return $Function('"use strict"; return (' + e + ").constructor;")()
    } catch {}
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
    try {
        $gOPD$1({}, "")
    } catch {
        $gOPD$1 = null
    }
var throwTypeError = function() {
    throw new $TypeError$3
}
  , ThrowTypeError = $gOPD$1 ? function() {
    try {
        return arguments.callee,
        throwTypeError
    } catch {
        try {
            return $gOPD$1(arguments, "callee").get
        } catch {
            return throwTypeError
        }
    }
}() : throwTypeError
  , hasSymbols = hasSymbols$1()
  , hasProto = hasProto$1()
  , getProto = Object.getPrototypeOf || (hasProto ? function(e) {
    return e.__proto__
}
: null)
  , needsEval = {}
  , TypedArray = typeof Uint8Array > "u" || !getProto ? undefined$1 : getProto(Uint8Array)
  , INTRINSICS = {
    "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
    "%Map%": typeof Map > "u" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError$1,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError$3,
    "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto)
    try {
        null.error
    } catch (e) {
        var errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto
    }
var doEval = function e(t) {
    var r;
    if (t === "%AsyncFunction%")
        r = getEvalledConstructor("async function () {}");
    else if (t === "%GeneratorFunction%")
        r = getEvalledConstructor("function* () {}");
    else if (t === "%AsyncGeneratorFunction%")
        r = getEvalledConstructor("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var n = e("%AsyncGeneratorFunction%");
        n && (r = n.prototype)
    } else if (t === "%AsyncIteratorPrototype%") {
        var o = e("%AsyncGenerator%");
        o && getProto && (r = getProto(o.prototype))
    }
    return INTRINSICS[t] = r,
    r
}
  , LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
}
  , bind = functionBind
  , hasOwn$1 = hasown
  , $concat$1 = bind.call(Function.call, Array.prototype.concat)
  , $spliceApply = bind.call(Function.apply, Array.prototype.splice)
  , $replace$1 = bind.call(Function.call, String.prototype.replace)
  , $strSlice = bind.call(Function.call, String.prototype.slice)
  , $exec = bind.call(Function.call, RegExp.prototype.exec)
  , rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
  , reEscapeChar = /\\(\\)?/g
  , stringToPath = function(t) {
    var r = $strSlice(t, 0, 1)
      , n = $strSlice(t, -1);
    if (r === "%" && n !== "%")
        throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
    if (n === "%" && r !== "%")
        throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
    var o = [];
    return $replace$1(t, rePropName, function(a, s, i, l) {
        o[o.length] = i ? $replace$1(l, reEscapeChar, "$1") : s || a
    }),
    o
}
  , getBaseIntrinsic = function(t, r) {
    var n = t, o;
    if (hasOwn$1(LEGACY_ALIASES, n) && (o = LEGACY_ALIASES[n],
    n = "%" + o[0] + "%"),
    hasOwn$1(INTRINSICS, n)) {
        var a = INTRINSICS[n];
        if (a === needsEval && (a = doEval(n)),
        typeof a > "u" && !r)
            throw new $TypeError$3("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return {
            alias: o,
            name: n,
            value: a
        }
    }
    throw new $SyntaxError$1("intrinsic " + t + " does not exist!")
}
  , getIntrinsic = function(t, r) {
    if (typeof t != "string" || t.length === 0)
        throw new $TypeError$3("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r != "boolean")
        throw new $TypeError$3('"allowMissing" argument must be a boolean');
    if ($exec(/^%?[^%]*%?$/, t) === null)
        throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var n = stringToPath(t)
      , o = n.length > 0 ? n[0] : ""
      , a = getBaseIntrinsic("%" + o + "%", r)
      , s = a.name
      , i = a.value
      , l = !1
      , u = a.alias;
    u && (o = u[0],
    $spliceApply(n, $concat$1([0, 1], u)));
    for (var c = 1, f = !0; c < n.length; c += 1) {
        var d = n[c]
          , p = $strSlice(d, 0, 1)
          , m = $strSlice(d, -1);
        if ((p === '"' || p === "'" || p === "`" || m === '"' || m === "'" || m === "`") && p !== m)
            throw new $SyntaxError$1("property names with quotes must have matching quotes");
        if ((d === "constructor" || !f) && (l = !0),
        o += "." + d,
        s = "%" + o + "%",
        hasOwn$1(INTRINSICS, s))
            i = INTRINSICS[s];
        else if (i != null) {
            if (!(d in i)) {
                if (!r)
                    throw new $TypeError$3("base intrinsic for " + t + " exists, but the property is not available.");
                return
            }
            if ($gOPD$1 && c + 1 >= n.length) {
                var g = $gOPD$1(i, d);
                f = !!g,
                f && "get"in g && !("originalValue"in g.get) ? i = g.get : i = i[d]
            } else
                f = hasOwn$1(i, d),
                i = i[d];
            f && !l && (INTRINSICS[s] = i)
        }
    }
    return i
}
  , callBind$1 = {
    exports: {}
}
  , GetIntrinsic$5 = getIntrinsic
  , $defineProperty$1 = GetIntrinsic$5("%Object.defineProperty%", !0)
  , hasPropertyDescriptors$1 = function() {
    if ($defineProperty$1)
        try {
            return $defineProperty$1({}, "a", {
                value: 1
            }),
            !0
        } catch {
            return !1
        }
    return !1
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function() {
    if (!hasPropertyDescriptors$1())
        return null;
    try {
        return $defineProperty$1([], "length", {
            value: 1
        }).length !== 1
    } catch {
        return !0
    }
}
;
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1
  , GetIntrinsic$4 = getIntrinsic
  , $gOPD = GetIntrinsic$4("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
    try {
        $gOPD([], "length")
    } catch {
        $gOPD = null
    }
var gopd$1 = $gOPD
  , hasPropertyDescriptors = hasPropertyDescriptors_1()
  , GetIntrinsic$3 = getIntrinsic
  , $defineProperty = hasPropertyDescriptors && GetIntrinsic$3("%Object.defineProperty%", !0);
if ($defineProperty)
    try {
        $defineProperty({}, "a", {
            value: 1
        })
    } catch {
        $defineProperty = !1
    }
var $SyntaxError = GetIntrinsic$3("%SyntaxError%")
  , $TypeError$2 = GetIntrinsic$3("%TypeError%")
  , gopd = gopd$1
  , defineDataProperty = function(t, r, n) {
    if (!t || typeof t != "object" && typeof t != "function")
        throw new $TypeError$2("`obj` must be an object or a function`");
    if (typeof r != "string" && typeof r != "symbol")
        throw new $TypeError$2("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
        throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
        throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
        throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
        throw new $TypeError$2("`loose`, if provided, must be a boolean");
    var o = arguments.length > 3 ? arguments[3] : null
      , a = arguments.length > 4 ? arguments[4] : null
      , s = arguments.length > 5 ? arguments[5] : null
      , i = arguments.length > 6 ? arguments[6] : !1
      , l = !!gopd && gopd(t, r);
    if ($defineProperty)
        $defineProperty(t, r, {
            configurable: s === null && l ? l.configurable : !s,
            enumerable: o === null && l ? l.enumerable : !o,
            value: n,
            writable: a === null && l ? l.writable : !a
        });
    else if (i || !o && !a && !s)
        t[r] = n;
    else
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
}
  , GetIntrinsic$2 = getIntrinsic
  , define = defineDataProperty
  , hasDescriptors = hasPropertyDescriptors_1()
  , gOPD = gopd$1
  , $TypeError$1 = GetIntrinsic$2("%TypeError%")
  , $floor$1 = GetIntrinsic$2("%Math.floor%")
  , setFunctionLength = function(t, r) {
    if (typeof t != "function")
        throw new $TypeError$1("`fn` is not a function");
    if (typeof r != "number" || r < 0 || r > 4294967295 || $floor$1(r) !== r)
        throw new $TypeError$1("`length` must be a positive 32-bit integer");
    var n = arguments.length > 2 && !!arguments[2]
      , o = !0
      , a = !0;
    if ("length"in t && gOPD) {
        var s = gOPD(t, "length");
        s && !s.configurable && (o = !1),
        s && !s.writable && (a = !1)
    }
    return (o || a || !n) && (hasDescriptors ? define(t, "length", r, !0, !0) : define(t, "length", r)),
    t
};
(function(e) {
    var t = functionBind
      , r = getIntrinsic
      , n = setFunctionLength
      , o = r("%TypeError%")
      , a = r("%Function.prototype.apply%")
      , s = r("%Function.prototype.call%")
      , i = r("%Reflect.apply%", !0) || t.call(s, a)
      , l = r("%Object.defineProperty%", !0)
      , u = r("%Math.max%");
    if (l)
        try {
            l({}, "a", {
                value: 1
            })
        } catch {
            l = null
        }
    e.exports = function(d) {
        if (typeof d != "function")
            throw new o("a function is required");
        var p = i(t, s, arguments);
        return n(p, 1 + u(0, d.length - (arguments.length - 1)), !0)
    }
    ;
    var c = function() {
        return i(t, a, arguments)
    };
    l ? l(e.exports, "apply", {
        value: c
    }) : e.exports.apply = c
}
)(callBind$1);
var callBindExports = callBind$1.exports
  , GetIntrinsic$1 = getIntrinsic
  , callBind = callBindExports
  , $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"))
  , callBound$1 = function(t, r) {
    var n = GetIntrinsic$1(t, !!r);
    return typeof n == "function" && $indexOf(t, ".prototype.") > -1 ? callBind(n) : n
};
const __viteBrowserExternal = {}
  , __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$0 = getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map == "function" && Map.prototype
  , mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
  , mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get == "function" ? mapSizeDescriptor.get : null
  , mapForEach = hasMap && Map.prototype.forEach
  , hasSet = typeof Set == "function" && Set.prototype
  , setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
  , setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get == "function" ? setSizeDescriptor.get : null
  , setForEach = hasSet && Set.prototype.forEach
  , hasWeakMap = typeof WeakMap == "function" && WeakMap.prototype
  , weakMapHas = hasWeakMap ? WeakMap.prototype.has : null
  , hasWeakSet = typeof WeakSet == "function" && WeakSet.prototype
  , weakSetHas = hasWeakSet ? WeakSet.prototype.has : null
  , hasWeakRef = typeof WeakRef == "function" && WeakRef.prototype
  , weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null
  , booleanValueOf = Boolean.prototype.valueOf
  , objectToString = Object.prototype.toString
  , functionToString = Function.prototype.toString
  , $match = String.prototype.match
  , $slice = String.prototype.slice
  , $replace = String.prototype.replace
  , $toUpperCase = String.prototype.toUpperCase
  , $toLowerCase = String.prototype.toLowerCase
  , $test = RegExp.prototype.test
  , $concat = Array.prototype.concat
  , $join = Array.prototype.join
  , $arrSlice = Array.prototype.slice
  , $floor = Math.floor
  , bigIntValueOf = typeof BigInt == "function" ? BigInt.prototype.valueOf : null
  , gOPS = Object.getOwnPropertySymbols
  , symToString = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null
  , hasShammedSymbols = typeof Symbol == "function" && typeof Symbol.iterator == "object"
  , toStringTag = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols || !0) ? Symbol.toStringTag : null
  , isEnumerable = Object.prototype.propertyIsEnumerable
  , gPO = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
    return e.__proto__
}
: null);
function addNumericSeparator(e, t) {
    if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || $test.call(/e/, t))
        return t;
    var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof e == "number") {
        var n = e < 0 ? -$floor(-e) : $floor(e);
        if (n !== e) {
            var o = String(n)
              , a = $slice.call(t, o.length + 1);
            return $replace.call(o, r, "$&_") + "." + $replace.call($replace.call(a, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return $replace.call(t, r, "$&_")
}
var utilInspect = require$$0
  , inspectCustom = utilInspect.custom
  , inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null
  , objectInspect = function e(t, r, n, o) {
    var a = r || {};
    if (has$3(a, "quoteStyle") && a.quoteStyle !== "single" && a.quoteStyle !== "double")
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (has$3(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var s = has$3(a, "customInspect") ? a.customInspect : !0;
    if (typeof s != "boolean" && s !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (has$3(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (has$3(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var i = a.numericSeparator;
    if (typeof t > "u")
        return "undefined";
    if (t === null)
        return "null";
    if (typeof t == "boolean")
        return t ? "true" : "false";
    if (typeof t == "string")
        return inspectString(t, a);
    if (typeof t == "number") {
        if (t === 0)
            return 1 / 0 / t > 0 ? "0" : "-0";
        var l = String(t);
        return i ? addNumericSeparator(t, l) : l
    }
    if (typeof t == "bigint") {
        var u = String(t) + "n";
        return i ? addNumericSeparator(t, u) : u
    }
    var c = typeof a.depth > "u" ? 5 : a.depth;
    if (typeof n > "u" && (n = 0),
    n >= c && c > 0 && typeof t == "object")
        return isArray$3(t) ? "[Array]" : "[Object]";
    var f = getIndent(a, n);
    if (typeof o > "u")
        o = [];
    else if (indexOf(o, t) >= 0)
        return "[Circular]";
    function d(A, B, $) {
        if (B && (o = $arrSlice.call(o),
        o.push(B)),
        $) {
            var P = {
                depth: a.depth
            };
            return has$3(a, "quoteStyle") && (P.quoteStyle = a.quoteStyle),
            e(A, P, n + 1, o)
        }
        return e(A, a, n + 1, o)
    }
    if (typeof t == "function" && !isRegExp$1(t)) {
        var p = nameOf(t)
          , m = arrObjKeys(t, d);
        return "[Function" + (p ? ": " + p : " (anonymous)") + "]" + (m.length > 0 ? " { " + $join.call(m, ", ") + " }" : "")
    }
    if (isSymbol(t)) {
        var g = hasShammedSymbols ? $replace.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(t);
        return typeof t == "object" && !hasShammedSymbols ? markBoxed(g) : g
    }
    if (isElement(t)) {
        for (var _ = "<" + $toLowerCase.call(String(t.nodeName)), b = t.attributes || [], y = 0; y < b.length; y++)
            _ += " " + b[y].name + "=" + wrapQuotes(quote(b[y].value), "double", a);
        return _ += ">",
        t.childNodes && t.childNodes.length && (_ += "..."),
        _ += "</" + $toLowerCase.call(String(t.nodeName)) + ">",
        _
    }
    if (isArray$3(t)) {
        if (t.length === 0)
            return "[]";
        var v = arrObjKeys(t, d);
        return f && !singleLineValues(v) ? "[" + indentedJoin(v, f) + "]" : "[ " + $join.call(v, ", ") + " ]"
    }
    if (isError(t)) {
        var S = arrObjKeys(t, d);
        return !("cause"in Error.prototype) && "cause"in t && !isEnumerable.call(t, "cause") ? "{ [" + String(t) + "] " + $join.call($concat.call("[cause]: " + d(t.cause), S), ", ") + " }" : S.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + $join.call(S, ", ") + " }"
    }
    if (typeof t == "object" && s) {
        if (inspectSymbol && typeof t[inspectSymbol] == "function" && utilInspect)
            return utilInspect(t, {
                depth: c - n
            });
        if (s !== "symbol" && typeof t.inspect == "function")
            return t.inspect()
    }
    if (isMap(t)) {
        var C = [];
        return mapForEach && mapForEach.call(t, function(A, B) {
            C.push(d(B, t, !0) + " => " + d(A, t))
        }),
        collectionOf("Map", mapSize.call(t), C, f)
    }
    if (isSet(t)) {
        var x = [];
        return setForEach && setForEach.call(t, function(A) {
            x.push(d(A, t))
        }),
        collectionOf("Set", setSize.call(t), x, f)
    }
    if (isWeakMap(t))
        return weakCollectionOf("WeakMap");
    if (isWeakSet(t))
        return weakCollectionOf("WeakSet");
    if (isWeakRef(t))
        return weakCollectionOf("WeakRef");
    if (isNumber(t))
        return markBoxed(d(Number(t)));
    if (isBigInt(t))
        return markBoxed(d(bigIntValueOf.call(t)));
    if (isBoolean(t))
        return markBoxed(booleanValueOf.call(t));
    if (isString(t))
        return markBoxed(d(String(t)));
    if (typeof window < "u" && t === window)
        return "{ [object Window] }";
    if (t === commonjsGlobal)
        return "{ [object globalThis] }";
    if (!isDate(t) && !isRegExp$1(t)) {
        var E = arrObjKeys(t, d)
          , I = gPO ? gPO(t) === Object.prototype : t instanceof Object || t.constructor === Object
          , M = t instanceof Object ? "" : "null prototype"
          , w = !I && toStringTag && Object(t) === t && toStringTag in t ? $slice.call(toStr(t), 8, -1) : M ? "Object" : ""
          , T = I || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : ""
          , k = T + (w || M ? "[" + $join.call($concat.call([], w || [], M || []), ": ") + "] " : "");
        return E.length === 0 ? k + "{}" : f ? k + "{" + indentedJoin(E, f) + "}" : k + "{ " + $join.call(E, ", ") + " }"
    }
    return String(t)
};
function wrapQuotes(e, t, r) {
    var n = (r.quoteStyle || t) === "double" ? '"' : "'";
    return n + e + n
}
function quote(e) {
    return $replace.call(String(e), /"/g, "&quot;")
}
function isArray$3(e) {
    return toStr(e) === "[object Array]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isDate(e) {
    return toStr(e) === "[object Date]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isRegExp$1(e) {
    return toStr(e) === "[object RegExp]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isError(e) {
    return toStr(e) === "[object Error]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isString(e) {
    return toStr(e) === "[object String]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isNumber(e) {
    return toStr(e) === "[object Number]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isBoolean(e) {
    return toStr(e) === "[object Boolean]" && (!toStringTag || !(typeof e == "object" && toStringTag in e))
}
function isSymbol(e) {
    if (hasShammedSymbols)
        return e && typeof e == "object" && e instanceof Symbol;
    if (typeof e == "symbol")
        return !0;
    if (!e || typeof e != "object" || !symToString)
        return !1;
    try {
        return symToString.call(e),
        !0
    } catch {}
    return !1
}
function isBigInt(e) {
    if (!e || typeof e != "object" || !bigIntValueOf)
        return !1;
    try {
        return bigIntValueOf.call(e),
        !0
    } catch {}
    return !1
}
var hasOwn = Object.prototype.hasOwnProperty || function(e) {
    return e in this
}
;
function has$3(e, t) {
    return hasOwn.call(e, t)
}
function toStr(e) {
    return objectToString.call(e)
}
function nameOf(e) {
    if (e.name)
        return e.name;
    var t = $match.call(functionToString.call(e), /^function\s*([\w$]+)/);
    return t ? t[1] : null
}
function indexOf(e, t) {
    if (e.indexOf)
        return e.indexOf(t);
    for (var r = 0, n = e.length; r < n; r++)
        if (e[r] === t)
            return r;
    return -1
}
function isMap(e) {
    if (!mapSize || !e || typeof e != "object")
        return !1;
    try {
        mapSize.call(e);
        try {
            setSize.call(e)
        } catch {
            return !0
        }
        return e instanceof Map
    } catch {}
    return !1
}
function isWeakMap(e) {
    if (!weakMapHas || !e || typeof e != "object")
        return !1;
    try {
        weakMapHas.call(e, weakMapHas);
        try {
            weakSetHas.call(e, weakSetHas)
        } catch {
            return !0
        }
        return e instanceof WeakMap
    } catch {}
    return !1
}
function isWeakRef(e) {
    if (!weakRefDeref || !e || typeof e != "object")
        return !1;
    try {
        return weakRefDeref.call(e),
        !0
    } catch {}
    return !1
}
function isSet(e) {
    if (!setSize || !e || typeof e != "object")
        return !1;
    try {
        setSize.call(e);
        try {
            mapSize.call(e)
        } catch {
            return !0
        }
        return e instanceof Set
    } catch {}
    return !1
}
function isWeakSet(e) {
    if (!weakSetHas || !e || typeof e != "object")
        return !1;
    try {
        weakSetHas.call(e, weakSetHas);
        try {
            weakMapHas.call(e, weakMapHas)
        } catch {
            return !0
        }
        return e instanceof WeakSet
    } catch {}
    return !1
}
function isElement(e) {
    return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function"
}
function inspectString(e, t) {
    if (e.length > t.maxStringLength) {
        var r = e.length - t.maxStringLength
          , n = "... " + r + " more character" + (r > 1 ? "s" : "");
        return inspectString($slice.call(e, 0, t.maxStringLength), t) + n
    }
    var o = $replace.call($replace.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(o, "single", t)
}
function lowbyte(e) {
    var t = e.charCodeAt(0)
      , r = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + $toUpperCase.call(t.toString(16))
}
function markBoxed(e) {
    return "Object(" + e + ")"
}
function weakCollectionOf(e) {
    return e + " { ? }"
}
function collectionOf(e, t, r, n) {
    var o = n ? indentedJoin(r, n) : $join.call(r, ", ");
    return e + " (" + t + ") {" + o + "}"
}
function singleLineValues(e) {
    for (var t = 0; t < e.length; t++)
        if (indexOf(e[t], `
`) >= 0)
            return !1;
    return !0
}
function getIndent(e, t) {
    var r;
    if (e.indent === "	")
        r = "	";
    else if (typeof e.indent == "number" && e.indent > 0)
        r = $join.call(Array(e.indent + 1), " ");
    else
        return null;
    return {
        base: r,
        prev: $join.call(Array(t + 1), r)
    }
}
function indentedJoin(e, t) {
    if (e.length === 0)
        return "";
    var r = `
` + t.prev + t.base;
    return r + $join.call(e, "," + r) + `
` + t.prev
}
function arrObjKeys(e, t) {
    var r = isArray$3(e)
      , n = [];
    if (r) {
        n.length = e.length;
        for (var o = 0; o < e.length; o++)
            n[o] = has$3(e, o) ? t(e[o], e) : ""
    }
    var a = typeof gOPS == "function" ? gOPS(e) : [], s;
    if (hasShammedSymbols) {
        s = {};
        for (var i = 0; i < a.length; i++)
            s["$" + a[i]] = a[i]
    }
    for (var l in e)
        has$3(e, l) && (r && String(Number(l)) === l && l < e.length || hasShammedSymbols && s["$" + l]instanceof Symbol || ($test.call(/[^\w$]/, l) ? n.push(t(l, e) + ": " + t(e[l], e)) : n.push(l + ": " + t(e[l], e))));
    if (typeof gOPS == "function")
        for (var u = 0; u < a.length; u++)
            isEnumerable.call(e, a[u]) && n.push("[" + t(a[u]) + "]: " + t(e[a[u]], e));
    return n
}
var GetIntrinsic = getIntrinsic
  , callBound = callBound$1
  , inspect = objectInspect
  , $TypeError = GetIntrinsic("%TypeError%")
  , $WeakMap = GetIntrinsic("%WeakMap%", !0)
  , $Map = GetIntrinsic("%Map%", !0)
  , $weakMapGet = callBound("WeakMap.prototype.get", !0)
  , $weakMapSet = callBound("WeakMap.prototype.set", !0)
  , $weakMapHas = callBound("WeakMap.prototype.has", !0)
  , $mapGet = callBound("Map.prototype.get", !0)
  , $mapSet = callBound("Map.prototype.set", !0)
  , $mapHas = callBound("Map.prototype.has", !0)
  , listGetNode = function(e, t) {
    for (var r = e, n; (n = r.next) !== null; r = n)
        if (n.key === t)
            return r.next = n.next,
            n.next = e.next,
            e.next = n,
            n
}
  , listGet = function(e, t) {
    var r = listGetNode(e, t);
    return r && r.value
}
  , listSet = function(e, t, r) {
    var n = listGetNode(e, t);
    n ? n.value = r : e.next = {
        key: t,
        next: e.next,
        value: r
    }
}
  , listHas = function(e, t) {
    return !!listGetNode(e, t)
}
  , sideChannel = function() {
    var t, r, n, o = {
        assert: function(a) {
            if (!o.has(a))
                throw new $TypeError("Side channel does not contain " + inspect(a))
        },
        get: function(a) {
            if ($WeakMap && a && (typeof a == "object" || typeof a == "function")) {
                if (t)
                    return $weakMapGet(t, a)
            } else if ($Map) {
                if (r)
                    return $mapGet(r, a)
            } else if (n)
                return listGet(n, a)
        },
        has: function(a) {
            if ($WeakMap && a && (typeof a == "object" || typeof a == "function")) {
                if (t)
                    return $weakMapHas(t, a)
            } else if ($Map) {
                if (r)
                    return $mapHas(r, a)
            } else if (n)
                return listHas(n, a);
            return !1
        },
        set: function(a, s) {
            $WeakMap && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new $WeakMap),
            $weakMapSet(t, a, s)) : $Map ? (r || (r = new $Map),
            $mapSet(r, a, s)) : (n || (n = {
                key: {},
                next: null
            }),
            listSet(n, a, s))
        }
    };
    return o
}
  , replace = String.prototype.replace
  , percentTwenties = /%20/g
  , Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}
  , formats$3 = {
    default: Format.RFC3986,
    formatters: {
        RFC1738: function(e) {
            return replace.call(e, percentTwenties, "+")
        },
        RFC3986: function(e) {
            return String(e)
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
}
  , formats$2 = formats$3
  , has$2 = Object.prototype.hasOwnProperty
  , isArray$2 = Array.isArray
  , hexTable = function() {
    for (var e = [], t = 0; t < 256; ++t)
        e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e
}()
  , compactQueue = function(t) {
    for (; t.length > 1; ) {
        var r = t.pop()
          , n = r.obj[r.prop];
        if (isArray$2(n)) {
            for (var o = [], a = 0; a < n.length; ++a)
                typeof n[a] < "u" && o.push(n[a]);
            r.obj[r.prop] = o
        }
    }
}
  , arrayToObject = function(t, r) {
    for (var n = r && r.plainObjects ? Object.create(null) : {}, o = 0; o < t.length; ++o)
        typeof t[o] < "u" && (n[o] = t[o]);
    return n
}
  , merge = function e(t, r, n) {
    if (!r)
        return t;
    if (typeof r != "object") {
        if (isArray$2(t))
            t.push(r);
        else if (t && typeof t == "object")
            (n && (n.plainObjects || n.allowPrototypes) || !has$2.call(Object.prototype, r)) && (t[r] = !0);
        else
            return [t, r];
        return t
    }
    if (!t || typeof t != "object")
        return [t].concat(r);
    var o = t;
    return isArray$2(t) && !isArray$2(r) && (o = arrayToObject(t, n)),
    isArray$2(t) && isArray$2(r) ? (r.forEach(function(a, s) {
        if (has$2.call(t, s)) {
            var i = t[s];
            i && typeof i == "object" && a && typeof a == "object" ? t[s] = e(i, a, n) : t.push(a)
        } else
            t[s] = a
    }),
    t) : Object.keys(r).reduce(function(a, s) {
        var i = r[s];
        return has$2.call(a, s) ? a[s] = e(a[s], i, n) : a[s] = i,
        a
    }, o)
}
  , assign = function(t, r) {
    return Object.keys(r).reduce(function(n, o) {
        return n[o] = r[o],
        n
    }, t)
}
  , decode = function(e, t, r) {
    var n = e.replace(/\+/g, " ");
    if (r === "iso-8859-1")
        return n.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(n)
    } catch {
        return n
    }
}
  , encode$1 = function(t, r, n, o, a) {
    if (t.length === 0)
        return t;
    var s = t;
    if (typeof t == "symbol" ? s = Symbol.prototype.toString.call(t) : typeof t != "string" && (s = String(t)),
    n === "iso-8859-1")
        return escape(s).replace(/%u[0-9a-f]{4}/gi, function(c) {
            return "%26%23" + parseInt(c.slice(2), 16) + "%3B"
        });
    for (var i = "", l = 0; l < s.length; ++l) {
        var u = s.charCodeAt(l);
        if (u === 45 || u === 46 || u === 95 || u === 126 || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || a === formats$2.RFC1738 && (u === 40 || u === 41)) {
            i += s.charAt(l);
            continue
        }
        if (u < 128) {
            i = i + hexTable[u];
            continue
        }
        if (u < 2048) {
            i = i + (hexTable[192 | u >> 6] + hexTable[128 | u & 63]);
            continue
        }
        if (u < 55296 || u >= 57344) {
            i = i + (hexTable[224 | u >> 12] + hexTable[128 | u >> 6 & 63] + hexTable[128 | u & 63]);
            continue
        }
        l += 1,
        u = 65536 + ((u & 1023) << 10 | s.charCodeAt(l) & 1023),
        i += hexTable[240 | u >> 18] + hexTable[128 | u >> 12 & 63] + hexTable[128 | u >> 6 & 63] + hexTable[128 | u & 63]
    }
    return i
}
  , compact = function(t) {
    for (var r = [{
        obj: {
            o: t
        },
        prop: "o"
    }], n = [], o = 0; o < r.length; ++o)
        for (var a = r[o], s = a.obj[a.prop], i = Object.keys(s), l = 0; l < i.length; ++l) {
            var u = i[l]
              , c = s[u];
            typeof c == "object" && c !== null && n.indexOf(c) === -1 && (r.push({
                obj: s,
                prop: u
            }),
            n.push(c))
        }
    return compactQueue(r),
    t
}
  , isRegExp = function(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
  , isBuffer = function(t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
}
  , combine = function(t, r) {
    return [].concat(t, r)
}
  , maybeMap = function(t, r) {
    if (isArray$2(t)) {
        for (var n = [], o = 0; o < t.length; o += 1)
            n.push(r(t[o]));
        return n
    }
    return r(t)
}
  , utils$2 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode,
    encode: encode$1,
    isBuffer,
    isRegExp,
    maybeMap,
    merge
}
  , getSideChannel = sideChannel
  , utils$1 = utils$2
  , formats$1 = formats$3
  , has$1 = Object.prototype.hasOwnProperty
  , arrayPrefixGenerators = {
    brackets: function(t) {
        return t + "[]"
    },
    comma: "comma",
    indices: function(t, r) {
        return t + "[" + r + "]"
    },
    repeat: function(t) {
        return t
    }
}
  , isArray$1 = Array.isArray
  , push = Array.prototype.push
  , pushToArray = function(e, t) {
    push.apply(e, isArray$1(t) ? t : [t])
}
  , toISO = Date.prototype.toISOString
  , defaultFormat = formats$1.default
  , defaults$1 = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: utils$1.encode,
    encodeValuesOnly: !1,
    format: defaultFormat,
    formatter: formats$1.formatters[defaultFormat],
    indices: !1,
    serializeDate: function(t) {
        return toISO.call(t)
    },
    skipNulls: !1,
    strictNullHandling: !1
}
  , isNonNullishPrimitive = function(t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint"
}
  , sentinel = {}
  , stringify$1 = function e(t, r, n, o, a, s, i, l, u, c, f, d, p, m, g, _) {
    for (var b = t, y = _, v = 0, S = !1; (y = y.get(sentinel)) !== void 0 && !S; ) {
        var C = y.get(t);
        if (v += 1,
        typeof C < "u") {
            if (C === v)
                throw new RangeError("Cyclic object value");
            S = !0
        }
        typeof y.get(sentinel) > "u" && (v = 0)
    }
    if (typeof l == "function" ? b = l(r, b) : b instanceof Date ? b = f(b) : n === "comma" && isArray$1(b) && (b = utils$1.maybeMap(b, function(P) {
        return P instanceof Date ? f(P) : P
    })),
    b === null) {
        if (a)
            return i && !m ? i(r, defaults$1.encoder, g, "key", d) : r;
        b = ""
    }
    if (isNonNullishPrimitive(b) || utils$1.isBuffer(b)) {
        if (i) {
            var x = m ? r : i(r, defaults$1.encoder, g, "key", d);
            return [p(x) + "=" + p(i(b, defaults$1.encoder, g, "value", d))]
        }
        return [p(r) + "=" + p(String(b))]
    }
    var E = [];
    if (typeof b > "u")
        return E;
    var I;
    if (n === "comma" && isArray$1(b))
        m && i && (b = utils$1.maybeMap(b, i)),
        I = [{
            value: b.length > 0 ? b.join(",") || null : void 0
        }];
    else if (isArray$1(l))
        I = l;
    else {
        var M = Object.keys(b);
        I = u ? M.sort(u) : M
    }
    for (var w = o && isArray$1(b) && b.length === 1 ? r + "[]" : r, T = 0; T < I.length; ++T) {
        var k = I[T]
          , A = typeof k == "object" && typeof k.value < "u" ? k.value : b[k];
        if (!(s && A === null)) {
            var B = isArray$1(b) ? typeof n == "function" ? n(w, k) : w : w + (c ? "." + k : "[" + k + "]");
            _.set(t, v);
            var $ = getSideChannel();
            $.set(sentinel, _),
            pushToArray(E, e(A, B, n, o, a, s, n === "comma" && m && isArray$1(b) ? null : i, l, u, c, f, d, p, m, g, $))
        }
    }
    return E
}
  , normalizeStringifyOptions = function(t) {
    if (!t)
        return defaults$1;
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
        throw new TypeError("Encoder has to be a function.");
    var r = t.charset || defaults$1.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var n = formats$1.default;
    if (typeof t.format < "u") {
        if (!has$1.call(formats$1.formatters, t.format))
            throw new TypeError("Unknown format option provided.");
        n = t.format
    }
    var o = formats$1.formatters[n]
      , a = defaults$1.filter;
    return (typeof t.filter == "function" || isArray$1(t.filter)) && (a = t.filter),
    {
        addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : defaults$1.addQueryPrefix,
        allowDots: typeof t.allowDots > "u" ? defaults$1.allowDots : !!t.allowDots,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : defaults$1.charsetSentinel,
        delimiter: typeof t.delimiter > "u" ? defaults$1.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : defaults$1.encode,
        encoder: typeof t.encoder == "function" ? t.encoder : defaults$1.encoder,
        encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : defaults$1.encodeValuesOnly,
        filter: a,
        format: n,
        formatter: o,
        serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : defaults$1.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : defaults$1.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : defaults$1.strictNullHandling
    }
}
  , stringify_1 = function(e, t) {
    var r = e, n = normalizeStringifyOptions(t), o, a;
    typeof n.filter == "function" ? (a = n.filter,
    r = a("", r)) : isArray$1(n.filter) && (a = n.filter,
    o = a);
    var s = [];
    if (typeof r != "object" || r === null)
        return "";
    var i;
    t && t.arrayFormat in arrayPrefixGenerators ? i = t.arrayFormat : t && "indices"in t ? i = t.indices ? "indices" : "repeat" : i = "indices";
    var l = arrayPrefixGenerators[i];
    if (t && "commaRoundTrip"in t && typeof t.commaRoundTrip != "boolean")
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var u = l === "comma" && t && t.commaRoundTrip;
    o || (o = Object.keys(r)),
    n.sort && o.sort(n.sort);
    for (var c = getSideChannel(), f = 0; f < o.length; ++f) {
        var d = o[f];
        n.skipNulls && r[d] === null || pushToArray(s, stringify$1(r[d], d, l, u, n.strictNullHandling, n.skipNulls, n.encode ? n.encoder : null, n.filter, n.sort, n.allowDots, n.serializeDate, n.format, n.formatter, n.encodeValuesOnly, n.charset, c))
    }
    var p = s.join(n.delimiter)
      , m = n.addQueryPrefix === !0 ? "?" : "";
    return n.charsetSentinel && (n.charset === "iso-8859-1" ? m += "utf8=%26%2310003%3B&" : m += "utf8=%E2%9C%93&"),
    p.length > 0 ? m + p : ""
}
  , utils = utils$2
  , has = Object.prototype.hasOwnProperty
  , isArray = Array.isArray
  , defaults = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1
}
  , interpretNumericEntities = function(e) {
    return e.replace(/&#(\d+);/g, function(t, r) {
        return String.fromCharCode(parseInt(r, 10))
    })
}
  , parseArrayValue = function(e, t) {
    return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e
}
  , isoSentinel = "utf8=%26%2310003%3B"
  , charsetSentinel = "utf8=%E2%9C%93"
  , parseValues = function(t, r) {
    var n = {
        __proto__: null
    }, o = r.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, a = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, s = o.split(r.delimiter, a), i = -1, l, u = r.charset;
    if (r.charsetSentinel)
        for (l = 0; l < s.length; ++l)
            s[l].indexOf("utf8=") === 0 && (s[l] === charsetSentinel ? u = "utf-8" : s[l] === isoSentinel && (u = "iso-8859-1"),
            i = l,
            l = s.length);
    for (l = 0; l < s.length; ++l)
        if (l !== i) {
            var c = s[l], f = c.indexOf("]="), d = f === -1 ? c.indexOf("=") : f + 1, p, m;
            d === -1 ? (p = r.decoder(c, defaults.decoder, u, "key"),
            m = r.strictNullHandling ? null : "") : (p = r.decoder(c.slice(0, d), defaults.decoder, u, "key"),
            m = utils.maybeMap(parseArrayValue(c.slice(d + 1), r), function(g) {
                return r.decoder(g, defaults.decoder, u, "value")
            })),
            m && r.interpretNumericEntities && u === "iso-8859-1" && (m = interpretNumericEntities(m)),
            c.indexOf("[]=") > -1 && (m = isArray(m) ? [m] : m),
            has.call(n, p) ? n[p] = utils.combine(n[p], m) : n[p] = m
        }
    return n
}
  , parseObject = function(e, t, r, n) {
    for (var o = n ? t : parseArrayValue(t, r), a = e.length - 1; a >= 0; --a) {
        var s, i = e[a];
        if (i === "[]" && r.parseArrays)
            s = [].concat(o);
        else {
            s = r.plainObjects ? Object.create(null) : {};
            var l = i.charAt(0) === "[" && i.charAt(i.length - 1) === "]" ? i.slice(1, -1) : i
              , u = parseInt(l, 10);
            !r.parseArrays && l === "" ? s = {
                0: o
            } : !isNaN(u) && i !== l && String(u) === l && u >= 0 && r.parseArrays && u <= r.arrayLimit ? (s = [],
            s[u] = o) : l !== "__proto__" && (s[l] = o)
        }
        o = s
    }
    return o
}
  , parseKeys = function(t, r, n, o) {
    if (t) {
        var a = n.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t
          , s = /(\[[^[\]]*])/
          , i = /(\[[^[\]]*])/g
          , l = n.depth > 0 && s.exec(a)
          , u = l ? a.slice(0, l.index) : a
          , c = [];
        if (u) {
            if (!n.plainObjects && has.call(Object.prototype, u) && !n.allowPrototypes)
                return;
            c.push(u)
        }
        for (var f = 0; n.depth > 0 && (l = i.exec(a)) !== null && f < n.depth; ) {
            if (f += 1,
            !n.plainObjects && has.call(Object.prototype, l[1].slice(1, -1)) && !n.allowPrototypes)
                return;
            c.push(l[1])
        }
        return l && c.push("[" + a.slice(l.index) + "]"),
        parseObject(c, r, n, o)
    }
}
  , normalizeParseOptions = function(t) {
    if (!t)
        return defaults;
    if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function")
        throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var r = typeof t.charset > "u" ? defaults.charset : t.charset;
    return {
        allowDots: typeof t.allowDots > "u" ? defaults.allowDots : !!t.allowDots,
        allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : defaults.allowSparse,
        arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : defaults.arrayLimit,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : defaults.charsetSentinel,
        comma: typeof t.comma == "boolean" ? t.comma : defaults.comma,
        decoder: typeof t.decoder == "function" ? t.decoder : defaults.decoder,
        delimiter: typeof t.delimiter == "string" || utils.isRegExp(t.delimiter) ? t.delimiter : defaults.delimiter,
        depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : defaults.depth,
        ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : defaults.parameterLimit,
        parseArrays: t.parseArrays !== !1,
        plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : defaults.strictNullHandling
    }
}
  , parse$1 = function(e, t) {
    var r = normalizeParseOptions(t);
    if (e === "" || e === null || typeof e > "u")
        return r.plainObjects ? Object.create(null) : {};
    for (var n = typeof e == "string" ? parseValues(e, r) : e, o = r.plainObjects ? Object.create(null) : {}, a = Object.keys(n), s = 0; s < a.length; ++s) {
        var i = a[s]
          , l = parseKeys(i, n[i], r, typeof e == "string");
        o = utils.merge(o, l, r)
    }
    return r.allowSparse === !0 ? o : utils.compact(o)
}
  , stringify = stringify_1
  , parse = parse$1
  , formats = formats$3
  , lib = {
    formats,
    parse,
    stringify
};
function handler() {
    let e = "";
    return typeof useRoute$1().meta.PMRedirectPath == "string" ? e = useRoute$1().meta.PMRedirectPath : typeof useRoute$1().meta.PMRedirectPath == "function" ? e = useRoute$1().meta.PMRedirectPath(useRoute$1()) : typeof useRoute$1().meta.PMRedirectPath == "boolean" && (e = useRoute$1().path),
    e
}
const useDevice = () => useNuxtApp().$device
  , useEnvStore = defineStore("env", {
    state: () => ({
        isPc: !0,
        isMobile: !1,
        a: "",
        fromApp: !1,
        fromWx: !1,
        fromLCDS: !1,
        appVersion: "",
        fromWeApp: !1,
        fromPubWeApp: !1,
        isHarmonyApp: !1,
        platform: "",
        transType: "",
        vPermit: !1
    }),
    getters: {
        isMiniProgram() {
            return this.fromWeApp || this.fromPubWeApp
        }
    }
})
  , _01_pc_mobile_redirect_TYARZqG7C1 = defineNuxtPlugin({
    name: "pc-mobile-redirect",
    setup() {
        if (!useRoute$1().meta.PMRedirectPath)
            return;
        let e = handler();
        if (!e || useRoute$1().query.is_preview || /MicroMessenger.+WindowsWechat/mi.test(useDevice().userAgent) || /Tablet; OpenHarmony/.test(useDevice().userAgent) && useEnvStore().isMobile)
            return;
        const t = useDevice().isMobile
          , r = useDevice().isApple && useDevice().isDesktopOrTablet || !useDevice().isApple && useDevice().isDesktop;
        if (useEnvStore().isPc && t || useEnvStore().isMobile && r) {
            if (!e.startsWith("http")) {
                const n = uXpConfig().mobileHost;
                e = uXpUrlParamsJoin(n + e, lib.stringify(useRoute$1().query))
            }
            navigateTo(e, {
                external: !0,
                redirectCode: 302
            })
        }
    }
});
var md5$1 = {
    exports: {}
};
function commonjsRequire(e) {
    throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var core = {
    exports: {}
}, hasRequiredCore;
function requireCore() {
    return hasRequiredCore || (hasRequiredCore = 1,
    function(e, t) {
        (function(r, n) {
            e.exports = n()
        }
        )(commonjsGlobal, function() {
            var r = r || function(n, o) {
                var a;
                if (typeof window < "u" && window.crypto && (a = window.crypto),
                typeof self < "u" && self.crypto && (a = self.crypto),
                typeof globalThis < "u" && globalThis.crypto && (a = globalThis.crypto),
                !a && typeof window < "u" && window.msCrypto && (a = window.msCrypto),
                !a && typeof commonjsGlobal < "u" && commonjsGlobal.crypto && (a = commonjsGlobal.crypto),
                !a && typeof commonjsRequire == "function")
                    try {
                        a = require$$0
                    } catch {}
                var s = function() {
                    if (a) {
                        if (typeof a.getRandomValues == "function")
                            try {
                                return a.getRandomValues(new Uint32Array(1))[0]
                            } catch {}
                        if (typeof a.randomBytes == "function")
                            try {
                                return a.randomBytes(4).readInt32LE()
                            } catch {}
                    }
                    throw new Error("Native crypto module could not be used to get secure random number.")
                }
                  , i = Object.create || function() {
                    function y() {}
                    return function(v) {
                        var S;
                        return y.prototype = v,
                        S = new y,
                        y.prototype = null,
                        S
                    }
                }()
                  , l = {}
                  , u = l.lib = {}
                  , c = u.Base = function() {
                    return {
                        extend: function(y) {
                            var v = i(this);
                            return y && v.mixIn(y),
                            (!v.hasOwnProperty("init") || this.init === v.init) && (v.init = function() {
                                v.$super.init.apply(this, arguments)
                            }
                            ),
                            v.init.prototype = v,
                            v.$super = this,
                            v
                        },
                        create: function() {
                            var y = this.extend();
                            return y.init.apply(y, arguments),
                            y
                        },
                        init: function() {},
                        mixIn: function(y) {
                            for (var v in y)
                                y.hasOwnProperty(v) && (this[v] = y[v]);
                            y.hasOwnProperty("toString") && (this.toString = y.toString)
                        },
                        clone: function() {
                            return this.init.prototype.extend(this)
                        }
                    }
                }()
                  , f = u.WordArray = c.extend({
                    init: function(y, v) {
                        y = this.words = y || [],
                        v != o ? this.sigBytes = v : this.sigBytes = y.length * 4
                    },
                    toString: function(y) {
                        return (y || p).stringify(this)
                    },
                    concat: function(y) {
                        var v = this.words
                          , S = y.words
                          , C = this.sigBytes
                          , x = y.sigBytes;
                        if (this.clamp(),
                        C % 4)
                            for (var E = 0; E < x; E++) {
                                var I = S[E >>> 2] >>> 24 - E % 4 * 8 & 255;
                                v[C + E >>> 2] |= I << 24 - (C + E) % 4 * 8
                            }
                        else
                            for (var M = 0; M < x; M += 4)
                                v[C + M >>> 2] = S[M >>> 2];
                        return this.sigBytes += x,
                        this
                    },
                    clamp: function() {
                        var y = this.words
                          , v = this.sigBytes;
                        y[v >>> 2] &= 4294967295 << 32 - v % 4 * 8,
                        y.length = n.ceil(v / 4)
                    },
                    clone: function() {
                        var y = c.clone.call(this);
                        return y.words = this.words.slice(0),
                        y
                    },
                    random: function(y) {
                        for (var v = [], S = 0; S < y; S += 4)
                            v.push(s());
                        return new f.init(v,y)
                    }
                })
                  , d = l.enc = {}
                  , p = d.Hex = {
                    stringify: function(y) {
                        for (var v = y.words, S = y.sigBytes, C = [], x = 0; x < S; x++) {
                            var E = v[x >>> 2] >>> 24 - x % 4 * 8 & 255;
                            C.push((E >>> 4).toString(16)),
                            C.push((E & 15).toString(16))
                        }
                        return C.join("")
                    },
                    parse: function(y) {
                        for (var v = y.length, S = [], C = 0; C < v; C += 2)
                            S[C >>> 3] |= parseInt(y.substr(C, 2), 16) << 24 - C % 8 * 4;
                        return new f.init(S,v / 2)
                    }
                }
                  , m = d.Latin1 = {
                    stringify: function(y) {
                        for (var v = y.words, S = y.sigBytes, C = [], x = 0; x < S; x++) {
                            var E = v[x >>> 2] >>> 24 - x % 4 * 8 & 255;
                            C.push(String.fromCharCode(E))
                        }
                        return C.join("")
                    },
                    parse: function(y) {
                        for (var v = y.length, S = [], C = 0; C < v; C++)
                            S[C >>> 2] |= (y.charCodeAt(C) & 255) << 24 - C % 4 * 8;
                        return new f.init(S,v)
                    }
                }
                  , g = d.Utf8 = {
                    stringify: function(y) {
                        try {
                            return decodeURIComponent(escape(m.stringify(y)))
                        } catch {
                            throw new Error("Malformed UTF-8 data")
                        }
                    },
                    parse: function(y) {
                        return m.parse(unescape(encodeURIComponent(y)))
                    }
                }
                  , _ = u.BufferedBlockAlgorithm = c.extend({
                    reset: function() {
                        this._data = new f.init,
                        this._nDataBytes = 0
                    },
                    _append: function(y) {
                        typeof y == "string" && (y = g.parse(y)),
                        this._data.concat(y),
                        this._nDataBytes += y.sigBytes
                    },
                    _process: function(y) {
                        var v, S = this._data, C = S.words, x = S.sigBytes, E = this.blockSize, I = E * 4, M = x / I;
                        y ? M = n.ceil(M) : M = n.max((M | 0) - this._minBufferSize, 0);
                        var w = M * E
                          , T = n.min(w * 4, x);
                        if (w) {
                            for (var k = 0; k < w; k += E)
                                this._doProcessBlock(C, k);
                            v = C.splice(0, w),
                            S.sigBytes -= T
                        }
                        return new f.init(v,T)
                    },
                    clone: function() {
                        var y = c.clone.call(this);
                        return y._data = this._data.clone(),
                        y
                    },
                    _minBufferSize: 0
                });
                u.Hasher = _.extend({
                    cfg: c.extend(),
                    init: function(y) {
                        this.cfg = this.cfg.extend(y),
                        this.reset()
                    },
                    reset: function() {
                        _.reset.call(this),
                        this._doReset()
                    },
                    update: function(y) {
                        return this._append(y),
                        this._process(),
                        this
                    },
                    finalize: function(y) {
                        y && this._append(y);
                        var v = this._doFinalize();
                        return v
                    },
                    blockSize: 16,
                    _createHelper: function(y) {
                        return function(v, S) {
                            return new y.init(S).finalize(v)
                        }
                    },
                    _createHmacHelper: function(y) {
                        return function(v, S) {
                            return new b.HMAC.init(y,S).finalize(v)
                        }
                    }
                });
                var b = l.algo = {};
                return l
            }(Math);
            return r
        })
    }(core)),
    core.exports
}
(function(e, t) {
    (function(r, n) {
        e.exports = n(requireCore())
    }
    )(commonjsGlobal, function(r) {
        return function(n) {
            var o = r
              , a = o.lib
              , s = a.WordArray
              , i = a.Hasher
              , l = o.algo
              , u = [];
            (function() {
                for (var g = 0; g < 64; g++)
                    u[g] = n.abs(n.sin(g + 1)) * 4294967296 | 0
            }
            )();
            var c = l.MD5 = i.extend({
                _doReset: function() {
                    this._hash = new s.init([1732584193, 4023233417, 2562383102, 271733878])
                },
                _doProcessBlock: function(g, _) {
                    for (var b = 0; b < 16; b++) {
                        var y = _ + b
                          , v = g[y];
                        g[y] = (v << 8 | v >>> 24) & 16711935 | (v << 24 | v >>> 8) & 4278255360
                    }
                    var S = this._hash.words
                      , C = g[_ + 0]
                      , x = g[_ + 1]
                      , E = g[_ + 2]
                      , I = g[_ + 3]
                      , M = g[_ + 4]
                      , w = g[_ + 5]
                      , T = g[_ + 6]
                      , k = g[_ + 7]
                      , A = g[_ + 8]
                      , B = g[_ + 9]
                      , $ = g[_ + 10]
                      , P = g[_ + 11]
                      , N = g[_ + 12]
                      , H = g[_ + 13]
                      , G = g[_ + 14]
                      , X = g[_ + 15]
                      , R = S[0]
                      , F = S[1]
                      , L = S[2]
                      , D = S[3];
                    R = f(R, F, L, D, C, 7, u[0]),
                    D = f(D, R, F, L, x, 12, u[1]),
                    L = f(L, D, R, F, E, 17, u[2]),
                    F = f(F, L, D, R, I, 22, u[3]),
                    R = f(R, F, L, D, M, 7, u[4]),
                    D = f(D, R, F, L, w, 12, u[5]),
                    L = f(L, D, R, F, T, 17, u[6]),
                    F = f(F, L, D, R, k, 22, u[7]),
                    R = f(R, F, L, D, A, 7, u[8]),
                    D = f(D, R, F, L, B, 12, u[9]),
                    L = f(L, D, R, F, $, 17, u[10]),
                    F = f(F, L, D, R, P, 22, u[11]),
                    R = f(R, F, L, D, N, 7, u[12]),
                    D = f(D, R, F, L, H, 12, u[13]),
                    L = f(L, D, R, F, G, 17, u[14]),
                    F = f(F, L, D, R, X, 22, u[15]),
                    R = d(R, F, L, D, x, 5, u[16]),
                    D = d(D, R, F, L, T, 9, u[17]),
                    L = d(L, D, R, F, P, 14, u[18]),
                    F = d(F, L, D, R, C, 20, u[19]),
                    R = d(R, F, L, D, w, 5, u[20]),
                    D = d(D, R, F, L, $, 9, u[21]),
                    L = d(L, D, R, F, X, 14, u[22]),
                    F = d(F, L, D, R, M, 20, u[23]),
                    R = d(R, F, L, D, B, 5, u[24]),
                    D = d(D, R, F, L, G, 9, u[25]),
                    L = d(L, D, R, F, I, 14, u[26]),
                    F = d(F, L, D, R, A, 20, u[27]),
                    R = d(R, F, L, D, H, 5, u[28]),
                    D = d(D, R, F, L, E, 9, u[29]),
                    L = d(L, D, R, F, k, 14, u[30]),
                    F = d(F, L, D, R, N, 20, u[31]),
                    R = p(R, F, L, D, w, 4, u[32]),
                    D = p(D, R, F, L, A, 11, u[33]),
                    L = p(L, D, R, F, P, 16, u[34]),
                    F = p(F, L, D, R, G, 23, u[35]),
                    R = p(R, F, L, D, x, 4, u[36]),
                    D = p(D, R, F, L, M, 11, u[37]),
                    L = p(L, D, R, F, k, 16, u[38]),
                    F = p(F, L, D, R, $, 23, u[39]),
                    R = p(R, F, L, D, H, 4, u[40]),
                    D = p(D, R, F, L, C, 11, u[41]),
                    L = p(L, D, R, F, I, 16, u[42]),
                    F = p(F, L, D, R, T, 23, u[43]),
                    R = p(R, F, L, D, B, 4, u[44]),
                    D = p(D, R, F, L, N, 11, u[45]),
                    L = p(L, D, R, F, X, 16, u[46]),
                    F = p(F, L, D, R, E, 23, u[47]),
                    R = m(R, F, L, D, C, 6, u[48]),
                    D = m(D, R, F, L, k, 10, u[49]),
                    L = m(L, D, R, F, G, 15, u[50]),
                    F = m(F, L, D, R, w, 21, u[51]),
                    R = m(R, F, L, D, N, 6, u[52]),
                    D = m(D, R, F, L, I, 10, u[53]),
                    L = m(L, D, R, F, $, 15, u[54]),
                    F = m(F, L, D, R, x, 21, u[55]),
                    R = m(R, F, L, D, A, 6, u[56]),
                    D = m(D, R, F, L, X, 10, u[57]),
                    L = m(L, D, R, F, T, 15, u[58]),
                    F = m(F, L, D, R, H, 21, u[59]),
                    R = m(R, F, L, D, M, 6, u[60]),
                    D = m(D, R, F, L, P, 10, u[61]),
                    L = m(L, D, R, F, E, 15, u[62]),
                    F = m(F, L, D, R, B, 21, u[63]),
                    S[0] = S[0] + R | 0,
                    S[1] = S[1] + F | 0,
                    S[2] = S[2] + L | 0,
                    S[3] = S[3] + D | 0
                },
                _doFinalize: function() {
                    var g = this._data
                      , _ = g.words
                      , b = this._nDataBytes * 8
                      , y = g.sigBytes * 8;
                    _[y >>> 5] |= 128 << 24 - y % 32;
                    var v = n.floor(b / 4294967296)
                      , S = b;
                    _[(y + 64 >>> 9 << 4) + 15] = (v << 8 | v >>> 24) & 16711935 | (v << 24 | v >>> 8) & 4278255360,
                    _[(y + 64 >>> 9 << 4) + 14] = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360,
                    g.sigBytes = (_.length + 1) * 4,
                    this._process();
                    for (var C = this._hash, x = C.words, E = 0; E < 4; E++) {
                        var I = x[E];
                        x[E] = (I << 8 | I >>> 24) & 16711935 | (I << 24 | I >>> 8) & 4278255360
                    }
                    return C
                },
                clone: function() {
                    var g = i.clone.call(this);
                    return g._hash = this._hash.clone(),
                    g
                }
            });
            function f(g, _, b, y, v, S, C) {
                var x = g + (_ & b | ~_ & y) + v + C;
                return (x << S | x >>> 32 - S) + _
            }
            function d(g, _, b, y, v, S, C) {
                var x = g + (_ & y | b & ~y) + v + C;
                return (x << S | x >>> 32 - S) + _
            }
            function p(g, _, b, y, v, S, C) {
                var x = g + (_ ^ b ^ y) + v + C;
                return (x << S | x >>> 32 - S) + _
            }
            function m(g, _, b, y, v, S, C) {
                var x = g + (b ^ (_ | ~y)) + v + C;
                return (x << S | x >>> 32 - S) + _
            }
            o.MD5 = i._createHelper(c),
            o.HmacMD5 = i._createHmacHelper(c)
        }(Math),
        r.MD5
    })
}
)(md5$1);
var md5Exports = md5$1.exports;
const md5 = getDefaultExportFromCjs(md5Exports);
var aes = {
    exports: {}
}, encBase64 = {
    exports: {}
}, hasRequiredEncBase64;
function requireEncBase64() {
    return hasRequiredEncBase64 || (hasRequiredEncBase64 = 1,
    function(e, t) {
        (function(r, n) {
            e.exports = n(requireCore())
        }
        )(commonjsGlobal, function(r) {
            return function() {
                var n = r
                  , o = n.lib
                  , a = o.WordArray
                  , s = n.enc;
                s.Base64 = {
                    stringify: function(l) {
                        var u = l.words
                          , c = l.sigBytes
                          , f = this._map;
                        l.clamp();
                        for (var d = [], p = 0; p < c; p += 3)
                            for (var m = u[p >>> 2] >>> 24 - p % 4 * 8 & 255, g = u[p + 1 >>> 2] >>> 24 - (p + 1) % 4 * 8 & 255, _ = u[p + 2 >>> 2] >>> 24 - (p + 2) % 4 * 8 & 255, b = m << 16 | g << 8 | _, y = 0; y < 4 && p + y * .75 < c; y++)
                                d.push(f.charAt(b >>> 6 * (3 - y) & 63));
                        var v = f.charAt(64);
                        if (v)
                            for (; d.length % 4; )
                                d.push(v);
                        return d.join("")
                    },
                    parse: function(l) {
                        var u = l.length
                          , c = this._map
                          , f = this._reverseMap;
                        if (!f) {
                            f = this._reverseMap = [];
                            for (var d = 0; d < c.length; d++)
                                f[c.charCodeAt(d)] = d
                        }
                        var p = c.charAt(64);
                        if (p) {
                            var m = l.indexOf(p);
                            m !== -1 && (u = m)
                        }
                        return i(l, u, f)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                };
                function i(l, u, c) {
                    for (var f = [], d = 0, p = 0; p < u; p++)
                        if (p % 4) {
                            var m = c[l.charCodeAt(p - 1)] << p % 4 * 2
                              , g = c[l.charCodeAt(p)] >>> 6 - p % 4 * 2
                              , _ = m | g;
                            f[d >>> 2] |= _ << 24 - d % 4 * 8,
                            d++
                        }
                    return a.create(f, d)
                }
            }(),
            r.enc.Base64
        })
    }(encBase64)),
    encBase64.exports
}
var evpkdf = {
    exports: {}
}
  , sha1 = {
    exports: {}
};
(function(e, t) {
    (function(r, n) {
        e.exports = n(requireCore())
    }
    )(commonjsGlobal, function(r) {
        return function() {
            var n = r
              , o = n.lib
              , a = o.WordArray
              , s = o.Hasher
              , i = n.algo
              , l = []
              , u = i.SHA1 = s.extend({
                _doReset: function() {
                    this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                },
                _doProcessBlock: function(c, f) {
                    for (var d = this._hash.words, p = d[0], m = d[1], g = d[2], _ = d[3], b = d[4], y = 0; y < 80; y++) {
                        if (y < 16)
                            l[y] = c[f + y] | 0;
                        else {
                            var v = l[y - 3] ^ l[y - 8] ^ l[y - 14] ^ l[y - 16];
                            l[y] = v << 1 | v >>> 31
                        }
                        var S = (p << 5 | p >>> 27) + b + l[y];
                        y < 20 ? S += (m & g | ~m & _) + 1518500249 : y < 40 ? S += (m ^ g ^ _) + 1859775393 : y < 60 ? S += (m & g | m & _ | g & _) - 1894007588 : S += (m ^ g ^ _) - 899497514,
                        b = _,
                        _ = g,
                        g = m << 30 | m >>> 2,
                        m = p,
                        p = S
                    }
                    d[0] = d[0] + p | 0,
                    d[1] = d[1] + m | 0,
                    d[2] = d[2] + g | 0,
                    d[3] = d[3] + _ | 0,
                    d[4] = d[4] + b | 0
                },
                _doFinalize: function() {
                    var c = this._data
                      , f = c.words
                      , d = this._nDataBytes * 8
                      , p = c.sigBytes * 8;
                    return f[p >>> 5] |= 128 << 24 - p % 32,
                    f[(p + 64 >>> 9 << 4) + 14] = Math.floor(d / 4294967296),
                    f[(p + 64 >>> 9 << 4) + 15] = d,
                    c.sigBytes = f.length * 4,
                    this._process(),
                    this._hash
                },
                clone: function() {
                    var c = s.clone.call(this);
                    return c._hash = this._hash.clone(),
                    c
                }
            });
            n.SHA1 = s._createHelper(u),
            n.HmacSHA1 = s._createHmacHelper(u)
        }(),
        r.SHA1
    })
}
)(sha1);
var sha1Exports = sha1.exports;
const SHA1 = getDefaultExportFromCjs(sha1Exports);
var hmac = {
    exports: {}
}, hasRequiredHmac;
function requireHmac() {
    return hasRequiredHmac || (hasRequiredHmac = 1,
    function(e, t) {
        (function(r, n) {
            e.exports = n(requireCore())
        }
        )(commonjsGlobal, function(r) {
            (function() {
                var n = r
                  , o = n.lib
                  , a = o.Base
                  , s = n.enc
                  , i = s.Utf8
                  , l = n.algo;
                l.HMAC = a.extend({
                    init: function(u, c) {
                        u = this._hasher = new u.init,
                        typeof c == "string" && (c = i.parse(c));
                        var f = u.blockSize
                          , d = f * 4;
                        c.sigBytes > d && (c = u.finalize(c)),
                        c.clamp();
                        for (var p = this._oKey = c.clone(), m = this._iKey = c.clone(), g = p.words, _ = m.words, b = 0; b < f; b++)
                            g[b] ^= 1549556828,
                            _[b] ^= 909522486;
                        p.sigBytes = m.sigBytes = d,
                        this.reset()
                    },
                    reset: function() {
                        var u = this._hasher;
                        u.reset(),
                        u.update(this._iKey)
                    },
                    update: function(u) {
                        return this._hasher.update(u),
                        this
                    },
                    finalize: function(u) {
                        var c = this._hasher
                          , f = c.finalize(u);
                        c.reset();
                        var d = c.finalize(this._oKey.clone().concat(f));
                        return d
                    }
                })
            }
            )()
        })
    }(hmac)),
    hmac.exports
}
var hasRequiredEvpkdf;
function requireEvpkdf() {
    return hasRequiredEvpkdf || (hasRequiredEvpkdf = 1,
    function(e, t) {
        (function(r, n, o) {
            e.exports = n(requireCore(), sha1Exports, requireHmac())
        }
        )(commonjsGlobal, function(r) {
            return function() {
                var n = r
                  , o = n.lib
                  , a = o.Base
                  , s = o.WordArray
                  , i = n.algo
                  , l = i.MD5
                  , u = i.EvpKDF = a.extend({
                    cfg: a.extend({
                        keySize: 128 / 32,
                        hasher: l,
                        iterations: 1
                    }),
                    init: function(c) {
                        this.cfg = this.cfg.extend(c)
                    },
                    compute: function(c, f) {
                        for (var d, p = this.cfg, m = p.hasher.create(), g = s.create(), _ = g.words, b = p.keySize, y = p.iterations; _.length < b; ) {
                            d && m.update(d),
                            d = m.update(c).finalize(f),
                            m.reset();
                            for (var v = 1; v < y; v++)
                                d = m.finalize(d),
                                m.reset();
                            g.concat(d)
                        }
                        return g.sigBytes = b * 4,
                        g
                    }
                });
                n.EvpKDF = function(c, f, d) {
                    return u.create(d).compute(c, f)
                }
            }(),
            r.EvpKDF
        })
    }(evpkdf)),
    evpkdf.exports
}
var cipherCore = {
    exports: {}
}, hasRequiredCipherCore;
function requireCipherCore() {
    return hasRequiredCipherCore || (hasRequiredCipherCore = 1,
    function(e, t) {
        (function(r, n, o) {
            e.exports = n(requireCore(), requireEvpkdf())
        }
        )(commonjsGlobal, function(r) {
            r.lib.Cipher || function(n) {
                var o = r
                  , a = o.lib
                  , s = a.Base
                  , i = a.WordArray
                  , l = a.BufferedBlockAlgorithm
                  , u = o.enc;
                u.Utf8;
                var c = u.Base64
                  , f = o.algo
                  , d = f.EvpKDF
                  , p = a.Cipher = l.extend({
                    cfg: s.extend(),
                    createEncryptor: function(w, T) {
                        return this.create(this._ENC_XFORM_MODE, w, T)
                    },
                    createDecryptor: function(w, T) {
                        return this.create(this._DEC_XFORM_MODE, w, T)
                    },
                    init: function(w, T, k) {
                        this.cfg = this.cfg.extend(k),
                        this._xformMode = w,
                        this._key = T,
                        this.reset()
                    },
                    reset: function() {
                        l.reset.call(this),
                        this._doReset()
                    },
                    process: function(w) {
                        return this._append(w),
                        this._process()
                    },
                    finalize: function(w) {
                        w && this._append(w);
                        var T = this._doFinalize();
                        return T
                    },
                    keySize: 128 / 32,
                    ivSize: 128 / 32,
                    _ENC_XFORM_MODE: 1,
                    _DEC_XFORM_MODE: 2,
                    _createHelper: function() {
                        function w(T) {
                            return typeof T == "string" ? M : x
                        }
                        return function(T) {
                            return {
                                encrypt: function(k, A, B) {
                                    return w(A).encrypt(T, k, A, B)
                                },
                                decrypt: function(k, A, B) {
                                    return w(A).decrypt(T, k, A, B)
                                }
                            }
                        }
                    }()
                });
                a.StreamCipher = p.extend({
                    _doFinalize: function() {
                        var w = this._process(!0);
                        return w
                    },
                    blockSize: 1
                });
                var m = o.mode = {}
                  , g = a.BlockCipherMode = s.extend({
                    createEncryptor: function(w, T) {
                        return this.Encryptor.create(w, T)
                    },
                    createDecryptor: function(w, T) {
                        return this.Decryptor.create(w, T)
                    },
                    init: function(w, T) {
                        this._cipher = w,
                        this._iv = T
                    }
                })
                  , _ = m.CBC = function() {
                    var w = g.extend();
                    w.Encryptor = w.extend({
                        processBlock: function(k, A) {
                            var B = this._cipher
                              , $ = B.blockSize;
                            T.call(this, k, A, $),
                            B.encryptBlock(k, A),
                            this._prevBlock = k.slice(A, A + $)
                        }
                    }),
                    w.Decryptor = w.extend({
                        processBlock: function(k, A) {
                            var B = this._cipher
                              , $ = B.blockSize
                              , P = k.slice(A, A + $);
                            B.decryptBlock(k, A),
                            T.call(this, k, A, $),
                            this._prevBlock = P
                        }
                    });
                    function T(k, A, B) {
                        var $, P = this._iv;
                        P ? ($ = P,
                        this._iv = n) : $ = this._prevBlock;
                        for (var N = 0; N < B; N++)
                            k[A + N] ^= $[N]
                    }
                    return w
                }()
                  , b = o.pad = {}
                  , y = b.Pkcs7 = {
                    pad: function(w, T) {
                        for (var k = T * 4, A = k - w.sigBytes % k, B = A << 24 | A << 16 | A << 8 | A, $ = [], P = 0; P < A; P += 4)
                            $.push(B);
                        var N = i.create($, A);
                        w.concat(N)
                    },
                    unpad: function(w) {
                        var T = w.words[w.sigBytes - 1 >>> 2] & 255;
                        w.sigBytes -= T
                    }
                };
                a.BlockCipher = p.extend({
                    cfg: p.cfg.extend({
                        mode: _,
                        padding: y
                    }),
                    reset: function() {
                        var w;
                        p.reset.call(this);
                        var T = this.cfg
                          , k = T.iv
                          , A = T.mode;
                        this._xformMode == this._ENC_XFORM_MODE ? w = A.createEncryptor : (w = A.createDecryptor,
                        this._minBufferSize = 1),
                        this._mode && this._mode.__creator == w ? this._mode.init(this, k && k.words) : (this._mode = w.call(A, this, k && k.words),
                        this._mode.__creator = w)
                    },
                    _doProcessBlock: function(w, T) {
                        this._mode.processBlock(w, T)
                    },
                    _doFinalize: function() {
                        var w, T = this.cfg.padding;
                        return this._xformMode == this._ENC_XFORM_MODE ? (T.pad(this._data, this.blockSize),
                        w = this._process(!0)) : (w = this._process(!0),
                        T.unpad(w)),
                        w
                    },
                    blockSize: 128 / 32
                });
                var v = a.CipherParams = s.extend({
                    init: function(w) {
                        this.mixIn(w)
                    },
                    toString: function(w) {
                        return (w || this.formatter).stringify(this)
                    }
                })
                  , S = o.format = {}
                  , C = S.OpenSSL = {
                    stringify: function(w) {
                        var T, k = w.ciphertext, A = w.salt;
                        return A ? T = i.create([1398893684, 1701076831]).concat(A).concat(k) : T = k,
                        T.toString(c)
                    },
                    parse: function(w) {
                        var T, k = c.parse(w), A = k.words;
                        return A[0] == 1398893684 && A[1] == 1701076831 && (T = i.create(A.slice(2, 4)),
                        A.splice(0, 4),
                        k.sigBytes -= 16),
                        v.create({
                            ciphertext: k,
                            salt: T
                        })
                    }
                }
                  , x = a.SerializableCipher = s.extend({
                    cfg: s.extend({
                        format: C
                    }),
                    encrypt: function(w, T, k, A) {
                        A = this.cfg.extend(A);
                        var B = w.createEncryptor(k, A)
                          , $ = B.finalize(T)
                          , P = B.cfg;
                        return v.create({
                            ciphertext: $,
                            key: k,
                            iv: P.iv,
                            algorithm: w,
                            mode: P.mode,
                            padding: P.padding,
                            blockSize: w.blockSize,
                            formatter: A.format
                        })
                    },
                    decrypt: function(w, T, k, A) {
                        A = this.cfg.extend(A),
                        T = this._parse(T, A.format);
                        var B = w.createDecryptor(k, A).finalize(T.ciphertext);
                        return B
                    },
                    _parse: function(w, T) {
                        return typeof w == "string" ? T.parse(w, this) : w
                    }
                })
                  , E = o.kdf = {}
                  , I = E.OpenSSL = {
                    execute: function(w, T, k, A, B) {
                        if (A || (A = i.random(64 / 8)),
                        B)
                            var $ = d.create({
                                keySize: T + k,
                                hasher: B
                            }).compute(w, A);
                        else
                            var $ = d.create({
                                keySize: T + k
                            }).compute(w, A);
                        var P = i.create($.words.slice(T), k * 4);
                        return $.sigBytes = T * 4,
                        v.create({
                            key: $,
                            iv: P,
                            salt: A
                        })
                    }
                }
                  , M = a.PasswordBasedCipher = x.extend({
                    cfg: x.cfg.extend({
                        kdf: I
                    }),
                    encrypt: function(w, T, k, A) {
                        A = this.cfg.extend(A);
                        var B = A.kdf.execute(k, w.keySize, w.ivSize, A.salt, A.hasher);
                        A.iv = B.iv;
                        var $ = x.encrypt.call(this, w, T, B.key, A);
                        return $.mixIn(B),
                        $
                    },
                    decrypt: function(w, T, k, A) {
                        A = this.cfg.extend(A),
                        T = this._parse(T, A.format);
                        var B = A.kdf.execute(k, w.keySize, w.ivSize, T.salt, A.hasher);
                        A.iv = B.iv;
                        var $ = x.decrypt.call(this, w, T, B.key, A);
                        return $
                    }
                })
            }()
        })
    }(cipherCore)),
    cipherCore.exports
}
(function(e, t) {
    (function(r, n, o) {
        e.exports = n(requireCore(), requireEncBase64(), md5Exports, requireEvpkdf(), requireCipherCore())
    }
    )(commonjsGlobal, function(r) {
        return function() {
            var n = r
              , o = n.lib
              , a = o.BlockCipher
              , s = n.algo
              , i = []
              , l = []
              , u = []
              , c = []
              , f = []
              , d = []
              , p = []
              , m = []
              , g = []
              , _ = [];
            (function() {
                for (var v = [], S = 0; S < 256; S++)
                    S < 128 ? v[S] = S << 1 : v[S] = S << 1 ^ 283;
                for (var C = 0, x = 0, S = 0; S < 256; S++) {
                    var E = x ^ x << 1 ^ x << 2 ^ x << 3 ^ x << 4;
                    E = E >>> 8 ^ E & 255 ^ 99,
                    i[C] = E,
                    l[E] = C;
                    var I = v[C]
                      , M = v[I]
                      , w = v[M]
                      , T = v[E] * 257 ^ E * 16843008;
                    u[C] = T << 24 | T >>> 8,
                    c[C] = T << 16 | T >>> 16,
                    f[C] = T << 8 | T >>> 24,
                    d[C] = T;
                    var T = w * 16843009 ^ M * 65537 ^ I * 257 ^ C * 16843008;
                    p[E] = T << 24 | T >>> 8,
                    m[E] = T << 16 | T >>> 16,
                    g[E] = T << 8 | T >>> 24,
                    _[E] = T,
                    C ? (C = I ^ v[v[v[w ^ I]]],
                    x ^= v[v[x]]) : C = x = 1
                }
            }
            )();
            var b = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
              , y = s.AES = a.extend({
                _doReset: function() {
                    var v;
                    if (!(this._nRounds && this._keyPriorReset === this._key)) {
                        for (var S = this._keyPriorReset = this._key, C = S.words, x = S.sigBytes / 4, E = this._nRounds = x + 6, I = (E + 1) * 4, M = this._keySchedule = [], w = 0; w < I; w++)
                            w < x ? M[w] = C[w] : (v = M[w - 1],
                            w % x ? x > 6 && w % x == 4 && (v = i[v >>> 24] << 24 | i[v >>> 16 & 255] << 16 | i[v >>> 8 & 255] << 8 | i[v & 255]) : (v = v << 8 | v >>> 24,
                            v = i[v >>> 24] << 24 | i[v >>> 16 & 255] << 16 | i[v >>> 8 & 255] << 8 | i[v & 255],
                            v ^= b[w / x | 0] << 24),
                            M[w] = M[w - x] ^ v);
                        for (var T = this._invKeySchedule = [], k = 0; k < I; k++) {
                            var w = I - k;
                            if (k % 4)
                                var v = M[w];
                            else
                                var v = M[w - 4];
                            k < 4 || w <= 4 ? T[k] = v : T[k] = p[i[v >>> 24]] ^ m[i[v >>> 16 & 255]] ^ g[i[v >>> 8 & 255]] ^ _[i[v & 255]]
                        }
                    }
                },
                encryptBlock: function(v, S) {
                    this._doCryptBlock(v, S, this._keySchedule, u, c, f, d, i)
                },
                decryptBlock: function(v, S) {
                    var C = v[S + 1];
                    v[S + 1] = v[S + 3],
                    v[S + 3] = C,
                    this._doCryptBlock(v, S, this._invKeySchedule, p, m, g, _, l);
                    var C = v[S + 1];
                    v[S + 1] = v[S + 3],
                    v[S + 3] = C
                },
                _doCryptBlock: function(v, S, C, x, E, I, M, w) {
                    for (var T = this._nRounds, k = v[S] ^ C[0], A = v[S + 1] ^ C[1], B = v[S + 2] ^ C[2], $ = v[S + 3] ^ C[3], P = 4, N = 1; N < T; N++) {
                        var H = x[k >>> 24] ^ E[A >>> 16 & 255] ^ I[B >>> 8 & 255] ^ M[$ & 255] ^ C[P++]
                          , G = x[A >>> 24] ^ E[B >>> 16 & 255] ^ I[$ >>> 8 & 255] ^ M[k & 255] ^ C[P++]
                          , X = x[B >>> 24] ^ E[$ >>> 16 & 255] ^ I[k >>> 8 & 255] ^ M[A & 255] ^ C[P++]
                          , R = x[$ >>> 24] ^ E[k >>> 16 & 255] ^ I[A >>> 8 & 255] ^ M[B & 255] ^ C[P++];
                        k = H,
                        A = G,
                        B = X,
                        $ = R
                    }
                    var H = (w[k >>> 24] << 24 | w[A >>> 16 & 255] << 16 | w[B >>> 8 & 255] << 8 | w[$ & 255]) ^ C[P++]
                      , G = (w[A >>> 24] << 24 | w[B >>> 16 & 255] << 16 | w[$ >>> 8 & 255] << 8 | w[k & 255]) ^ C[P++]
                      , X = (w[B >>> 24] << 24 | w[$ >>> 16 & 255] << 16 | w[k >>> 8 & 255] << 8 | w[A & 255]) ^ C[P++]
                      , R = (w[$ >>> 24] << 24 | w[k >>> 16 & 255] << 16 | w[A >>> 8 & 255] << 8 | w[B & 255]) ^ C[P++];
                    v[S] = H,
                    v[S + 1] = G,
                    v[S + 2] = X,
                    v[S + 3] = R
                },
                keySize: 256 / 32
            });
            n.AES = a._createHelper(y)
        }(),
        r.AES
    })
}
)(aes);
var aesExports = aes.exports;
const AES = getDefaultExportFromCjs(aesExports);
var encUtf8 = {
    exports: {}
};
(function(e, t) {
    (function(r, n) {
        e.exports = n(requireCore())
    }
    )(commonjsGlobal, function(r) {
        return r.enc.Utf8
    })
}
)(encUtf8);
var encUtf8Exports = encUtf8.exports;
const UTF8 = getDefaultExportFromCjs(encUtf8Exports);
var padPkcs7 = {
    exports: {}
};
(function(e, t) {
    (function(r, n, o) {
        e.exports = n(requireCore(), requireCipherCore())
    }
    )(commonjsGlobal, function(r) {
        return r.pad.Pkcs7
    })
}
)(padPkcs7);
var padPkcs7Exports = padPkcs7.exports;
const pkcs7 = getDefaultExportFromCjs(padPkcs7Exports)
  , DEFAULT_EXCLUDE_KEYS = ["class", "style"]
  , LISTENER_PREFIX = /^on[A-Z]/
  , useAttrs = (e={}) => {
    const {excludeListeners: t=!1, excludeKeys: r} = e
      , n = computed( () => ((r == null ? void 0 : r.value) || []).concat(DEFAULT_EXCLUDE_KEYS))
      , o = getCurrentInstance();
    return o ? computed( () => {
        var a;
        return fromPairs(Object.entries((a = o.proxy) == null ? void 0 : a.$attrs).filter( ([s]) => !n.value.includes(s) && !(t && LISTENER_PREFIX.test(s))))
    }
    ) : computed( () => ({}))
}
  , useDeprecated = ({from: e, replacement: t, scope: r, version: n, ref: o, type: a="API"}, s) => {
    watch( () => unref(s), i => {}
    , {
        immediate: !0
    })
}
  , useDraggable = (e, t, r, n) => {
    let o = {
        offsetX: 0,
        offsetY: 0
    };
    const a = u => {
        const c = u.clientX
          , f = u.clientY
          , {offsetX: d, offsetY: p} = o
          , m = e.value.getBoundingClientRect()
          , g = m.left
          , _ = m.top
          , b = m.width
          , y = m.height
          , v = document.documentElement.clientWidth
          , S = document.documentElement.clientHeight
          , C = -g + d
          , x = -_ + p
          , E = v - g - b + d
          , I = S - _ - y + p
          , M = T => {
            let k = d + T.clientX - c
              , A = p + T.clientY - f;
            n != null && n.value || (k = Math.min(Math.max(k, C), E),
            A = Math.min(Math.max(A, x), I)),
            o = {
                offsetX: k,
                offsetY: A
            },
            e.value && (e.value.style.transform = `translate(${addUnit(k)}, ${addUnit(A)})`)
        }
          , w = () => {
            document.removeEventListener("mousemove", M),
            document.removeEventListener("mouseup", w)
        }
        ;
        document.addEventListener("mousemove", M),
        document.addEventListener("mouseup", w)
    }
      , s = () => {
        t.value && e.value && t.value.addEventListener("mousedown", a)
    }
      , i = () => {
        t.value && e.value && t.value.removeEventListener("mousedown", a)
    }
      , l = () => {
        o = {
            offsetX: 0,
            offsetY: 0
        },
        e.value && (e.value.style.transform = "none")
    }
    ;
    return onMounted( () => {
        watchEffect( () => {
            r.value ? s() : i()
        }
        )
    }
    ),
    onBeforeUnmount( () => {
        i()
    }
    ),
    {
        resetPosition: l
    }
}
;
var zhCn$1 = {
    name: "zh-cn",
    el: {
        breadcrumb: {
            label: "面包屑"
        },
        colorpicker: {
            confirm: "确定",
            clear: "清空",
            defaultLabel: "颜色选择器",
            description: "当前颜色 {color}，按 Enter 键选择新颜色",
            alphaLabel: "选择透明度的值"
        },
        datepicker: {
            now: "此刻",
            today: "今天",
            cancel: "取消",
            clear: "清空",
            confirm: "确定",
            dateTablePrompt: "使用方向键与 Enter 键可选择日期",
            monthTablePrompt: "使用方向键与 Enter 键可选择月份",
            yearTablePrompt: "使用方向键与 Enter 键可选择年份",
            selectedDate: "已选日期",
            selectDate: "选择日期",
            selectTime: "选择时间",
            startDate: "开始日期",
            startTime: "开始时间",
            endDate: "结束日期",
            endTime: "结束时间",
            prevYear: "前一年",
            nextYear: "后一年",
            prevMonth: "上个月",
            nextMonth: "下个月",
            year: "年",
            month1: "1 月",
            month2: "2 月",
            month3: "3 月",
            month4: "4 月",
            month5: "5 月",
            month6: "6 月",
            month7: "7 月",
            month8: "8 月",
            month9: "9 月",
            month10: "10 月",
            month11: "11 月",
            month12: "12 月",
            weeks: {
                sun: "日",
                mon: "一",
                tue: "二",
                wed: "三",
                thu: "四",
                fri: "五",
                sat: "六"
            },
            weeksFull: {
                sun: "星期日",
                mon: "星期一",
                tue: "星期二",
                wed: "星期三",
                thu: "星期四",
                fri: "星期五",
                sat: "星期六"
            },
            months: {
                jan: "一月",
                feb: "二月",
                mar: "三月",
                apr: "四月",
                may: "五月",
                jun: "六月",
                jul: "七月",
                aug: "八月",
                sep: "九月",
                oct: "十月",
                nov: "十一月",
                dec: "十二月"
            }
        },
        inputNumber: {
            decrease: "减少数值",
            increase: "增加数值"
        },
        select: {
            loading: "加载中",
            noMatch: "无匹配数据",
            noData: "无数据",
            placeholder: "请选择"
        },
        dropdown: {
            toggleDropdown: "切换下拉选项"
        },
        mention: {
            loading: "加载中"
        },
        cascader: {
            noMatch: "无匹配数据",
            loading: "加载中",
            placeholder: "请选择",
            noData: "暂无数据"
        },
        pagination: {
            goto: "前往",
            pagesize: "条/页",
            total: "共 {total} 条",
            pageClassifier: "页",
            page: "页",
            prev: "上一页",
            next: "下一页",
            currentPage: "第 {pager} 页",
            prevPages: "向前 {pager} 页",
            nextPages: "向后 {pager} 页",
            deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
        },
        dialog: {
            close: "关闭此对话框"
        },
        drawer: {
            close: "关闭此对话框"
        },
        messagebox: {
            title: "提示",
            confirm: "确定",
            cancel: "取消",
            error: "输入的数据不合法!",
            close: "关闭此对话框"
        },
        upload: {
            deleteTip: "按 delete 键可删除",
            delete: "删除",
            preview: "查看图片",
            continue: "继续上传"
        },
        slider: {
            defaultLabel: "滑块介于 {min} 至 {max}",
            defaultRangeStartLabel: "选择起始值",
            defaultRangeEndLabel: "选择结束值"
        },
        table: {
            emptyText: "暂无数据",
            confirmFilter: "筛选",
            resetFilter: "重置",
            clearFilter: "全部",
            sumText: "合计"
        },
        tour: {
            next: "下一步",
            previous: "上一步",
            finish: "结束导览"
        },
        tree: {
            emptyText: "暂无数据"
        },
        transfer: {
            noMatch: "无匹配数据",
            noData: "无数据",
            titles: ["列表 1", "列表 2"],
            filterPlaceholder: "请输入搜索内容",
            noCheckedFormat: "共 {total} 项",
            hasCheckedFormat: "已选 {checked}/{total} 项"
        },
        image: {
            error: "加载失败"
        },
        pageHeader: {
            title: "返回"
        },
        popconfirm: {
            confirmButtonText: "确定",
            cancelButtonText: "取消"
        },
        carousel: {
            leftArrow: "上一张幻灯片",
            rightArrow: "下一张幻灯片",
            indicator: "幻灯片切换至索引 {index}"
        }
    }
};
const buildTranslator = e => (t, r) => translate(t, r, unref(e))
  , translate = (e, t, r) => get(r, e, e).replace(/\{(\w+)\}/g, (n, o) => {
    var a;
    return `${(a = t == null ? void 0 : t[o]) != null ? a : `{${o}}`}`
}
)
  , buildLocaleContext = e => {
    const t = computed( () => unref(e).name)
      , r = isRef(e) ? e : ref(e);
    return {
        lang: t,
        locale: r,
        t: buildTranslator(e)
    }
}
  , localeContextKey = Symbol("localeContextKey")
  , useLocale = e => {
    const t = e || inject(localeContextKey, ref());
    return buildLocaleContext(computed( () => t.value || zhCn$1))
}
  , useLockscreen = (e, t={}) => {
    isRef(e) || throwError("[useLockscreen]", "You need to pass a ref param to this function");
    const r = t.ns || useNamespace("popup")
      , n = computed( () => r.bm("parent", "hidden"));
    if (!isClient || hasClass(document.body, n.value))
        return;
    let o = 0
      , a = !1
      , s = "0";
    const i = () => {
        setTimeout( () => {
            typeof document > "u" || (removeClass(document == null ? void 0 : document.body, n.value),
            a && document && (document.body.style.width = s))
        }
        , 200)
    }
    ;
    watch(e, l => {
        if (!l) {
            i();
            return
        }
        a = !hasClass(document.body, n.value),
        a && (s = document.body.style.width),
        o = getScrollBarWidth(r.namespace.value);
        const u = document.documentElement.clientHeight < document.body.scrollHeight
          , c = getStyle(document.body, "overflowY");
        o > 0 && (u || c === "scroll") && a && (document.body.style.width = `calc(100% - ${o}px)`),
        addClass(document.body, n.value)
    }
    ),
    onScopeDispose( () => i())
}
  , useProp = e => {
    const t = getCurrentInstance();
    return computed( () => {
        var r, n;
        return (n = (r = t == null ? void 0 : t.proxy) == null ? void 0 : r.$props) == null ? void 0 : n[e]
    }
    )
}
  , useSameTarget = e => {
    if (!e)
        return {
            onClick: NOOP,
            onMousedown: NOOP,
            onMouseup: NOOP
        };
    let t = !1
      , r = !1;
    return {
        onClick: s => {
            t && r && e(s),
            t = r = !1
        }
        ,
        onMousedown: s => {
            t = s.target === s.currentTarget
        }
        ,
        onMouseup: s => {
            r = s.target === s.currentTarget
        }
    }
}
;
let registeredEscapeHandlers = [];
const cachedHandler = e => {
    const t = e;
    t.key === EVENT_CODE.esc && registeredEscapeHandlers.forEach(r => r(t))
}
  , useEscapeKeydown = e => {
    onMounted( () => {
        registeredEscapeHandlers.length === 0 && document.addEventListener("keydown", cachedHandler),
        isClient && registeredEscapeHandlers.push(e)
    }
    ),
    onBeforeUnmount( () => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter(t => t !== e),
        registeredEscapeHandlers.length === 0 && isClient && document.removeEventListener("keydown", cachedHandler)
    }
    )
}
;
function useCursor(e) {
    let t;
    function r() {
        if (e.value == null)
            return;
        const {selectionStart: o, selectionEnd: a, value: s} = e.value;
        if (o == null || a == null)
            return;
        const i = s.slice(0, Math.max(0, o))
          , l = s.slice(Math.max(0, a));
        t = {
            selectionStart: o,
            selectionEnd: a,
            value: s,
            beforeTxt: i,
            afterTxt: l
        }
    }
    function n() {
        if (e.value == null || t == null)
            return;
        const {value: o} = e.value
          , {beforeTxt: a, afterTxt: s, selectionStart: i} = t;
        if (a == null || s == null || i == null)
            return;
        let l = o.length;
        if (o.endsWith(s))
            l = o.length - s.length;
        else if (o.startsWith(a))
            l = a.length;
        else {
            const u = a[i - 1]
              , c = o.indexOf(u, i - 1);
            c !== -1 && (l = c + 1)
        }
        e.value.setSelectionRange(l, l)
    }
    return [r, n]
}
const useSizeProp = buildProp({
    type: String,
    values: componentSizes,
    required: !1
})
  , SIZE_INJECTION_KEY = Symbol("size")
  , useGlobalSize = () => {
    const e = inject(SIZE_INJECTION_KEY, {});
    return computed( () => unref(e.size) || "")
}
;
function useFocusController(e, {beforeFocus: t, afterFocus: r, beforeBlur: n, afterBlur: o}={}) {
    const a = getCurrentInstance()
      , {emit: s} = a
      , i = shallowRef()
      , l = ref(!1)
      , u = d => {
        isFunction(t) && t(d) || l.value || (l.value = !0,
        s("focus", d),
        r == null || r())
    }
      , c = d => {
        var p;
        isFunction(n) && n(d) || d.relatedTarget && ((p = i.value) != null && p.contains(d.relatedTarget)) || (l.value = !1,
        s("blur", d),
        o == null || o())
    }
      , f = () => {
        var d, p;
        (d = i.value) != null && d.contains(document.activeElement) && i.value !== document.activeElement || (p = e.value) == null || p.focus()
    }
    ;
    return watch(i, d => {
        d && d.setAttribute("tabindex", "-1")
    }
    ),
    useEventListener(i, "focus", u, !0),
    useEventListener(i, "blur", c, !0),
    useEventListener(i, "click", f, !0),
    {
        isFocused: l,
        wrapperRef: i,
        handleFocus: u,
        handleBlur: c
    }
}
function useComposition({afterComposition: e, emit: t}) {
    const r = ref(!1)
      , n = i => {
        t == null || t("compositionstart", i),
        r.value = !0
    }
      , o = i => {
        var l;
        t == null || t("compositionupdate", i);
        const u = (l = i.target) == null ? void 0 : l.value
          , c = u[u.length - 1] || "";
        r.value = !isKorean(c)
    }
      , a = i => {
        t == null || t("compositionend", i),
        r.value && (r.value = !1,
        nextTick( () => e(i)))
    }
    ;
    return {
        isComposing: r,
        handleComposition: i => {
            i.type === "compositionend" ? a(i) : o(i)
        }
        ,
        handleCompositionStart: n,
        handleCompositionUpdate: o,
        handleCompositionEnd: a
    }
}
const emptyValuesContextKey = Symbol("emptyValuesContextKey")
  , DEFAULT_EMPTY_VALUES = ["", void 0, null]
  , DEFAULT_VALUE_ON_CLEAR = void 0
  , useEmptyValuesProps = buildProps({
    emptyValues: Array,
    valueOnClear: {
        type: [String, Number, Boolean, Function],
        default: void 0,
        validator: e => isFunction(e) ? !e() : !e
    }
})
  , useEmptyValues = (e, t) => {
    const r = getCurrentInstance() ? inject(emptyValuesContextKey, ref({})) : ref({})
      , n = computed( () => e.emptyValues || r.value.emptyValues || DEFAULT_EMPTY_VALUES)
      , o = computed( () => isFunction(e.valueOnClear) ? e.valueOnClear() : e.valueOnClear !== void 0 ? e.valueOnClear : isFunction(r.value.valueOnClear) ? r.value.valueOnClear() : r.value.valueOnClear !== void 0 ? r.value.valueOnClear : t !== void 0 ? t : DEFAULT_VALUE_ON_CLEAR)
      , a = s => n.value.includes(s);
    return n.value.includes(o.value),
    {
        emptyValues: n,
        valueOnClear: o,
        isEmptyValue: a
    }
}
  , ariaProps = buildProps({
    ariaLabel: String,
    ariaOrientation: {
        type: String,
        values: ["horizontal", "vertical", "undefined"]
    },
    ariaControls: String
})
  , useAriaProps = e => pick(ariaProps, e)
  , configProviderContextKey = Symbol()
  , globalConfig = ref();
function useGlobalConfig(e, t=void 0) {
    const r = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
    return e ? computed( () => {
        var n, o;
        return (o = (n = r.value) == null ? void 0 : n[e]) != null ? o : t
    }
    ) : r
}
function useGlobalComponentSettings(e, t) {
    const r = useGlobalConfig()
      , n = useNamespace(e, computed( () => {
        var i;
        return ((i = r.value) == null ? void 0 : i.namespace) || defaultNamespace
    }
    ))
      , o = useLocale(computed( () => {
        var i;
        return (i = r.value) == null ? void 0 : i.locale
    }
    ))
      , a = useZIndex(computed( () => {
        var i;
        return ((i = r.value) == null ? void 0 : i.zIndex) || defaultInitialZIndex
    }
    ))
      , s = computed( () => {
        var i;
        return unref(t) || ((i = r.value) == null ? void 0 : i.size) || ""
    }
    );
    return provideGlobalConfig(computed( () => unref(r) || {})),
    {
        ns: n,
        locale: o,
        zIndex: a,
        size: s
    }
}
const provideGlobalConfig = (e, t, r=!1) => {
    var n;
    const o = !!getCurrentInstance()
      , a = o ? useGlobalConfig() : void 0
      , s = (n = void 0) != null ? n : o ? provide : void 0;
    if (!s)
        return;
    const i = computed( () => {
        const l = unref(e);
        return a != null && a.value ? mergeConfig(a.value, l) : l
    }
    );
    return s(configProviderContextKey, i),
    s(localeContextKey, computed( () => i.value.locale)),
    s(namespaceContextKey, computed( () => i.value.namespace)),
    s(zIndexContextKey, computed( () => i.value.zIndex)),
    s(SIZE_INJECTION_KEY, {
        size: computed( () => i.value.size || "")
    }),
    s(emptyValuesContextKey, computed( () => ({
        emptyValues: i.value.emptyValues,
        valueOnClear: i.value.valueOnClear
    }))),
    (r || !globalConfig.value) && (globalConfig.value = i.value),
    i
}
  , mergeConfig = (e, t) => {
    const r = [...new Set([...keysOf(e), ...keysOf(t)])]
      , n = {};
    for (const o of r)
        n[o] = t[o] !== void 0 ? t[o] : e[o];
    return n
}
  , configProviderProps = buildProps({
    a11y: {
        type: Boolean,
        default: !0
    },
    locale: {
        type: definePropType(Object)
    },
    size: useSizeProp,
    button: {
        type: definePropType(Object)
    },
    experimentalFeatures: {
        type: definePropType(Object)
    },
    keyboardNavigation: {
        type: Boolean,
        default: !0
    },
    message: {
        type: definePropType(Object)
    },
    zIndex: Number,
    namespace: {
        type: String,
        default: "el"
    },
    ...useEmptyValuesProps
})
  , messageConfig = {}
  , ConfigProvider = defineComponent({
    name: "ElConfigProvider",
    props: configProviderProps,
    setup(e, {slots: t}) {
        watch( () => e.message, n => {
            Object.assign(messageConfig, n ?? {})
        }
        , {
            immediate: !0,
            deep: !0
        });
        const r = provideGlobalConfig(e);
        return () => renderSlot(t, "default", {
            config: r == null ? void 0 : r.value
        })
    }
})
  , ElConfigProvider = withInstall(ConfigProvider)
  , badgeProps = buildProps({
    value: {
        type: [String, Number],
        default: ""
    },
    max: {
        type: Number,
        default: 99
    },
    isDot: Boolean,
    hidden: Boolean,
    type: {
        type: String,
        values: ["primary", "success", "warning", "info", "danger"],
        default: "danger"
    },
    showZero: {
        type: Boolean,
        default: !0
    },
    color: String,
    badgeStyle: {
        type: definePropType([String, Object, Array])
    },
    offset: {
        type: definePropType(Array),
        default: [0, 0]
    },
    badgeClass: {
        type: String
    }
});
var _export_sfc$1 = (e, t) => {
    const r = e.__vccOpts || e;
    for (const [n,o] of t)
        r[n] = o;
    return r
}
;
const __default__$5 = defineComponent({
    name: "ElBadge"
})
  , _sfc_main$a = defineComponent({
    ...__default__$5,
    props: badgeProps,
    setup(e, {expose: t}) {
        const r = e
          , n = useNamespace("badge")
          , o = computed( () => r.isDot ? "" : isNumber$1(r.value) && isNumber$1(r.max) ? r.max < r.value ? `${r.max}+` : `${r.value}` : `${r.value}`)
          , a = computed( () => {
            var s, i, l, u, c;
            return [{
                backgroundColor: r.color,
                marginRight: addUnit(-((i = (s = r.offset) == null ? void 0 : s[0]) != null ? i : 0)),
                marginTop: addUnit((u = (l = r.offset) == null ? void 0 : l[1]) != null ? u : 0)
            }, (c = r.badgeStyle) != null ? c : {}]
        }
        );
        return t({
            content: o
        }),
        (s, i) => (openBlock(),
        createElementBlock("div", {
            class: normalizeClass(unref(n).b())
        }, [renderSlot(s.$slots, "default"), createVNode(Transition, {
            name: `${unref(n).namespace.value}-zoom-in-center`,
            persisted: ""
        }, {
            default: withCtx( () => [withDirectives(createBaseVNode("sup", {
                class: normalizeClass([unref(n).e("content"), unref(n).em("content", s.type), unref(n).is("fixed", !!s.$slots.default), unref(n).is("dot", s.isDot), unref(n).is("hide-zero", !s.showZero && r.value === 0), s.badgeClass]),
                style: normalizeStyle(unref(a)),
                textContent: toDisplayString(unref(o))
            }, null, 14, ["textContent"]), [[vShow, !s.hidden && (unref(o) || s.isDot)]])]),
            _: 1
        }, 8, ["name"])], 2))
    }
});
var Badge = _export_sfc$1(_sfc_main$a, [["__file", "badge.vue"]]);
const ElBadge = withInstall(Badge)
  , iconProps = buildProps({
    size: {
        type: definePropType([Number, String])
    },
    color: {
        type: String
    }
})
  , __default__$4 = defineComponent({
    name: "ElIcon",
    inheritAttrs: !1
})
  , _sfc_main$9 = defineComponent({
    ...__default__$4,
    props: iconProps,
    setup(e) {
        const t = e
          , r = useNamespace("icon")
          , n = computed( () => {
            const {size: o, color: a} = t;
            return !o && !a ? {} : {
                fontSize: isUndefined(o) ? void 0 : addUnit(o),
                "--color": a
            }
        }
        );
        return (o, a) => (openBlock(),
        createElementBlock("i", mergeProps({
            class: unref(r).b(),
            style: unref(n)
        }, o.$attrs), [renderSlot(o.$slots, "default")], 16))
    }
});
var Icon = _export_sfc$1(_sfc_main$9, [["__file", "icon.vue"]]);
const ElIcon = withInstall(Icon)
  , messageTypes = ["success", "info", "warning", "error"]
  , messageDefaults = mutable({
    customClass: "",
    center: !1,
    dangerouslyUseHTMLString: !1,
    duration: 3e3,
    icon: void 0,
    id: "",
    message: "",
    onClose: void 0,
    showClose: !1,
    type: "info",
    plain: !1,
    offset: 16,
    zIndex: 0,
    grouping: !1,
    repeatNum: 1,
    appendTo: isClient ? document.body : void 0
})
  , messageProps = buildProps({
    customClass: {
        type: String,
        default: messageDefaults.customClass
    },
    center: {
        type: Boolean,
        default: messageDefaults.center
    },
    dangerouslyUseHTMLString: {
        type: Boolean,
        default: messageDefaults.dangerouslyUseHTMLString
    },
    duration: {
        type: Number,
        default: messageDefaults.duration
    },
    icon: {
        type: iconPropType,
        default: messageDefaults.icon
    },
    id: {
        type: String,
        default: messageDefaults.id
    },
    message: {
        type: definePropType([String, Object, Function]),
        default: messageDefaults.message
    },
    onClose: {
        type: definePropType(Function),
        default: messageDefaults.onClose
    },
    showClose: {
        type: Boolean,
        default: messageDefaults.showClose
    },
    type: {
        type: String,
        values: messageTypes,
        default: messageDefaults.type
    },
    plain: {
        type: Boolean,
        default: messageDefaults.plain
    },
    offset: {
        type: Number,
        default: messageDefaults.offset
    },
    zIndex: {
        type: Number,
        default: messageDefaults.zIndex
    },
    grouping: {
        type: Boolean,
        default: messageDefaults.grouping
    },
    repeatNum: {
        type: Number,
        default: messageDefaults.repeatNum
    }
})
  , messageEmits = {
    destroy: () => !0
}
  , instances = shallowReactive([])
  , getInstance = e => {
    const t = instances.findIndex(o => o.id === e)
      , r = instances[t];
    let n;
    return t > 0 && (n = instances[t - 1]),
    {
        current: r,
        prev: n
    }
}
  , getLastOffset = e => {
    const {prev: t} = getInstance(e);
    return t ? t.vm.exposed.bottom.value : 0
}
  , getOffsetOrSpace = (e, t) => instances.findIndex(n => n.id === e) > 0 ? 16 : t
  , __default__$3 = defineComponent({
    name: "ElMessage"
})
  , _sfc_main$8 = defineComponent({
    ...__default__$3,
    props: messageProps,
    emits: messageEmits,
    setup(e, {expose: t}) {
        const r = e
          , {Close: n} = TypeComponents
          , {ns: o, zIndex: a} = useGlobalComponentSettings("message")
          , {currentZIndex: s, nextZIndex: i} = a
          , l = ref()
          , u = ref(!1)
          , c = ref(0);
        let f;
        const d = computed( () => r.type ? r.type === "error" ? "danger" : r.type : "info")
          , p = computed( () => {
            const E = r.type;
            return {
                [o.bm("icon", E)]: E && TypeComponentsMap[E]
            }
        }
        )
          , m = computed( () => r.icon || TypeComponentsMap[r.type] || "")
          , g = computed( () => getLastOffset(r.id))
          , _ = computed( () => getOffsetOrSpace(r.id, r.offset) + g.value)
          , b = computed( () => c.value + _.value)
          , y = computed( () => ({
            top: `${_.value}px`,
            zIndex: s.value
        }));
        function v() {
            r.duration !== 0 && ({stop: f} = useTimeoutFn( () => {
                C()
            }
            , r.duration))
        }
        function S() {
            f == null || f()
        }
        function C() {
            u.value = !1
        }
        function x({code: E}) {
            E === EVENT_CODE.esc && C()
        }
        return onMounted( () => {
            v(),
            i(),
            u.value = !0
        }
        ),
        watch( () => r.repeatNum, () => {
            S(),
            v()
        }
        ),
        useEventListener(document, "keydown", x),
        useResizeObserver(l, () => {
            c.value = l.value.getBoundingClientRect().height
        }
        ),
        t({
            visible: u,
            bottom: b,
            close: C
        }),
        (E, I) => (openBlock(),
        createBlock(Transition, {
            name: unref(o).b("fade"),
            onBeforeLeave: E.onClose,
            onAfterLeave: M => E.$emit("destroy"),
            persisted: ""
        }, {
            default: withCtx( () => [withDirectives(createBaseVNode("div", {
                id: E.id,
                ref_key: "messageRef",
                ref: l,
                class: normalizeClass([unref(o).b(), {
                    [unref(o).m(E.type)]: E.type
                }, unref(o).is("center", E.center), unref(o).is("closable", E.showClose), unref(o).is("plain", E.plain), E.customClass]),
                style: normalizeStyle(unref(y)),
                role: "alert",
                onMouseenter: S,
                onMouseleave: v
            }, [E.repeatNum > 1 ? (openBlock(),
            createBlock(unref(ElBadge), {
                key: 0,
                value: E.repeatNum,
                type: unref(d),
                class: normalizeClass(unref(o).e("badge"))
            }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", !0), unref(m) ? (openBlock(),
            createBlock(unref(ElIcon), {
                key: 1,
                class: normalizeClass([unref(o).e("icon"), unref(p)])
            }, {
                default: withCtx( () => [(openBlock(),
                createBlock(resolveDynamicComponent(unref(m))))]),
                _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", !0), renderSlot(E.$slots, "default", {}, () => [E.dangerouslyUseHTMLString ? (openBlock(),
            createElementBlock(Fragment, {
                key: 1
            }, [createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "), createBaseVNode("p", {
                class: normalizeClass(unref(o).e("content")),
                innerHTML: E.message
            }, null, 10, ["innerHTML"])], 2112)) : (openBlock(),
            createElementBlock("p", {
                key: 0,
                class: normalizeClass(unref(o).e("content"))
            }, toDisplayString(E.message), 3))]), E.showClose ? (openBlock(),
            createBlock(unref(ElIcon), {
                key: 2,
                class: normalizeClass(unref(o).e("closeBtn")),
                onClick: withModifiers(C, ["stop"])
            }, {
                default: withCtx( () => [createVNode(unref(n))]),
                _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", !0)], 46, ["id"]), [[vShow, u.value]])]),
            _: 3
        }, 8, ["name", "onBeforeLeave", "onAfterLeave"]))
    }
});
var MessageConstructor = _export_sfc$1(_sfc_main$8, [["__file", "message.vue"]]);
let seed = 1;
const normalizeOptions = e => {
    const t = !e || isString$1(e) || isVNode(e) || isFunction(e) ? {
        message: e
    } : e
      , r = {
        ...messageDefaults,
        ...t
    };
    if (!r.appendTo)
        r.appendTo = document.body;
    else if (isString$1(r.appendTo)) {
        let n = document.querySelector(r.appendTo);
        isElement$1(n) || (n = document.body),
        r.appendTo = n
    }
    return isBoolean$1(messageConfig.grouping) && !r.grouping && (r.grouping = messageConfig.grouping),
    isNumber$1(messageConfig.duration) && r.duration === 3e3 && (r.duration = messageConfig.duration),
    isNumber$1(messageConfig.offset) && r.offset === 16 && (r.offset = messageConfig.offset),
    isBoolean$1(messageConfig.showClose) && !r.showClose && (r.showClose = messageConfig.showClose),
    r
}
  , closeMessage = e => {
    const t = instances.indexOf(e);
    if (t === -1)
        return;
    instances.splice(t, 1);
    const {handler: r} = e;
    r.close()
}
  , createMessage = ({appendTo: e, ...t}, r) => {
    const n = `message_${seed++}`
      , o = t.onClose
      , a = document.createElement("div")
      , s = {
        ...t,
        id: n,
        onClose: () => {
            o == null || o(),
            closeMessage(c)
        }
        ,
        onDestroy: () => {
            render(null, a)
        }
    }
      , i = createVNode(MessageConstructor, s, isFunction(s.message) || isVNode(s.message) ? {
        default: isFunction(s.message) ? s.message : () => s.message
    } : null);
    i.appContext = r || message._context,
    render(i, a),
    e.appendChild(a.firstElementChild);
    const l = i.component
      , c = {
        id: n,
        vnode: i,
        vm: l,
        handler: {
            close: () => {
                l.exposed.visible.value = !1
            }
        },
        props: i.component.props
    };
    return c
}
  , message = (e={}, t) => {
    if (!isClient)
        return {
            close: () => {}
        };
    const r = normalizeOptions(e);
    if (r.grouping && instances.length) {
        const o = instances.find( ({vnode: a}) => {
            var s;
            return ((s = a.props) == null ? void 0 : s.message) === r.message
        }
        );
        if (o)
            return o.props.repeatNum += 1,
            o.props.type = r.type,
            o.handler
    }
    if (isNumber$1(messageConfig.max) && instances.length >= messageConfig.max)
        return {
            close: () => {}
        };
    const n = createMessage(r, t);
    return instances.push(n),
    n.handler
}
;
messageTypes.forEach(e => {
    message[e] = (t={}, r) => {
        const n = normalizeOptions(t);
        return message({
            ...n,
            type: e
        }, r)
    }
}
);
function closeAll(e) {
    for (const t of instances)
        (!e || e === t.props.type) && t.handler.close()
}
message.closeAll = closeAll;
message._context = null;
const ElMessage = withInstallFunction(message, "$message")
  , getRiskQuestionList = () => uXpFetch("/sun/user/riskQuestionList")
  , submitRiskResult = e => uXpFetch("/sun/User/submitRiskResult", {
    data: e
})
  , submitQualifiedInvestor = e => uXpFetch("/sun/User/submitQualifiedInvestor", {
    data: e
})
  , authIdentity = e => uXpFetch("/sun/auth/authIdentity", {
    encryptData: e,
    successProcess: !1
})
  , getOrgRecord = () => uXpFetch("/trade/Account/fetchLatestUserEmployeeRecord")
  , syncRiskResult = e => uXpFetch("/sun/User/recordMismatchFund", {
    data: e
})
  , sendSms = (e, t, r=13) => uXpFetch("/sun/auth/sendSms", {
    method: "POST",
    data: {
        NVCVal: t
    },
    encryptData: {
        phone: e,
        type: r
    }
})
  , loginWithSms = (e, t, r=!0) => uXpFetch("/sun/auth/loginWithSms", {
    method: "POST",
    data: {
        NVCVal: e,
        source_url: location.href
    },
    encryptData: t,
    successProcess: r
})
  , loginWithPwd = (e, t, r=!0) => uXpFetch("/sun/auth/login", {
    method: "POST",
    data: {
        NVCVal: e,
        reme: 1
    },
    encryptData: t,
    successProcess: r
})
  , setPassword = e => uXpFetch("/sun/auth/forget", {
    encryptData: e
})
  , autoLogin = () => uXpFetch("/sun/auth/autoLogin", {
    successProcess: !1
})
  , logout = () => uXpFetch("/sun/auth/logout", {
    method: "GET"
})
  , wxQRCode = () => uXpFetch("/sun/auth/wxQRCode", {
    method: "POST"
})
  , checkScanResult = e => uXpFetch("/sun/auth/checkScanResult", {
    method: "POST",
    data: e
})
  , scanRegBind = e => uXpFetch("/sun/auth/scanRegBind", {
    method: "POST",
    data: e,
    successProcess: !1
})
  , scanBind = e => uXpFetch("/sun/auth/scanBind", {
    method: "POST",
    data: e,
    successProcess: !1
})
  , formContextKey = Symbol("formContextKey")
  , formItemContextKey = Symbol("formItemContextKey")
  , useFormSize = (e, t={}) => {
    const r = ref(void 0)
      , n = t.prop ? r : useProp("size")
      , o = t.global ? r : useGlobalSize()
      , a = t.form ? {
        size: void 0
    } : inject(formContextKey, void 0)
      , s = t.formItem ? {
        size: void 0
    } : inject(formItemContextKey, void 0);
    return computed( () => n.value || unref(e) || (s == null ? void 0 : s.size) || (a == null ? void 0 : a.size) || o.value || "")
}
  , useFormDisabled = e => {
    const t = useProp("disabled")
      , r = inject(formContextKey, void 0);
    return computed( () => t.value || unref(e) || (r == null ? void 0 : r.disabled) || !1)
}
  , useFormItem = () => {
    const e = inject(formContextKey, void 0)
      , t = inject(formItemContextKey, void 0);
    return {
        form: e,
        formItem: t
    }
}
  , useFormItemInputId = (e, {formItemContext: t, disableIdGeneration: r, disableIdManagement: n}) => {
    r || (r = ref(!1)),
    n || (n = ref(!1));
    const o = ref();
    let a;
    const s = computed( () => {
        var i;
        return !!(!(e.label || e.ariaLabel) && t && t.inputIds && ((i = t.inputIds) == null ? void 0 : i.length) <= 1)
    }
    );
    return onMounted( () => {
        a = watch([toRef(e, "id"), r], ([i,l]) => {
            const u = i ?? (l ? void 0 : useId().value);
            u !== o.value && (t != null && t.removeInputId && (o.value && t.removeInputId(o.value),
            !(n != null && n.value) && !l && u && t.addInputId(u)),
            o.value = u)
        }
        , {
            immediate: !0
        })
    }
    ),
    onUnmounted( () => {
        a && a(),
        t != null && t.removeInputId && o.value && t.removeInputId(o.value)
    }
    ),
    {
        isLabeledByFormItem: s,
        inputId: o
    }
}
;
let hiddenTextarea;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`
  , CONTEXT_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
function calculateNodeStyling(e) {
    const t = window.getComputedStyle(e)
      , r = t.getPropertyValue("box-sizing")
      , n = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top"))
      , o = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
    return {
        contextStyle: CONTEXT_STYLE.map(s => `${s}:${t.getPropertyValue(s)}`).join(";"),
        paddingSize: n,
        borderSize: o,
        boxSizing: r
    }
}
function calcTextareaHeight(e, t=1, r) {
    var n;
    hiddenTextarea || (hiddenTextarea = document.createElement("textarea"),
    document.body.appendChild(hiddenTextarea));
    const {paddingSize: o, borderSize: a, boxSizing: s, contextStyle: i} = calculateNodeStyling(e);
    hiddenTextarea.setAttribute("style", `${i};${HIDDEN_STYLE}`),
    hiddenTextarea.value = e.value || e.placeholder || "";
    let l = hiddenTextarea.scrollHeight;
    const u = {};
    s === "border-box" ? l = l + a : s === "content-box" && (l = l - o),
    hiddenTextarea.value = "";
    const c = hiddenTextarea.scrollHeight - o;
    if (isNumber$1(t)) {
        let f = c * t;
        s === "border-box" && (f = f + o + a),
        l = Math.max(f, l),
        u.minHeight = `${f}px`
    }
    if (isNumber$1(r)) {
        let f = c * r;
        s === "border-box" && (f = f + o + a),
        l = Math.min(f, l)
    }
    return u.height = `${l}px`,
    (n = hiddenTextarea.parentNode) == null || n.removeChild(hiddenTextarea),
    hiddenTextarea = void 0,
    u
}
const inputProps = buildProps({
    id: {
        type: String,
        default: void 0
    },
    size: useSizeProp,
    disabled: Boolean,
    modelValue: {
        type: definePropType([String, Number, Object]),
        default: ""
    },
    maxlength: {
        type: [String, Number]
    },
    minlength: {
        type: [String, Number]
    },
    type: {
        type: String,
        default: "text"
    },
    resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
    },
    autosize: {
        type: definePropType([Boolean, Object]),
        default: !1
    },
    autocomplete: {
        type: String,
        default: "off"
    },
    formatter: {
        type: Function
    },
    parser: {
        type: Function
    },
    placeholder: {
        type: String
    },
    form: {
        type: String
    },
    readonly: Boolean,
    clearable: Boolean,
    showPassword: Boolean,
    showWordLimit: Boolean,
    suffixIcon: {
        type: iconPropType
    },
    prefixIcon: {
        type: iconPropType
    },
    containerRole: {
        type: String,
        default: void 0
    },
    tabindex: {
        type: [String, Number],
        default: 0
    },
    validateEvent: {
        type: Boolean,
        default: !0
    },
    inputStyle: {
        type: definePropType([Object, Array, String]),
        default: () => mutable({})
    },
    autofocus: Boolean,
    rows: {
        type: Number,
        default: 2
    },
    ...useAriaProps(["ariaLabel"])
})
  , inputEmits = {
    [UPDATE_MODEL_EVENT]: e => isString$1(e),
    input: e => isString$1(e),
    change: e => isString$1(e),
    focus: e => e instanceof FocusEvent,
    blur: e => e instanceof FocusEvent,
    clear: () => !0,
    mouseleave: e => e instanceof MouseEvent,
    mouseenter: e => e instanceof MouseEvent,
    keydown: e => e instanceof Event,
    compositionstart: e => e instanceof CompositionEvent,
    compositionupdate: e => e instanceof CompositionEvent,
    compositionend: e => e instanceof CompositionEvent
}
  , __default__$2 = defineComponent({
    name: "ElInput",
    inheritAttrs: !1
})
  , _sfc_main$7 = defineComponent({
    ...__default__$2,
    props: inputProps,
    emits: inputEmits,
    setup(e, {expose: t, emit: r}) {
        const n = e
          , o = useAttrs$1()
          , a = useAttrs()
          , s = useSlots()
          , i = computed( () => [n.type === "textarea" ? g.b() : m.b(), m.m(d.value), m.is("disabled", p.value), m.is("exceed", F.value), {
            [m.b("group")]: s.prepend || s.append,
            [m.m("prefix")]: s.prefix || n.prefixIcon,
            [m.m("suffix")]: s.suffix || n.suffixIcon || n.clearable || n.showPassword,
            [m.bm("suffix", "password-clear")]: H.value && G.value,
            [m.b("hidden")]: n.type === "hidden"
        }, o.class])
          , l = computed( () => [m.e("wrapper"), m.is("focus", I.value)])
          , {form: u, formItem: c} = useFormItem()
          , {inputId: f} = useFormItemInputId(n, {
            formItemContext: c
        })
          , d = useFormSize()
          , p = useFormDisabled()
          , m = useNamespace("input")
          , g = useNamespace("textarea")
          , _ = shallowRef()
          , b = shallowRef()
          , y = ref(!1)
          , v = ref(!1)
          , S = ref()
          , C = shallowRef(n.inputStyle)
          , x = computed( () => _.value || b.value)
          , {wrapperRef: E, isFocused: I, handleFocus: M, handleBlur: w} = useFocusController(x, {
            beforeFocus() {
                return p.value
            },
            afterBlur() {
                var V;
                n.validateEvent && ((V = c == null ? void 0 : c.validate) == null || V.call(c, "blur").catch(J => void 0))
            }
        })
          , T = computed( () => {
            var V;
            return (V = u == null ? void 0 : u.statusIcon) != null ? V : !1
        }
        )
          , k = computed( () => (c == null ? void 0 : c.validateState) || "")
          , A = computed( () => k.value && ValidateComponentsMap[k.value])
          , B = computed( () => v.value ? view_default : hide_default)
          , $ = computed( () => [o.style])
          , P = computed( () => [n.inputStyle, C.value, {
            resize: n.resize
        }])
          , N = computed( () => isNil(n.modelValue) ? "" : String(n.modelValue))
          , H = computed( () => n.clearable && !p.value && !n.readonly && !!N.value && (I.value || y.value))
          , G = computed( () => n.showPassword && !p.value && !!N.value && (!!N.value || I.value))
          , X = computed( () => n.showWordLimit && !!n.maxlength && (n.type === "text" || n.type === "textarea") && !p.value && !n.readonly && !n.showPassword)
          , R = computed( () => N.value.length)
          , F = computed( () => !!X.value && R.value > Number(n.maxlength))
          , L = computed( () => !!s.suffix || !!n.suffixIcon || H.value || n.showPassword || X.value || !!k.value && T.value)
          , [D,ee] = useCursor(_);
        useResizeObserver(b, V => {
            if (j(),
            !X.value || n.resize !== "both")
                return;
            const J = V[0]
              , {width: oe} = J.contentRect;
            S.value = {
                right: `calc(100% - ${oe + 15 + 6}px)`
            }
        }
        );
        const Z = () => {
            const {type: V, autosize: J} = n;
            if (!(!isClient || V !== "textarea" || !b.value))
                if (J) {
                    const oe = isObject(J) ? J.minRows : void 0
                      , ie = isObject(J) ? J.maxRows : void 0
                      , ue = calcTextareaHeight(b.value, oe, ie);
                    C.value = {
                        overflowY: "hidden",
                        ...ue
                    },
                    nextTick( () => {
                        b.value.offsetHeight,
                        C.value = ue
                    }
                    )
                } else
                    C.value = {
                        minHeight: calcTextareaHeight(b.value).minHeight
                    }
        }
          , j = (V => {
            let J = !1;
            return () => {
                var oe;
                if (J || !n.autosize)
                    return;
                ((oe = b.value) == null ? void 0 : oe.offsetParent) === null || (V(),
                J = !0)
            }
        }
        )(Z)
          , U = () => {
            const V = x.value
              , J = n.formatter ? n.formatter(N.value) : N.value;
            !V || V.value === J || (V.value = J)
        }
          , z = async V => {
            D();
            let {value: J} = V.target;
            if (n.formatter && (J = n.parser ? n.parser(J) : J),
            !Y.value) {
                if (J === N.value) {
                    U();
                    return
                }
                r(UPDATE_MODEL_EVENT, J),
                r("input", J),
                await nextTick(),
                U(),
                ee()
            }
        }
          , q = V => {
            r("change", V.target.value)
        }
          , {isComposing: Y, handleCompositionStart: W, handleCompositionUpdate: K, handleCompositionEnd: Q} = useComposition({
            emit: r,
            afterComposition: z
        })
          , re = () => {
            v.value = !v.value,
            te()
        }
          , te = async () => {
            var V;
            await nextTick(),
            (V = x.value) == null || V.focus()
        }
          , le = () => {
            var V;
            return (V = x.value) == null ? void 0 : V.blur()
        }
          , ce = V => {
            y.value = !1,
            r("mouseleave", V)
        }
          , fe = V => {
            y.value = !0,
            r("mouseenter", V)
        }
          , ae = V => {
            r("keydown", V)
        }
          , de = () => {
            var V;
            (V = x.value) == null || V.select()
        }
          , se = () => {
            r(UPDATE_MODEL_EVENT, ""),
            r("change", ""),
            r("clear"),
            r("input", "")
        }
        ;
        return watch( () => n.modelValue, () => {
            var V;
            nextTick( () => Z()),
            n.validateEvent && ((V = c == null ? void 0 : c.validate) == null || V.call(c, "change").catch(J => void 0))
        }
        ),
        watch(N, () => U()),
        watch( () => n.type, async () => {
            await nextTick(),
            U(),
            Z()
        }
        ),
        onMounted( () => {
            !n.formatter && n.parser,
            U(),
            nextTick(Z)
        }
        ),
        t({
            input: _,
            textarea: b,
            ref: x,
            textareaStyle: P,
            autosize: toRef(n, "autosize"),
            isComposing: Y,
            focus: te,
            blur: le,
            select: de,
            clear: se,
            resizeTextarea: Z
        }),
        (V, J) => (openBlock(),
        createElementBlock("div", {
            class: normalizeClass([unref(i), {
                [unref(m).bm("group", "append")]: V.$slots.append,
                [unref(m).bm("group", "prepend")]: V.$slots.prepend
            }]),
            style: normalizeStyle(unref($)),
            onMouseenter: fe,
            onMouseleave: ce
        }, [createCommentVNode(" input "), V.type !== "textarea" ? (openBlock(),
        createElementBlock(Fragment, {
            key: 0
        }, [createCommentVNode(" prepend slot "), V.$slots.prepend ? (openBlock(),
        createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(m).be("group", "prepend"))
        }, [renderSlot(V.$slots, "prepend")], 2)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
            ref_key: "wrapperRef",
            ref: E,
            class: normalizeClass(unref(l))
        }, [createCommentVNode(" prefix slot "), V.$slots.prefix || V.prefixIcon ? (openBlock(),
        createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(m).e("prefix"))
        }, [createBaseVNode("span", {
            class: normalizeClass(unref(m).e("prefix-inner"))
        }, [renderSlot(V.$slots, "prefix"), V.prefixIcon ? (openBlock(),
        createBlock(unref(ElIcon), {
            key: 0,
            class: normalizeClass(unref(m).e("icon"))
        }, {
            default: withCtx( () => [(openBlock(),
            createBlock(resolveDynamicComponent(V.prefixIcon)))]),
            _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", !0)], 2)], 2)) : createCommentVNode("v-if", !0), createBaseVNode("input", mergeProps({
            id: unref(f),
            ref_key: "input",
            ref: _,
            class: unref(m).e("inner")
        }, unref(a), {
            minlength: V.minlength,
            maxlength: V.maxlength,
            type: V.showPassword ? v.value ? "text" : "password" : V.type,
            disabled: unref(p),
            readonly: V.readonly,
            autocomplete: V.autocomplete,
            tabindex: V.tabindex,
            "aria-label": V.ariaLabel,
            placeholder: V.placeholder,
            style: V.inputStyle,
            form: V.form,
            autofocus: V.autofocus,
            role: V.containerRole,
            onCompositionstart: unref(W),
            onCompositionupdate: unref(K),
            onCompositionend: unref(Q),
            onInput: z,
            onChange: q,
            onKeydown: ae
        }), null, 16, ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend"]), createCommentVNode(" suffix slot "), unref(L) ? (openBlock(),
        createElementBlock("span", {
            key: 1,
            class: normalizeClass(unref(m).e("suffix"))
        }, [createBaseVNode("span", {
            class: normalizeClass(unref(m).e("suffix-inner"))
        }, [!unref(H) || !unref(G) || !unref(X) ? (openBlock(),
        createElementBlock(Fragment, {
            key: 0
        }, [renderSlot(V.$slots, "suffix"), V.suffixIcon ? (openBlock(),
        createBlock(unref(ElIcon), {
            key: 0,
            class: normalizeClass(unref(m).e("icon"))
        }, {
            default: withCtx( () => [(openBlock(),
            createBlock(resolveDynamicComponent(V.suffixIcon)))]),
            _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", !0)], 64)) : createCommentVNode("v-if", !0), unref(H) ? (openBlock(),
        createBlock(unref(ElIcon), {
            key: 1,
            class: normalizeClass([unref(m).e("icon"), unref(m).e("clear")]),
            onMousedown: withModifiers(unref(NOOP), ["prevent"]),
            onClick: se
        }, {
            default: withCtx( () => [createVNode(unref(circle_close_default))]),
            _: 1
        }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", !0), unref(G) ? (openBlock(),
        createBlock(unref(ElIcon), {
            key: 2,
            class: normalizeClass([unref(m).e("icon"), unref(m).e("password")]),
            onClick: re
        }, {
            default: withCtx( () => [(openBlock(),
            createBlock(resolveDynamicComponent(unref(B))))]),
            _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", !0), unref(X) ? (openBlock(),
        createElementBlock("span", {
            key: 3,
            class: normalizeClass(unref(m).e("count"))
        }, [createBaseVNode("span", {
            class: normalizeClass(unref(m).e("count-inner"))
        }, toDisplayString(unref(R)) + " / " + toDisplayString(V.maxlength), 3)], 2)) : createCommentVNode("v-if", !0), unref(k) && unref(A) && unref(T) ? (openBlock(),
        createBlock(unref(ElIcon), {
            key: 4,
            class: normalizeClass([unref(m).e("icon"), unref(m).e("validateIcon"), unref(m).is("loading", unref(k) === "validating")])
        }, {
            default: withCtx( () => [(openBlock(),
            createBlock(resolveDynamicComponent(unref(A))))]),
            _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", !0)], 2)], 2)) : createCommentVNode("v-if", !0)], 2), createCommentVNode(" append slot "), V.$slots.append ? (openBlock(),
        createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(m).be("group", "append"))
        }, [renderSlot(V.$slots, "append")], 2)) : createCommentVNode("v-if", !0)], 64)) : (openBlock(),
        createElementBlock(Fragment, {
            key: 1
        }, [createCommentVNode(" textarea "), createBaseVNode("textarea", mergeProps({
            id: unref(f),
            ref_key: "textarea",
            ref: b,
            class: [unref(g).e("inner"), unref(m).is("focus", unref(I))]
        }, unref(a), {
            minlength: V.minlength,
            maxlength: V.maxlength,
            tabindex: V.tabindex,
            disabled: unref(p),
            readonly: V.readonly,
            autocomplete: V.autocomplete,
            style: unref(P),
            "aria-label": V.ariaLabel,
            placeholder: V.placeholder,
            form: V.form,
            autofocus: V.autofocus,
            rows: V.rows,
            role: V.containerRole,
            onCompositionstart: unref(W),
            onCompositionupdate: unref(K),
            onCompositionend: unref(Q),
            onInput: z,
            onFocus: unref(M),
            onBlur: unref(w),
            onChange: q,
            onKeydown: ae
        }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]), unref(X) ? (openBlock(),
        createElementBlock("span", {
            key: 0,
            style: normalizeStyle(S.value),
            class: normalizeClass(unref(m).e("count"))
        }, toDisplayString(unref(R)) + " / " + toDisplayString(V.maxlength), 7)) : createCommentVNode("v-if", !0)], 64))], 38))
    }
});
var Input = _export_sfc$1(_sfc_main$7, [["__file", "input.vue"]]);
const ElInput = withInstall(Input)
  , FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped"
  , FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released"
  , FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented"
  , FOCUS_AFTER_TRAPPED_OPTS = {
    cancelable: !0,
    bubbles: !1
}
  , FOCUSOUT_PREVENTED_OPTS = {
    cancelable: !0,
    bubbles: !1
}
  , ON_TRAP_FOCUS_EVT = "focusAfterTrapped"
  , ON_RELEASE_FOCUS_EVT = "focusAfterReleased"
  , FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap")
  , focusReason = ref()
  , lastUserFocusTimestamp = ref(0)
  , lastAutomatedFocusTimestamp = ref(0);
let focusReasonUserCount = 0;
const obtainAllFocusableElements = e => {
    const t = []
      , r = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: n => {
            const o = n.tagName === "INPUT" && n.type === "hidden";
            return n.disabled || n.hidden || o ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 || n === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; r.nextNode(); )
        t.push(r.currentNode);
    return t
}
  , getVisibleElement = (e, t) => {
    for (const r of e)
        if (!isHidden(r, t))
            return r
}
  , isHidden = (e, t) => {
    if (getComputedStyle(e).visibility === "hidden")
        return !0;
    for (; e; ) {
        if (t && e === t)
            return !1;
        if (getComputedStyle(e).display === "none")
            return !0;
        e = e.parentElement
    }
    return !1
}
  , getEdges = e => {
    const t = obtainAllFocusableElements(e)
      , r = getVisibleElement(t, e)
      , n = getVisibleElement(t.reverse(), e);
    return [r, n]
}
  , isSelectable = e => e instanceof HTMLInputElement && "select"in e
  , tryFocus = (e, t) => {
    if (e && e.focus) {
        const r = document.activeElement;
        e.focus({
            preventScroll: !0
        }),
        lastAutomatedFocusTimestamp.value = window.performance.now(),
        e !== r && isSelectable(e) && t && e.select()
    }
}
;
function removeFromStack(e, t) {
    const r = [...e]
      , n = e.indexOf(t);
    return n !== -1 && r.splice(n, 1),
    r
}
const createFocusableStack = () => {
    let e = [];
    return {
        push: n => {
            const o = e[0];
            o && n !== o && o.pause(),
            e = removeFromStack(e, n),
            e.unshift(n)
        }
        ,
        remove: n => {
            var o, a;
            e = removeFromStack(e, n),
            (a = (o = e[0]) == null ? void 0 : o.resume) == null || a.call(o)
        }
    }
}
  , focusFirstDescendant = (e, t=!1) => {
    const r = document.activeElement;
    for (const n of e)
        if (tryFocus(n, t),
        document.activeElement !== r)
            return
}
  , focusableStack = createFocusableStack()
  , isFocusCausedByUserEvent = () => lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value
  , notifyFocusReasonPointer = () => {
    focusReason.value = "pointer",
    lastUserFocusTimestamp.value = window.performance.now()
}
  , notifyFocusReasonKeydown = () => {
    focusReason.value = "keyboard",
    lastUserFocusTimestamp.value = window.performance.now()
}
  , useFocusReason = () => (onMounted( () => {
    focusReasonUserCount === 0 && (document.addEventListener("mousedown", notifyFocusReasonPointer),
    document.addEventListener("touchstart", notifyFocusReasonPointer),
    document.addEventListener("keydown", notifyFocusReasonKeydown)),
    focusReasonUserCount++
}
),
onBeforeUnmount( () => {
    focusReasonUserCount--,
    focusReasonUserCount <= 0 && (document.removeEventListener("mousedown", notifyFocusReasonPointer),
    document.removeEventListener("touchstart", notifyFocusReasonPointer),
    document.removeEventListener("keydown", notifyFocusReasonKeydown))
}
),
{
    focusReason,
    lastUserFocusTimestamp,
    lastAutomatedFocusTimestamp
})
  , createFocusOutPreventedEvent = e => new CustomEvent(FOCUSOUT_PREVENTED,{
    ...FOCUSOUT_PREVENTED_OPTS,
    detail: e
})
  , _sfc_main$6 = defineComponent({
    name: "ElFocusTrap",
    inheritAttrs: !1,
    props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
            type: [Object, String],
            default: "first"
        }
    },
    emits: [ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, "focusin", "focusout", "focusout-prevented", "release-requested"],
    setup(e, {emit: t}) {
        const r = ref();
        let n, o;
        const {focusReason: a} = useFocusReason();
        useEscapeKeydown(m => {
            e.trapped && !s.paused && t("release-requested", m)
        }
        );
        const s = {
            paused: !1,
            pause() {
                this.paused = !0
            },
            resume() {
                this.paused = !1
            }
        }
          , i = m => {
            if (!e.loop && !e.trapped || s.paused)
                return;
            const {key: g, altKey: _, ctrlKey: b, metaKey: y, currentTarget: v, shiftKey: S} = m
              , {loop: C} = e
              , x = g === EVENT_CODE.tab && !_ && !b && !y
              , E = document.activeElement;
            if (x && E) {
                const I = v
                  , [M,w] = getEdges(I);
                if (M && w) {
                    if (!S && E === w) {
                        const k = createFocusOutPreventedEvent({
                            focusReason: a.value
                        });
                        t("focusout-prevented", k),
                        k.defaultPrevented || (m.preventDefault(),
                        C && tryFocus(M, !0))
                    } else if (S && [M, I].includes(E)) {
                        const k = createFocusOutPreventedEvent({
                            focusReason: a.value
                        });
                        t("focusout-prevented", k),
                        k.defaultPrevented || (m.preventDefault(),
                        C && tryFocus(w, !0))
                    }
                } else if (E === I) {
                    const k = createFocusOutPreventedEvent({
                        focusReason: a.value
                    });
                    t("focusout-prevented", k),
                    k.defaultPrevented || m.preventDefault()
                }
            }
        }
        ;
        provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: r,
            onKeydown: i
        }),
        watch( () => e.focusTrapEl, m => {
            m && (r.value = m)
        }
        , {
            immediate: !0
        }),
        watch([r], ([m], [g]) => {
            m && (m.addEventListener("keydown", i),
            m.addEventListener("focusin", c),
            m.addEventListener("focusout", f)),
            g && (g.removeEventListener("keydown", i),
            g.removeEventListener("focusin", c),
            g.removeEventListener("focusout", f))
        }
        );
        const l = m => {
            t(ON_TRAP_FOCUS_EVT, m)
        }
          , u = m => t(ON_RELEASE_FOCUS_EVT, m)
          , c = m => {
            const g = unref(r);
            if (!g)
                return;
            const _ = m.target
              , b = m.relatedTarget
              , y = _ && g.contains(_);
            e.trapped || b && g.contains(b) || (n = b),
            y && t("focusin", m),
            !s.paused && e.trapped && (y ? o = _ : tryFocus(o, !0))
        }
          , f = m => {
            const g = unref(r);
            if (!(s.paused || !g))
                if (e.trapped) {
                    const _ = m.relatedTarget;
                    !isNil(_) && !g.contains(_) && setTimeout( () => {
                        if (!s.paused && e.trapped) {
                            const b = createFocusOutPreventedEvent({
                                focusReason: a.value
                            });
                            t("focusout-prevented", b),
                            b.defaultPrevented || tryFocus(o, !0)
                        }
                    }
                    , 0)
                } else {
                    const _ = m.target;
                    _ && g.contains(_) || t("focusout", m)
                }
        }
        ;
        async function d() {
            await nextTick();
            const m = unref(r);
            if (m) {
                focusableStack.push(s);
                const g = m.contains(document.activeElement) ? n : document.activeElement;
                if (n = g,
                !m.contains(g)) {
                    const b = new Event(FOCUS_AFTER_TRAPPED,FOCUS_AFTER_TRAPPED_OPTS);
                    m.addEventListener(FOCUS_AFTER_TRAPPED, l),
                    m.dispatchEvent(b),
                    b.defaultPrevented || nextTick( () => {
                        let y = e.focusStartEl;
                        isString$1(y) || (tryFocus(y),
                        document.activeElement !== y && (y = "first")),
                        y === "first" && focusFirstDescendant(obtainAllFocusableElements(m), !0),
                        (document.activeElement === g || y === "container") && tryFocus(m)
                    }
                    )
                }
            }
        }
        function p() {
            const m = unref(r);
            if (m) {
                m.removeEventListener(FOCUS_AFTER_TRAPPED, l);
                const g = new CustomEvent(FOCUS_AFTER_RELEASED,{
                    ...FOCUS_AFTER_TRAPPED_OPTS,
                    detail: {
                        focusReason: a.value
                    }
                });
                m.addEventListener(FOCUS_AFTER_RELEASED, u),
                m.dispatchEvent(g),
                !g.defaultPrevented && (a.value == "keyboard" || !isFocusCausedByUserEvent() || m.contains(document.activeElement)) && tryFocus(n ?? document.body),
                m.removeEventListener(FOCUS_AFTER_RELEASED, u),
                focusableStack.remove(s)
            }
        }
        return onMounted( () => {
            e.trapped && d(),
            watch( () => e.trapped, m => {
                m ? d() : p()
            }
            )
        }
        ),
        onBeforeUnmount( () => {
            e.trapped && p(),
            r.value && (r.value.removeEventListener("keydown", i),
            r.value.removeEventListener("focusin", c),
            r.value.removeEventListener("focusout", f),
            r.value = void 0)
        }
        ),
        {
            onKeydown: i
        }
    }
});
function _sfc_render$1(e, t, r, n, o, a) {
    return renderSlot(e.$slots, "default", {
        handleKeydown: e.onKeydown
    })
}
var ElFocusTrap = _export_sfc$1(_sfc_main$6, [["render", _sfc_render$1], ["__file", "focus-trap.vue"]]);
const buttonGroupContextKey = Symbol("buttonGroupContextKey")
  , useButton = (e, t) => {
    useDeprecated({
        from: "type.text",
        replacement: "link",
        version: "3.0.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    }, computed( () => e.type === "text"));
    const r = inject(buttonGroupContextKey, void 0)
      , n = useGlobalConfig("button")
      , {form: o} = useFormItem()
      , a = useFormSize(computed( () => r == null ? void 0 : r.size))
      , s = useFormDisabled()
      , i = ref()
      , l = useSlots()
      , u = computed( () => e.type || (r == null ? void 0 : r.type) || "")
      , c = computed( () => {
        var m, g, _;
        return (_ = (g = e.autoInsertSpace) != null ? g : (m = n.value) == null ? void 0 : m.autoInsertSpace) != null ? _ : !1
    }
    )
      , f = computed( () => e.tag === "button" ? {
        ariaDisabled: s.value || e.loading,
        disabled: s.value || e.loading,
        autofocus: e.autofocus,
        type: e.nativeType
    } : {})
      , d = computed( () => {
        var m;
        const g = (m = l.default) == null ? void 0 : m.call(l);
        if (c.value && (g == null ? void 0 : g.length) === 1) {
            const _ = g[0];
            if ((_ == null ? void 0 : _.type) === Text) {
                const b = _.children;
                return new RegExp("^\\p{Unified_Ideograph}{2}$","u").test(b.trim())
            }
        }
        return !1
    }
    );
    return {
        _disabled: s,
        _size: a,
        _type: u,
        _ref: i,
        _props: f,
        shouldAddSpace: d,
        handleClick: m => {
            if (s.value || e.loading) {
                m.stopPropagation();
                return
            }
            e.nativeType === "reset" && (o == null || o.resetFields()),
            t("click", m)
        }
    }
}
  , buttonTypes = ["default", "primary", "success", "warning", "info", "danger", "text", ""]
  , buttonNativeTypes = ["button", "submit", "reset"]
  , buttonProps = buildProps({
    size: useSizeProp,
    disabled: Boolean,
    type: {
        type: String,
        values: buttonTypes,
        default: ""
    },
    icon: {
        type: iconPropType
    },
    nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
    },
    loading: Boolean,
    loadingIcon: {
        type: iconPropType,
        default: () => loading_default
    },
    plain: Boolean,
    text: Boolean,
    link: Boolean,
    bg: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean,
    color: String,
    dark: Boolean,
    autoInsertSpace: {
        type: Boolean,
        default: void 0
    },
    tag: {
        type: definePropType([String, Object]),
        default: "button"
    }
})
  , buttonEmits = {
    click: e => e instanceof MouseEvent
};
function bound01(e, t) {
    isOnePointZero(e) && (e = "100%");
    var r = isPercentage(e);
    return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))),
    r && (e = parseInt(String(e * t), 10) / 100),
    Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)),
    e)
}
function clamp01(e) {
    return Math.min(1, Math.max(0, e))
}
function isOnePointZero(e) {
    return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1
}
function isPercentage(e) {
    return typeof e == "string" && e.indexOf("%") !== -1
}
function boundAlpha(e) {
    return e = parseFloat(e),
    (isNaN(e) || e < 0 || e > 1) && (e = 1),
    e
}
function convertToPercentage(e) {
    return e <= 1 ? "".concat(Number(e) * 100, "%") : e
}
function pad2(e) {
    return e.length === 1 ? "0" + e : String(e)
}
function rgbToRgb(e, t, r) {
    return {
        r: bound01(e, 255) * 255,
        g: bound01(t, 255) * 255,
        b: bound01(r, 255) * 255
    }
}
function rgbToHsl(e, t, r) {
    e = bound01(e, 255),
    t = bound01(t, 255),
    r = bound01(r, 255);
    var n = Math.max(e, t, r)
      , o = Math.min(e, t, r)
      , a = 0
      , s = 0
      , i = (n + o) / 2;
    if (n === o)
        s = 0,
        a = 0;
    else {
        var l = n - o;
        switch (s = i > .5 ? l / (2 - n - o) : l / (n + o),
        n) {
        case e:
            a = (t - r) / l + (t < r ? 6 : 0);
            break;
        case t:
            a = (r - e) / l + 2;
            break;
        case r:
            a = (e - t) / l + 4;
            break
        }
        a /= 6
    }
    return {
        h: a,
        s,
        l: i
    }
}
function hue2rgb(e, t, r) {
    return r < 0 && (r += 1),
    r > 1 && (r -= 1),
    r < 1 / 6 ? e + (t - e) * (6 * r) : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e
}
function hslToRgb(e, t, r) {
    var n, o, a;
    if (e = bound01(e, 360),
    t = bound01(t, 100),
    r = bound01(r, 100),
    t === 0)
        o = r,
        a = r,
        n = r;
    else {
        var s = r < .5 ? r * (1 + t) : r + t - r * t
          , i = 2 * r - s;
        n = hue2rgb(i, s, e + 1 / 3),
        o = hue2rgb(i, s, e),
        a = hue2rgb(i, s, e - 1 / 3)
    }
    return {
        r: n * 255,
        g: o * 255,
        b: a * 255
    }
}
function rgbToHsv(e, t, r) {
    e = bound01(e, 255),
    t = bound01(t, 255),
    r = bound01(r, 255);
    var n = Math.max(e, t, r)
      , o = Math.min(e, t, r)
      , a = 0
      , s = n
      , i = n - o
      , l = n === 0 ? 0 : i / n;
    if (n === o)
        a = 0;
    else {
        switch (n) {
        case e:
            a = (t - r) / i + (t < r ? 6 : 0);
            break;
        case t:
            a = (r - e) / i + 2;
            break;
        case r:
            a = (e - t) / i + 4;
            break
        }
        a /= 6
    }
    return {
        h: a,
        s: l,
        v: s
    }
}
function hsvToRgb(e, t, r) {
    e = bound01(e, 360) * 6,
    t = bound01(t, 100),
    r = bound01(r, 100);
    var n = Math.floor(e)
      , o = e - n
      , a = r * (1 - t)
      , s = r * (1 - o * t)
      , i = r * (1 - (1 - o) * t)
      , l = n % 6
      , u = [r, s, a, a, i, r][l]
      , c = [i, r, r, s, a, a][l]
      , f = [a, a, i, r, r, s][l];
    return {
        r: u * 255,
        g: c * 255,
        b: f * 255
    }
}
function rgbToHex(e, t, r, n) {
    var o = [pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16)), pad2(Math.round(r).toString(16))];
    return n && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) : o.join("")
}
function rgbaToHex(e, t, r, n, o) {
    var a = [pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16)), pad2(Math.round(r).toString(16)), pad2(convertDecimalToHex(n))];
    return o && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("")
}
function convertDecimalToHex(e) {
    return Math.round(parseFloat(e) * 255).toString(16)
}
function convertHexToDecimal(e) {
    return parseIntFromHex(e) / 255
}
function parseIntFromHex(e) {
    return parseInt(e, 16)
}
function numberInputToObject(e) {
    return {
        r: e >> 16,
        g: (e & 65280) >> 8,
        b: e & 255
    }
}
var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};
function inputToRGB(e) {
    var t = {
        r: 0,
        g: 0,
        b: 0
    }
      , r = 1
      , n = null
      , o = null
      , a = null
      , s = !1
      , i = !1;
    return typeof e == "string" && (e = stringInputToObject(e)),
    typeof e == "object" && (isValidCSSUnit(e.r) && isValidCSSUnit(e.g) && isValidCSSUnit(e.b) ? (t = rgbToRgb(e.r, e.g, e.b),
    s = !0,
    i = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(e.h) && isValidCSSUnit(e.s) && isValidCSSUnit(e.v) ? (n = convertToPercentage(e.s),
    o = convertToPercentage(e.v),
    t = hsvToRgb(e.h, n, o),
    s = !0,
    i = "hsv") : isValidCSSUnit(e.h) && isValidCSSUnit(e.s) && isValidCSSUnit(e.l) && (n = convertToPercentage(e.s),
    a = convertToPercentage(e.l),
    t = hslToRgb(e.h, n, a),
    s = !0,
    i = "hsl"),
    Object.prototype.hasOwnProperty.call(e, "a") && (r = e.a)),
    r = boundAlpha(r),
    {
        ok: s,
        format: e.format || i,
        r: Math.min(255, Math.max(t.r, 0)),
        g: Math.min(255, Math.max(t.g, 0)),
        b: Math.min(255, Math.max(t.b, 0)),
        a: r
    }
}
var CSS_INTEGER = "[-\\+]?\\d+%?"
  , CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?"
  , CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")")
  , PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?")
  , PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?")
  , matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(e) {
    if (e = e.trim().toLowerCase(),
    e.length === 0)
        return !1;
    var t = !1;
    if (names[e])
        e = names[e],
        t = !0;
    else if (e === "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    var r = matchers.rgb.exec(e);
    return r ? {
        r: r[1],
        g: r[2],
        b: r[3]
    } : (r = matchers.rgba.exec(e),
    r ? {
        r: r[1],
        g: r[2],
        b: r[3],
        a: r[4]
    } : (r = matchers.hsl.exec(e),
    r ? {
        h: r[1],
        s: r[2],
        l: r[3]
    } : (r = matchers.hsla.exec(e),
    r ? {
        h: r[1],
        s: r[2],
        l: r[3],
        a: r[4]
    } : (r = matchers.hsv.exec(e),
    r ? {
        h: r[1],
        s: r[2],
        v: r[3]
    } : (r = matchers.hsva.exec(e),
    r ? {
        h: r[1],
        s: r[2],
        v: r[3],
        a: r[4]
    } : (r = matchers.hex8.exec(e),
    r ? {
        r: parseIntFromHex(r[1]),
        g: parseIntFromHex(r[2]),
        b: parseIntFromHex(r[3]),
        a: convertHexToDecimal(r[4]),
        format: t ? "name" : "hex8"
    } : (r = matchers.hex6.exec(e),
    r ? {
        r: parseIntFromHex(r[1]),
        g: parseIntFromHex(r[2]),
        b: parseIntFromHex(r[3]),
        format: t ? "name" : "hex"
    } : (r = matchers.hex4.exec(e),
    r ? {
        r: parseIntFromHex(r[1] + r[1]),
        g: parseIntFromHex(r[2] + r[2]),
        b: parseIntFromHex(r[3] + r[3]),
        a: convertHexToDecimal(r[4] + r[4]),
        format: t ? "name" : "hex8"
    } : (r = matchers.hex3.exec(e),
    r ? {
        r: parseIntFromHex(r[1] + r[1]),
        g: parseIntFromHex(r[2] + r[2]),
        b: parseIntFromHex(r[3] + r[3]),
        format: t ? "name" : "hex"
    } : !1)))))))))
}
function isValidCSSUnit(e) {
    return !!matchers.CSS_UNIT.exec(String(e))
}
var TinyColor = function() {
    function e(t, r) {
        t === void 0 && (t = ""),
        r === void 0 && (r = {});
        var n;
        if (t instanceof e)
            return t;
        typeof t == "number" && (t = numberInputToObject(t)),
        this.originalInput = t;
        var o = inputToRGB(t);
        this.originalInput = t,
        this.r = o.r,
        this.g = o.g,
        this.b = o.b,
        this.a = o.a,
        this.roundA = Math.round(100 * this.a) / 100,
        this.format = (n = r.format) !== null && n !== void 0 ? n : o.format,
        this.gradientType = r.gradientType,
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        this.isValid = o.ok
    }
    return e.prototype.isDark = function() {
        return this.getBrightness() < 128
    }
    ,
    e.prototype.isLight = function() {
        return !this.isDark()
    }
    ,
    e.prototype.getBrightness = function() {
        var t = this.toRgb();
        return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3
    }
    ,
    e.prototype.getLuminance = function() {
        var t = this.toRgb(), r, n, o, a = t.r / 255, s = t.g / 255, i = t.b / 255;
        return a <= .03928 ? r = a / 12.92 : r = Math.pow((a + .055) / 1.055, 2.4),
        s <= .03928 ? n = s / 12.92 : n = Math.pow((s + .055) / 1.055, 2.4),
        i <= .03928 ? o = i / 12.92 : o = Math.pow((i + .055) / 1.055, 2.4),
        .2126 * r + .7152 * n + .0722 * o
    }
    ,
    e.prototype.getAlpha = function() {
        return this.a
    }
    ,
    e.prototype.setAlpha = function(t) {
        return this.a = boundAlpha(t),
        this.roundA = Math.round(100 * this.a) / 100,
        this
    }
    ,
    e.prototype.isMonochrome = function() {
        var t = this.toHsl().s;
        return t === 0
    }
    ,
    e.prototype.toHsv = function() {
        var t = rgbToHsv(this.r, this.g, this.b);
        return {
            h: t.h * 360,
            s: t.s,
            v: t.v,
            a: this.a
        }
    }
    ,
    e.prototype.toHsvString = function() {
        var t = rgbToHsv(this.r, this.g, this.b)
          , r = Math.round(t.h * 360)
          , n = Math.round(t.s * 100)
          , o = Math.round(t.v * 100);
        return this.a === 1 ? "hsv(".concat(r, ", ").concat(n, "%, ").concat(o, "%)") : "hsva(".concat(r, ", ").concat(n, "%, ").concat(o, "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toHsl = function() {
        var t = rgbToHsl(this.r, this.g, this.b);
        return {
            h: t.h * 360,
            s: t.s,
            l: t.l,
            a: this.a
        }
    }
    ,
    e.prototype.toHslString = function() {
        var t = rgbToHsl(this.r, this.g, this.b)
          , r = Math.round(t.h * 360)
          , n = Math.round(t.s * 100)
          , o = Math.round(t.l * 100);
        return this.a === 1 ? "hsl(".concat(r, ", ").concat(n, "%, ").concat(o, "%)") : "hsla(".concat(r, ", ").concat(n, "%, ").concat(o, "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toHex = function(t) {
        return t === void 0 && (t = !1),
        rgbToHex(this.r, this.g, this.b, t)
    }
    ,
    e.prototype.toHexString = function(t) {
        return t === void 0 && (t = !1),
        "#" + this.toHex(t)
    }
    ,
    e.prototype.toHex8 = function(t) {
        return t === void 0 && (t = !1),
        rgbaToHex(this.r, this.g, this.b, this.a, t)
    }
    ,
    e.prototype.toHex8String = function(t) {
        return t === void 0 && (t = !1),
        "#" + this.toHex8(t)
    }
    ,
    e.prototype.toHexShortString = function(t) {
        return t === void 0 && (t = !1),
        this.a === 1 ? this.toHexString(t) : this.toHex8String(t)
    }
    ,
    e.prototype.toRgb = function() {
        return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
        }
    }
    ,
    e.prototype.toRgbString = function() {
        var t = Math.round(this.r)
          , r = Math.round(this.g)
          , n = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(t, ", ").concat(r, ", ").concat(n, ")") : "rgba(".concat(t, ", ").concat(r, ", ").concat(n, ", ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toPercentageRgb = function() {
        var t = function(r) {
            return "".concat(Math.round(bound01(r, 255) * 100), "%")
        };
        return {
            r: t(this.r),
            g: t(this.g),
            b: t(this.b),
            a: this.a
        }
    }
    ,
    e.prototype.toPercentageRgbString = function() {
        var t = function(r) {
            return Math.round(bound01(r, 255) * 100)
        };
        return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toName = function() {
        if (this.a === 0)
            return "transparent";
        if (this.a < 1)
            return !1;
        for (var t = "#" + rgbToHex(this.r, this.g, this.b, !1), r = 0, n = Object.entries(names); r < n.length; r++) {
            var o = n[r]
              , a = o[0]
              , s = o[1];
            if (t === s)
                return a
        }
        return !1
    }
    ,
    e.prototype.toString = function(t) {
        var r = !!t;
        t = t ?? this.format;
        var n = !1
          , o = this.a < 1 && this.a >= 0
          , a = !r && o && (t.startsWith("hex") || t === "name");
        return a ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (n = this.toRgbString()),
        t === "prgb" && (n = this.toPercentageRgbString()),
        (t === "hex" || t === "hex6") && (n = this.toHexString()),
        t === "hex3" && (n = this.toHexString(!0)),
        t === "hex4" && (n = this.toHex8String(!0)),
        t === "hex8" && (n = this.toHex8String()),
        t === "name" && (n = this.toName()),
        t === "hsl" && (n = this.toHslString()),
        t === "hsv" && (n = this.toHsvString()),
        n || this.toHexString())
    }
    ,
    e.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
    }
    ,
    e.prototype.clone = function() {
        return new e(this.toString())
    }
    ,
    e.prototype.lighten = function(t) {
        t === void 0 && (t = 10);
        var r = this.toHsl();
        return r.l += t / 100,
        r.l = clamp01(r.l),
        new e(r)
    }
    ,
    e.prototype.brighten = function(t) {
        t === void 0 && (t = 10);
        var r = this.toRgb();
        return r.r = Math.max(0, Math.min(255, r.r - Math.round(255 * -(t / 100)))),
        r.g = Math.max(0, Math.min(255, r.g - Math.round(255 * -(t / 100)))),
        r.b = Math.max(0, Math.min(255, r.b - Math.round(255 * -(t / 100)))),
        new e(r)
    }
    ,
    e.prototype.darken = function(t) {
        t === void 0 && (t = 10);
        var r = this.toHsl();
        return r.l -= t / 100,
        r.l = clamp01(r.l),
        new e(r)
    }
    ,
    e.prototype.tint = function(t) {
        return t === void 0 && (t = 10),
        this.mix("white", t)
    }
    ,
    e.prototype.shade = function(t) {
        return t === void 0 && (t = 10),
        this.mix("black", t)
    }
    ,
    e.prototype.desaturate = function(t) {
        t === void 0 && (t = 10);
        var r = this.toHsl();
        return r.s -= t / 100,
        r.s = clamp01(r.s),
        new e(r)
    }
    ,
    e.prototype.saturate = function(t) {
        t === void 0 && (t = 10);
        var r = this.toHsl();
        return r.s += t / 100,
        r.s = clamp01(r.s),
        new e(r)
    }
    ,
    e.prototype.greyscale = function() {
        return this.desaturate(100)
    }
    ,
    e.prototype.spin = function(t) {
        var r = this.toHsl()
          , n = (r.h + t) % 360;
        return r.h = n < 0 ? 360 + n : n,
        new e(r)
    }
    ,
    e.prototype.mix = function(t, r) {
        r === void 0 && (r = 50);
        var n = this.toRgb()
          , o = new e(t).toRgb()
          , a = r / 100
          , s = {
            r: (o.r - n.r) * a + n.r,
            g: (o.g - n.g) * a + n.g,
            b: (o.b - n.b) * a + n.b,
            a: (o.a - n.a) * a + n.a
        };
        return new e(s)
    }
    ,
    e.prototype.analogous = function(t, r) {
        t === void 0 && (t = 6),
        r === void 0 && (r = 30);
        var n = this.toHsl()
          , o = 360 / r
          , a = [this];
        for (n.h = (n.h - (o * t >> 1) + 720) % 360; --t; )
            n.h = (n.h + o) % 360,
            a.push(new e(n));
        return a
    }
    ,
    e.prototype.complement = function() {
        var t = this.toHsl();
        return t.h = (t.h + 180) % 360,
        new e(t)
    }
    ,
    e.prototype.monochromatic = function(t) {
        t === void 0 && (t = 6);
        for (var r = this.toHsv(), n = r.h, o = r.s, a = r.v, s = [], i = 1 / t; t--; )
            s.push(new e({
                h: n,
                s: o,
                v: a
            })),
            a = (a + i) % 1;
        return s
    }
    ,
    e.prototype.splitcomplement = function() {
        var t = this.toHsl()
          , r = t.h;
        return [this, new e({
            h: (r + 72) % 360,
            s: t.s,
            l: t.l
        }), new e({
            h: (r + 216) % 360,
            s: t.s,
            l: t.l
        })]
    }
    ,
    e.prototype.onBackground = function(t) {
        var r = this.toRgb()
          , n = new e(t).toRgb()
          , o = r.a + n.a * (1 - r.a);
        return new e({
            r: (r.r * r.a + n.r * n.a * (1 - r.a)) / o,
            g: (r.g * r.a + n.g * n.a * (1 - r.a)) / o,
            b: (r.b * r.a + n.b * n.a * (1 - r.a)) / o,
            a: o
        })
    }
    ,
    e.prototype.triad = function() {
        return this.polyad(3)
    }
    ,
    e.prototype.tetrad = function() {
        return this.polyad(4)
    }
    ,
    e.prototype.polyad = function(t) {
        for (var r = this.toHsl(), n = r.h, o = [this], a = 360 / t, s = 1; s < t; s++)
            o.push(new e({
                h: (n + s * a) % 360,
                s: r.s,
                l: r.l
            }));
        return o
    }
    ,
    e.prototype.equals = function(t) {
        return this.toRgbString() === new e(t).toRgbString()
    }
    ,
    e
}();
function darken(e, t=20) {
    return e.mix("#141414", t).toString()
}
function useButtonCustomStyle(e) {
    const t = useFormDisabled()
      , r = useNamespace("button");
    return computed( () => {
        let n = {}
          , o = e.color;
        if (o) {
            const a = o.match(/var\((.*?)\)/);
            a && (o = window.getComputedStyle(window.document.documentElement).getPropertyValue(a[1]));
            const s = new TinyColor(o)
              , i = e.dark ? s.tint(20).toString() : darken(s, 20);
            if (e.plain)
                n = r.cssVarBlock({
                    "bg-color": e.dark ? darken(s, 90) : s.tint(90).toString(),
                    "text-color": o,
                    "border-color": e.dark ? darken(s, 50) : s.tint(50).toString(),
                    "hover-text-color": `var(${r.cssVarName("color-white")})`,
                    "hover-bg-color": o,
                    "hover-border-color": o,
                    "active-bg-color": i,
                    "active-text-color": `var(${r.cssVarName("color-white")})`,
                    "active-border-color": i
                }),
                t.value && (n[r.cssVarBlockName("disabled-bg-color")] = e.dark ? darken(s, 90) : s.tint(90).toString(),
                n[r.cssVarBlockName("disabled-text-color")] = e.dark ? darken(s, 50) : s.tint(50).toString(),
                n[r.cssVarBlockName("disabled-border-color")] = e.dark ? darken(s, 80) : s.tint(80).toString());
            else {
                const l = e.dark ? darken(s, 30) : s.tint(30).toString()
                  , u = s.isDark() ? `var(${r.cssVarName("color-white")})` : `var(${r.cssVarName("color-black")})`;
                if (n = r.cssVarBlock({
                    "bg-color": o,
                    "text-color": u,
                    "border-color": o,
                    "hover-bg-color": l,
                    "hover-text-color": u,
                    "hover-border-color": l,
                    "active-bg-color": i,
                    "active-border-color": i
                }),
                t.value) {
                    const c = e.dark ? darken(s, 50) : s.tint(50).toString();
                    n[r.cssVarBlockName("disabled-bg-color")] = c,
                    n[r.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${r.cssVarName("color-white")})`,
                    n[r.cssVarBlockName("disabled-border-color")] = c
                }
            }
        }
        return n
    }
    )
}
const __default__$1 = defineComponent({
    name: "ElButton"
})
  , _sfc_main$5 = defineComponent({
    ...__default__$1,
    props: buttonProps,
    emits: buttonEmits,
    setup(e, {expose: t, emit: r}) {
        const n = e
          , o = useButtonCustomStyle(n)
          , a = useNamespace("button")
          , {_ref: s, _size: i, _type: l, _disabled: u, _props: c, shouldAddSpace: f, handleClick: d} = useButton(n, r)
          , p = computed( () => [a.b(), a.m(l.value), a.m(i.value), a.is("disabled", u.value), a.is("loading", n.loading), a.is("plain", n.plain), a.is("round", n.round), a.is("circle", n.circle), a.is("text", n.text), a.is("link", n.link), a.is("has-bg", n.bg)]);
        return t({
            ref: s,
            size: i,
            type: l,
            disabled: u,
            shouldAddSpace: f
        }),
        (m, g) => (openBlock(),
        createBlock(resolveDynamicComponent(m.tag), mergeProps({
            ref_key: "_ref",
            ref: s
        }, unref(c), {
            class: unref(p),
            style: unref(o),
            onClick: unref(d)
        }), {
            default: withCtx( () => [m.loading ? (openBlock(),
            createElementBlock(Fragment, {
                key: 0
            }, [m.$slots.loading ? renderSlot(m.$slots, "loading", {
                key: 0
            }) : (openBlock(),
            createBlock(unref(ElIcon), {
                key: 1,
                class: normalizeClass(unref(a).is("loading"))
            }, {
                default: withCtx( () => [(openBlock(),
                createBlock(resolveDynamicComponent(m.loadingIcon)))]),
                _: 1
            }, 8, ["class"]))], 64)) : m.icon || m.$slots.icon ? (openBlock(),
            createBlock(unref(ElIcon), {
                key: 1
            }, {
                default: withCtx( () => [m.icon ? (openBlock(),
                createBlock(resolveDynamicComponent(m.icon), {
                    key: 0
                })) : renderSlot(m.$slots, "icon", {
                    key: 1
                })]),
                _: 3
            })) : createCommentVNode("v-if", !0), m.$slots.default ? (openBlock(),
            createElementBlock("span", {
                key: 2,
                class: normalizeClass({
                    [unref(a).em("text", "expand")]: unref(f)
                })
            }, [renderSlot(m.$slots, "default")], 2)) : createCommentVNode("v-if", !0)]),
            _: 3
        }, 16, ["class", "style", "onClick"]))
    }
});
var Button = _export_sfc$1(_sfc_main$5, [["__file", "button.vue"]]);
const buttonGroupProps = {
    size: buttonProps.size,
    type: buttonProps.type
}
  , __default__ = defineComponent({
    name: "ElButtonGroup"
})
  , _sfc_main$4 = defineComponent({
    ...__default__,
    props: buttonGroupProps,
    setup(e) {
        const t = e;
        provide(buttonGroupContextKey, reactive({
            size: toRef(t, "size"),
            type: toRef(t, "type")
        }));
        const r = useNamespace("button");
        return (n, o) => (openBlock(),
        createElementBlock("div", {
            class: normalizeClass(unref(r).b("group"))
        }, [renderSlot(n.$slots, "default")], 2))
    }
});
var ButtonGroup = _export_sfc$1(_sfc_main$4, [["__file", "button-group.vue"]]);
const ElButton = withInstall(Button, {
    ButtonGroup
});
withNoopInstall(ButtonGroup);
var dayjs_min = {
    exports: {}
};
(function(e, t) {
    (function(r, n) {
        e.exports = n()
    }
    )(commonjsGlobal, function() {
        var r = 1e3
          , n = 6e4
          , o = 36e5
          , a = "millisecond"
          , s = "second"
          , i = "minute"
          , l = "hour"
          , u = "day"
          , c = "week"
          , f = "month"
          , d = "quarter"
          , p = "year"
          , m = "date"
          , g = "Invalid Date"
          , _ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
          , b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
          , y = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(B) {
                var $ = ["th", "st", "nd", "rd"]
                  , P = B % 100;
                return "[" + B + ($[(P - 20) % 10] || $[P] || $[0]) + "]"
            }
        }
          , v = function(B, $, P) {
            var N = String(B);
            return !N || N.length >= $ ? B : "" + Array($ + 1 - N.length).join(P) + B
        }
          , S = {
            s: v,
            z: function(B) {
                var $ = -B.utcOffset()
                  , P = Math.abs($)
                  , N = Math.floor(P / 60)
                  , H = P % 60;
                return ($ <= 0 ? "+" : "-") + v(N, 2, "0") + ":" + v(H, 2, "0")
            },
            m: function B($, P) {
                if ($.date() < P.date())
                    return -B(P, $);
                var N = 12 * (P.year() - $.year()) + (P.month() - $.month())
                  , H = $.clone().add(N, f)
                  , G = P - H < 0
                  , X = $.clone().add(N + (G ? -1 : 1), f);
                return +(-(N + (P - H) / (G ? H - X : X - H)) || 0)
            },
            a: function(B) {
                return B < 0 ? Math.ceil(B) || 0 : Math.floor(B)
            },
            p: function(B) {
                return {
                    M: f,
                    y: p,
                    w: c,
                    d: u,
                    D: m,
                    h: l,
                    m: i,
                    s,
                    ms: a,
                    Q: d
                }[B] || String(B || "").toLowerCase().replace(/s$/, "")
            },
            u: function(B) {
                return B === void 0
            }
        }
          , C = "en"
          , x = {};
        x[C] = y;
        var E = "$isDayjsObject"
          , I = function(B) {
            return B instanceof k || !(!B || !B[E])
        }
          , M = function B($, P, N) {
            var H;
            if (!$)
                return C;
            if (typeof $ == "string") {
                var G = $.toLowerCase();
                x[G] && (H = G),
                P && (x[G] = P,
                H = G);
                var X = $.split("-");
                if (!H && X.length > 1)
                    return B(X[0])
            } else {
                var R = $.name;
                x[R] = $,
                H = R
            }
            return !N && H && (C = H),
            H || !N && C
        }
          , w = function(B, $) {
            if (I(B))
                return B.clone();
            var P = typeof $ == "object" ? $ : {};
            return P.date = B,
            P.args = arguments,
            new k(P)
        }
          , T = S;
        T.l = M,
        T.i = I,
        T.w = function(B, $) {
            return w(B, {
                locale: $.$L,
                utc: $.$u,
                x: $.$x,
                $offset: $.$offset
            })
        }
        ;
        var k = function() {
            function B(P) {
                this.$L = M(P.locale, null, !0),
                this.parse(P),
                this.$x = this.$x || P.x || {},
                this[E] = !0
            }
            var $ = B.prototype;
            return $.parse = function(P) {
                this.$d = function(N) {
                    var H = N.date
                      , G = N.utc;
                    if (H === null)
                        return new Date(NaN);
                    if (T.u(H))
                        return new Date;
                    if (H instanceof Date)
                        return new Date(H);
                    if (typeof H == "string" && !/Z$/i.test(H)) {
                        var X = H.match(_);
                        if (X) {
                            var R = X[2] - 1 || 0
                              , F = (X[7] || "0").substring(0, 3);
                            return G ? new Date(Date.UTC(X[1], R, X[3] || 1, X[4] || 0, X[5] || 0, X[6] || 0, F)) : new Date(X[1],R,X[3] || 1,X[4] || 0,X[5] || 0,X[6] || 0,F)
                        }
                    }
                    return new Date(H)
                }(P),
                this.init()
            }
            ,
            $.init = function() {
                var P = this.$d;
                this.$y = P.getFullYear(),
                this.$M = P.getMonth(),
                this.$D = P.getDate(),
                this.$W = P.getDay(),
                this.$H = P.getHours(),
                this.$m = P.getMinutes(),
                this.$s = P.getSeconds(),
                this.$ms = P.getMilliseconds()
            }
            ,
            $.$utils = function() {
                return T
            }
            ,
            $.isValid = function() {
                return this.$d.toString() !== g
            }
            ,
            $.isSame = function(P, N) {
                var H = w(P);
                return this.startOf(N) <= H && H <= this.endOf(N)
            }
            ,
            $.isAfter = function(P, N) {
                return w(P) < this.startOf(N)
            }
            ,
            $.isBefore = function(P, N) {
                return this.endOf(N) < w(P)
            }
            ,
            $.$g = function(P, N, H) {
                return T.u(P) ? this[N] : this.set(H, P)
            }
            ,
            $.unix = function() {
                return Math.floor(this.valueOf() / 1e3)
            }
            ,
            $.valueOf = function() {
                return this.$d.getTime()
            }
            ,
            $.startOf = function(P, N) {
                var H = this
                  , G = !!T.u(N) || N
                  , X = T.p(P)
                  , R = function(U, z) {
                    var q = T.w(H.$u ? Date.UTC(H.$y, z, U) : new Date(H.$y,z,U), H);
                    return G ? q : q.endOf(u)
                }
                  , F = function(U, z) {
                    return T.w(H.toDate()[U].apply(H.toDate("s"), (G ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(z)), H)
                }
                  , L = this.$W
                  , D = this.$M
                  , ee = this.$D
                  , Z = "set" + (this.$u ? "UTC" : "");
                switch (X) {
                case p:
                    return G ? R(1, 0) : R(31, 11);
                case f:
                    return G ? R(1, D) : R(0, D + 1);
                case c:
                    var O = this.$locale().weekStart || 0
                      , j = (L < O ? L + 7 : L) - O;
                    return R(G ? ee - j : ee + (6 - j), D);
                case u:
                case m:
                    return F(Z + "Hours", 0);
                case l:
                    return F(Z + "Minutes", 1);
                case i:
                    return F(Z + "Seconds", 2);
                case s:
                    return F(Z + "Milliseconds", 3);
                default:
                    return this.clone()
                }
            }
            ,
            $.endOf = function(P) {
                return this.startOf(P, !1)
            }
            ,
            $.$set = function(P, N) {
                var H, G = T.p(P), X = "set" + (this.$u ? "UTC" : ""), R = (H = {},
                H[u] = X + "Date",
                H[m] = X + "Date",
                H[f] = X + "Month",
                H[p] = X + "FullYear",
                H[l] = X + "Hours",
                H[i] = X + "Minutes",
                H[s] = X + "Seconds",
                H[a] = X + "Milliseconds",
                H)[G], F = G === u ? this.$D + (N - this.$W) : N;
                if (G === f || G === p) {
                    var L = this.clone().set(m, 1);
                    L.$d[R](F),
                    L.init(),
                    this.$d = L.set(m, Math.min(this.$D, L.daysInMonth())).$d
                } else
                    R && this.$d[R](F);
                return this.init(),
                this
            }
            ,
            $.set = function(P, N) {
                return this.clone().$set(P, N)
            }
            ,
            $.get = function(P) {
                return this[T.p(P)]()
            }
            ,
            $.add = function(P, N) {
                var H, G = this;
                P = Number(P);
                var X = T.p(N)
                  , R = function(D) {
                    var ee = w(G);
                    return T.w(ee.date(ee.date() + Math.round(D * P)), G)
                };
                if (X === f)
                    return this.set(f, this.$M + P);
                if (X === p)
                    return this.set(p, this.$y + P);
                if (X === u)
                    return R(1);
                if (X === c)
                    return R(7);
                var F = (H = {},
                H[i] = n,
                H[l] = o,
                H[s] = r,
                H)[X] || 1
                  , L = this.$d.getTime() + P * F;
                return T.w(L, this)
            }
            ,
            $.subtract = function(P, N) {
                return this.add(-1 * P, N)
            }
            ,
            $.format = function(P) {
                var N = this
                  , H = this.$locale();
                if (!this.isValid())
                    return H.invalidDate || g;
                var G = P || "YYYY-MM-DDTHH:mm:ssZ"
                  , X = T.z(this)
                  , R = this.$H
                  , F = this.$m
                  , L = this.$M
                  , D = H.weekdays
                  , ee = H.months
                  , Z = H.meridiem
                  , O = function(z, q, Y, W) {
                    return z && (z[q] || z(N, G)) || Y[q].slice(0, W)
                }
                  , j = function(z) {
                    return T.s(R % 12 || 12, z, "0")
                }
                  , U = Z || function(z, q, Y) {
                    var W = z < 12 ? "AM" : "PM";
                    return Y ? W.toLowerCase() : W
                }
                ;
                return G.replace(b, function(z, q) {
                    return q || function(Y) {
                        switch (Y) {
                        case "YY":
                            return String(N.$y).slice(-2);
                        case "YYYY":
                            return T.s(N.$y, 4, "0");
                        case "M":
                            return L + 1;
                        case "MM":
                            return T.s(L + 1, 2, "0");
                        case "MMM":
                            return O(H.monthsShort, L, ee, 3);
                        case "MMMM":
                            return O(ee, L);
                        case "D":
                            return N.$D;
                        case "DD":
                            return T.s(N.$D, 2, "0");
                        case "d":
                            return String(N.$W);
                        case "dd":
                            return O(H.weekdaysMin, N.$W, D, 2);
                        case "ddd":
                            return O(H.weekdaysShort, N.$W, D, 3);
                        case "dddd":
                            return D[N.$W];
                        case "H":
                            return String(R);
                        case "HH":
                            return T.s(R, 2, "0");
                        case "h":
                            return j(1);
                        case "hh":
                            return j(2);
                        case "a":
                            return U(R, F, !0);
                        case "A":
                            return U(R, F, !1);
                        case "m":
                            return String(F);
                        case "mm":
                            return T.s(F, 2, "0");
                        case "s":
                            return String(N.$s);
                        case "ss":
                            return T.s(N.$s, 2, "0");
                        case "SSS":
                            return T.s(N.$ms, 3, "0");
                        case "Z":
                            return X
                        }
                        return null
                    }(z) || X.replace(":", "")
                })
            }
            ,
            $.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
            }
            ,
            $.diff = function(P, N, H) {
                var G, X = this, R = T.p(N), F = w(P), L = (F.utcOffset() - this.utcOffset()) * n, D = this - F, ee = function() {
                    return T.m(X, F)
                };
                switch (R) {
                case p:
                    G = ee() / 12;
                    break;
                case f:
                    G = ee();
                    break;
                case d:
                    G = ee() / 3;
                    break;
                case c:
                    G = (D - L) / 6048e5;
                    break;
                case u:
                    G = (D - L) / 864e5;
                    break;
                case l:
                    G = D / o;
                    break;
                case i:
                    G = D / n;
                    break;
                case s:
                    G = D / r;
                    break;
                default:
                    G = D
                }
                return H ? G : T.a(G)
            }
            ,
            $.daysInMonth = function() {
                return this.endOf(f).$D
            }
            ,
            $.$locale = function() {
                return x[this.$L]
            }
            ,
            $.locale = function(P, N) {
                if (!P)
                    return this.$L;
                var H = this.clone()
                  , G = M(P, N, !0);
                return G && (H.$L = G),
                H
            }
            ,
            $.clone = function() {
                return T.w(this.$d, this)
            }
            ,
            $.toDate = function() {
                return new Date(this.valueOf())
            }
            ,
            $.toJSON = function() {
                return this.isValid() ? this.toISOString() : null
            }
            ,
            $.toISOString = function() {
                return this.$d.toISOString()
            }
            ,
            $.toString = function() {
                return this.$d.toUTCString()
            }
            ,
            B
        }()
          , A = k.prototype;
        return w.prototype = A,
        [["$ms", a], ["$s", s], ["$m", i], ["$H", l], ["$W", u], ["$M", f], ["$y", p], ["$D", m]].forEach(function(B) {
            A[B[1]] = function($) {
                return this.$g($, B[0], B[1])
            }
        }),
        w.extend = function(B, $) {
            return B.$i || (B($, k, w),
            B.$i = !0),
            w
        }
        ,
        w.locale = M,
        w.isDayjs = I,
        w.unix = function(B) {
            return w(1e3 * B)
        }
        ,
        w.en = x[C],
        w.Ls = x,
        w.p = {},
        w
    })
}
)(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = getDefaultExportFromCjs(dayjs_minExports)
  , FOCUSABLE_CHILDREN = "_trap-focus-children"
  , FOCUS_STACK = []
  , FOCUS_HANDLER = e => {
    if (FOCUS_STACK.length === 0)
        return;
    const t = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
    if (t.length > 0 && e.code === EVENT_CODE.tab) {
        if (t.length === 1) {
            e.preventDefault(),
            document.activeElement !== t[0] && t[0].focus();
            return
        }
        const r = e.shiftKey
          , n = e.target === t[0]
          , o = e.target === t[t.length - 1];
        n && r && (e.preventDefault(),
        t[t.length - 1].focus()),
        o && !r && (e.preventDefault(),
        t[0].focus())
    }
}
  , TrapFocus = {
    beforeMount(e) {
        e[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(e),
        FOCUS_STACK.push(e),
        FOCUS_STACK.length <= 1 && document.addEventListener("keydown", FOCUS_HANDLER)
    },
    updated(e) {
        nextTick( () => {
            e[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(e)
        }
        )
    },
    unmounted() {
        FOCUS_STACK.shift(),
        FOCUS_STACK.length === 0 && document.removeEventListener("keydown", FOCUS_HANDLER)
    }
}
  , overlayProps = buildProps({
    mask: {
        type: Boolean,
        default: !0
    },
    customMaskEvent: Boolean,
    overlayClass: {
        type: definePropType([String, Array, Object])
    },
    zIndex: {
        type: definePropType([String, Number])
    }
})
  , overlayEmits = {
    click: e => e instanceof MouseEvent
}
  , BLOCK = "overlay";
var Overlay = defineComponent({
    name: "ElOverlay",
    props: overlayProps,
    emits: overlayEmits,
    setup(e, {slots: t, emit: r}) {
        const n = useNamespace(BLOCK)
          , o = l => {
            r("click", l)
        }
          , {onClick: a, onMousedown: s, onMouseup: i} = useSameTarget(e.customMaskEvent ? void 0 : o);
        return () => e.mask ? createVNode("div", {
            class: [n.b(), e.overlayClass],
            style: {
                zIndex: e.zIndex
            },
            onClick: a,
            onMousedown: s,
            onMouseup: i
        }, [renderSlot(t, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
            class: e.overlayClass,
            style: {
                zIndex: e.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
            }
        }, [renderSlot(t, "default")])
    }
});
const ElOverlay = Overlay
  , _sfc_main$3 = defineComponent({
    name: "ElMessageBox",
    directives: {
        TrapFocus
    },
    components: {
        ElButton,
        ElFocusTrap,
        ElInput,
        ElOverlay,
        ElIcon,
        ...TypeComponents
    },
    inheritAttrs: !1,
    props: {
        buttonSize: {
            type: String,
            validator: isValidComponentSize
        },
        modal: {
            type: Boolean,
            default: !0
        },
        lockScroll: {
            type: Boolean,
            default: !0
        },
        showClose: {
            type: Boolean,
            default: !0
        },
        closeOnClickModal: {
            type: Boolean,
            default: !0
        },
        closeOnPressEscape: {
            type: Boolean,
            default: !0
        },
        closeOnHashChange: {
            type: Boolean,
            default: !0
        },
        center: Boolean,
        draggable: Boolean,
        overflow: Boolean,
        roundButton: {
            default: !1,
            type: Boolean
        },
        container: {
            type: String,
            default: "body"
        },
        boxType: {
            type: String,
            default: ""
        }
    },
    emits: ["vanish", "action"],
    setup(e, {emit: t}) {
        const {locale: r, zIndex: n, ns: o, size: a} = useGlobalComponentSettings("message-box", computed( () => e.buttonSize))
          , {t: s} = r
          , {nextZIndex: i} = n
          , l = ref(!1)
          , u = reactive({
            autofocus: !0,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: !1,
            distinguishCancelAndClose: !1,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: !0,
            modalClass: "",
            showCancelButton: !1,
            showConfirmButton: !0,
            type: "",
            title: void 0,
            showInput: !1,
            action: "",
            confirmButtonLoading: !1,
            cancelButtonLoading: !1,
            confirmButtonLoadingIcon: markRaw(loading_default),
            cancelButtonLoadingIcon: markRaw(loading_default),
            confirmButtonDisabled: !1,
            editorErrorMessage: "",
            validateError: !1,
            zIndex: i()
        })
          , c = computed( () => {
            const P = u.type;
            return {
                [o.bm("icon", P)]: P && TypeComponentsMap[P]
            }
        }
        )
          , f = useId()
          , d = useId()
          , p = computed( () => u.icon || TypeComponentsMap[u.type] || "")
          , m = computed( () => !!u.message)
          , g = ref()
          , _ = ref()
          , b = ref()
          , y = ref()
          , v = ref()
          , S = computed( () => u.confirmButtonClass);
        watch( () => u.inputValue, async P => {
            await nextTick(),
            e.boxType === "prompt" && P !== null && k()
        }
        , {
            immediate: !0
        }),
        watch( () => l.value, P => {
            var N, H;
            P && (e.boxType !== "prompt" && (u.autofocus ? b.value = (H = (N = v.value) == null ? void 0 : N.$el) != null ? H : g.value : b.value = g.value),
            u.zIndex = i()),
            e.boxType === "prompt" && (P ? nextTick().then( () => {
                var G;
                y.value && y.value.$el && (u.autofocus ? b.value = (G = A()) != null ? G : g.value : b.value = g.value)
            }
            ) : (u.editorErrorMessage = "",
            u.validateError = !1))
        }
        );
        const C = computed( () => e.draggable)
          , x = computed( () => e.overflow);
        useDraggable(g, _, C, x),
        onMounted(async () => {
            await nextTick(),
            e.closeOnHashChange && window.addEventListener("hashchange", E)
        }
        ),
        onBeforeUnmount( () => {
            e.closeOnHashChange && window.removeEventListener("hashchange", E)
        }
        );
        function E() {
            l.value && (l.value = !1,
            nextTick( () => {
                u.action && t("action", u.action)
            }
            ))
        }
        const I = () => {
            e.closeOnClickModal && T(u.distinguishCancelAndClose ? "close" : "cancel")
        }
          , M = useSameTarget(I)
          , w = P => {
            if (u.inputType !== "textarea")
                return P.preventDefault(),
                T("confirm")
        }
          , T = P => {
            var N;
            e.boxType === "prompt" && P === "confirm" && !k() || (u.action = P,
            u.beforeClose ? (N = u.beforeClose) == null || N.call(u, P, u, E) : E())
        }
          , k = () => {
            if (e.boxType === "prompt") {
                const P = u.inputPattern;
                if (P && !P.test(u.inputValue || ""))
                    return u.editorErrorMessage = u.inputErrorMessage || s("el.messagebox.error"),
                    u.validateError = !0,
                    !1;
                const N = u.inputValidator;
                if (isFunction(N)) {
                    const H = N(u.inputValue);
                    if (H === !1)
                        return u.editorErrorMessage = u.inputErrorMessage || s("el.messagebox.error"),
                        u.validateError = !0,
                        !1;
                    if (isString$1(H))
                        return u.editorErrorMessage = H,
                        u.validateError = !0,
                        !1
                }
            }
            return u.editorErrorMessage = "",
            u.validateError = !1,
            !0
        }
          , A = () => {
            const P = y.value.$refs;
            return P.input || P.textarea
        }
          , B = () => {
            T("close")
        }
          , $ = () => {
            e.closeOnPressEscape && B()
        }
        ;
        return e.lockScroll && useLockscreen(l),
        {
            ...toRefs(u),
            ns: o,
            overlayEvent: M,
            visible: l,
            hasMessage: m,
            typeClass: c,
            contentId: f,
            inputId: d,
            btnSize: a,
            iconComponent: p,
            confirmButtonClasses: S,
            rootRef: g,
            focusStartRef: b,
            headerRef: _,
            inputRef: y,
            confirmRef: v,
            doClose: E,
            handleClose: B,
            onCloseRequested: $,
            handleWrapperClick: I,
            handleInputEnter: w,
            handleAction: T,
            t: s
        }
    }
});
function _sfc_render(e, t, r, n, o, a) {
    const s = resolveComponent("el-icon")
      , i = resolveComponent("close")
      , l = resolveComponent("el-input")
      , u = resolveComponent("el-button")
      , c = resolveComponent("el-focus-trap")
      , f = resolveComponent("el-overlay");
    return openBlock(),
    createBlock(Transition, {
        name: "fade-in-linear",
        onAfterLeave: d => e.$emit("vanish"),
        persisted: ""
    }, {
        default: withCtx( () => [withDirectives(createVNode(f, {
            "z-index": e.zIndex,
            "overlay-class": [e.ns.is("message-box"), e.modalClass],
            mask: e.modal
        }, {
            default: withCtx( () => [createBaseVNode("div", {
                role: "dialog",
                "aria-label": e.title,
                "aria-modal": "true",
                "aria-describedby": e.showInput ? void 0 : e.contentId,
                class: normalizeClass(`${e.ns.namespace.value}-overlay-message-box`),
                onClick: e.overlayEvent.onClick,
                onMousedown: e.overlayEvent.onMousedown,
                onMouseup: e.overlayEvent.onMouseup
            }, [createVNode(c, {
                loop: "",
                trapped: e.visible,
                "focus-trap-el": e.rootRef,
                "focus-start-el": e.focusStartRef,
                onReleaseRequested: e.onCloseRequested
            }, {
                default: withCtx( () => [createBaseVNode("div", {
                    ref: "rootRef",
                    class: normalizeClass([e.ns.b(), e.customClass, e.ns.is("draggable", e.draggable), {
                        [e.ns.m("center")]: e.center
                    }]),
                    style: normalizeStyle(e.customStyle),
                    tabindex: "-1",
                    onClick: withModifiers( () => {}
                    , ["stop"])
                }, [e.title !== null && e.title !== void 0 ? (openBlock(),
                createElementBlock("div", {
                    key: 0,
                    ref: "headerRef",
                    class: normalizeClass([e.ns.e("header"), {
                        "show-close": e.showClose
                    }])
                }, [createBaseVNode("div", {
                    class: normalizeClass(e.ns.e("title"))
                }, [e.iconComponent && e.center ? (openBlock(),
                createBlock(s, {
                    key: 0,
                    class: normalizeClass([e.ns.e("status"), e.typeClass])
                }, {
                    default: withCtx( () => [(openBlock(),
                    createBlock(resolveDynamicComponent(e.iconComponent)))]),
                    _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", !0), createBaseVNode("span", null, toDisplayString(e.title), 1)], 2), e.showClose ? (openBlock(),
                createElementBlock("button", {
                    key: 0,
                    type: "button",
                    class: normalizeClass(e.ns.e("headerbtn")),
                    "aria-label": e.t("el.messagebox.close"),
                    onClick: d => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"),
                    onKeydown: withKeys(withModifiers(d => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"])
                }, [createVNode(s, {
                    class: normalizeClass(e.ns.e("close"))
                }, {
                    default: withCtx( () => [createVNode(i)]),
                    _: 1
                }, 8, ["class"])], 42, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("v-if", !0)], 2)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
                    id: e.contentId,
                    class: normalizeClass(e.ns.e("content"))
                }, [createBaseVNode("div", {
                    class: normalizeClass(e.ns.e("container"))
                }, [e.iconComponent && !e.center && e.hasMessage ? (openBlock(),
                createBlock(s, {
                    key: 0,
                    class: normalizeClass([e.ns.e("status"), e.typeClass])
                }, {
                    default: withCtx( () => [(openBlock(),
                    createBlock(resolveDynamicComponent(e.iconComponent)))]),
                    _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", !0), e.hasMessage ? (openBlock(),
                createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(e.ns.e("message"))
                }, [renderSlot(e.$slots, "default", {}, () => [e.dangerouslyUseHTMLString ? (openBlock(),
                createBlock(resolveDynamicComponent(e.showInput ? "label" : "p"), {
                    key: 1,
                    for: e.showInput ? e.inputId : void 0,
                    innerHTML: e.message
                }, null, 8, ["for", "innerHTML"])) : (openBlock(),
                createBlock(resolveDynamicComponent(e.showInput ? "label" : "p"), {
                    key: 0,
                    for: e.showInput ? e.inputId : void 0
                }, {
                    default: withCtx( () => [createTextVNode(toDisplayString(e.dangerouslyUseHTMLString ? "" : e.message), 1)]),
                    _: 1
                }, 8, ["for"]))])], 2)) : createCommentVNode("v-if", !0)], 2), withDirectives(createBaseVNode("div", {
                    class: normalizeClass(e.ns.e("input"))
                }, [createVNode(l, {
                    id: e.inputId,
                    ref: "inputRef",
                    modelValue: e.inputValue,
                    "onUpdate:modelValue": d => e.inputValue = d,
                    type: e.inputType,
                    placeholder: e.inputPlaceholder,
                    "aria-invalid": e.validateError,
                    class: normalizeClass({
                        invalid: e.validateError
                    }),
                    onKeydown: withKeys(e.handleInputEnter, ["enter"])
                }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]), createBaseVNode("div", {
                    class: normalizeClass(e.ns.e("errormsg")),
                    style: normalizeStyle({
                        visibility: e.editorErrorMessage ? "visible" : "hidden"
                    })
                }, toDisplayString(e.editorErrorMessage), 7)], 2), [[vShow, e.showInput]])], 10, ["id"]), createBaseVNode("div", {
                    class: normalizeClass(e.ns.e("btns"))
                }, [e.showCancelButton ? (openBlock(),
                createBlock(u, {
                    key: 0,
                    loading: e.cancelButtonLoading,
                    "loading-icon": e.cancelButtonLoadingIcon,
                    class: normalizeClass([e.cancelButtonClass]),
                    round: e.roundButton,
                    size: e.btnSize,
                    onClick: d => e.handleAction("cancel"),
                    onKeydown: withKeys(withModifiers(d => e.handleAction("cancel"), ["prevent"]), ["enter"])
                }, {
                    default: withCtx( () => [createTextVNode(toDisplayString(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)]),
                    _: 1
                }, 8, ["loading", "loading-icon", "class", "round", "size", "onClick", "onKeydown"])) : createCommentVNode("v-if", !0), withDirectives(createVNode(u, {
                    ref: "confirmRef",
                    type: "primary",
                    loading: e.confirmButtonLoading,
                    "loading-icon": e.confirmButtonLoadingIcon,
                    class: normalizeClass([e.confirmButtonClasses]),
                    round: e.roundButton,
                    disabled: e.confirmButtonDisabled,
                    size: e.btnSize,
                    onClick: d => e.handleAction("confirm"),
                    onKeydown: withKeys(withModifiers(d => e.handleAction("confirm"), ["prevent"]), ["enter"])
                }, {
                    default: withCtx( () => [createTextVNode(toDisplayString(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)]),
                    _: 1
                }, 8, ["loading", "loading-icon", "class", "round", "disabled", "size", "onClick", "onKeydown"]), [[vShow, e.showConfirmButton]])], 2)], 14, ["onClick"])]),
                _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])], 42, ["aria-label", "aria-describedby", "onClick", "onMousedown", "onMouseup"])]),
            _: 3
        }, 8, ["z-index", "overlay-class", "mask"]), [[vShow, e.visible]])]),
        _: 3
    }, 8, ["onAfterLeave"])
}
var MessageBoxConstructor = _export_sfc$1(_sfc_main$3, [["render", _sfc_render], ["__file", "index.vue"]]);
const messageInstance = new Map
  , getAppendToElement = e => {
    let t = document.body;
    return e.appendTo && (isString$1(e.appendTo) && (t = document.querySelector(e.appendTo)),
    isElement$1(e.appendTo) && (t = e.appendTo),
    isElement$1(t) || (t = document.body)),
    t
}
  , initInstance = (e, t, r=null) => {
    const n = createVNode(MessageBoxConstructor, e, isFunction(e.message) || isVNode(e.message) ? {
        default: isFunction(e.message) ? e.message : () => e.message
    } : null);
    return n.appContext = r,
    render(n, t),
    getAppendToElement(e).appendChild(t.firstElementChild),
    n.component
}
  , genContainer = () => document.createElement("div")
  , showMessage = (e, t) => {
    const r = genContainer();
    e.onVanish = () => {
        render(null, r),
        messageInstance.delete(o)
    }
    ,
    e.onAction = a => {
        const s = messageInstance.get(o);
        let i;
        e.showInput ? i = {
            value: o.inputValue,
            action: a
        } : i = a,
        e.callback ? e.callback(i, n.proxy) : a === "cancel" || a === "close" ? e.distinguishCancelAndClose && a !== "cancel" ? s.reject("close") : s.reject("cancel") : s.resolve(i)
    }
    ;
    const n = initInstance(e, r, t)
      , o = n.proxy;
    for (const a in e)
        hasOwn$2(e, a) && !hasOwn$2(o.$props, a) && (o[a] = e[a]);
    return o.visible = !0,
    o
}
;
function MessageBox(e, t=null) {
    if (!isClient)
        return Promise.reject();
    let r;
    return isString$1(e) || isVNode(e) ? e = {
        message: e
    } : r = e.callback,
    new Promise( (n, o) => {
        const a = showMessage(e, t ?? MessageBox._context);
        messageInstance.set(a, {
            options: e,
            callback: r,
            resolve: n,
            reject: o
        })
    }
    )
}
const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"]
  , MESSAGE_BOX_DEFAULT_OPTS$1 = {
    alert: {
        closeOnPressEscape: !1,
        closeOnClickModal: !1
    },
    confirm: {
        showCancelButton: !0
    },
    prompt: {
        showCancelButton: !0,
        showInput: !0
    }
};
MESSAGE_BOX_VARIANTS.forEach(e => {
    MessageBox[e] = messageBoxFactory(e)
}
);
function messageBoxFactory(e) {
    return (t, r, n, o) => {
        let a = "";
        return isObject(r) ? (n = r,
        a = "") : isUndefined(r) ? a = "" : a = r,
        MessageBox(Object.assign({
            title: a,
            message: t,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS$1[e]
        }, n, {
            boxType: e
        }), o)
    }
}
MessageBox.close = () => {
    messageInstance.forEach( (e, t) => {
        t.doClose()
    }
    ),
    messageInstance.clear()
}
;
MessageBox._context = null;
const _MessageBox = MessageBox;
_MessageBox.install = e => {
    _MessageBox._context = e._context,
    e.config.globalProperties.$msgbox = _MessageBox,
    e.config.globalProperties.$messageBox = _MessageBox,
    e.config.globalProperties.$alert = _MessageBox.alert,
    e.config.globalProperties.$confirm = _MessageBox.confirm,
    e.config.globalProperties.$prompt = _MessageBox.prompt
}
;
const ElMessageBox = _MessageBox
  , DefAvatar = "" + new URL("def-m-avatar.DI8AhqOW.svg",import.meta.url).href
  , girlAvatar = "" + new URL("def-m-avatar1.y3YPFO3M.svg",import.meta.url).href
  , coAvatar = "data:image/svg+xml,%3csvg%20width='60'%20height='60'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3crect%20id='a'%20x='0'%20y='0'%20width='60'%20height='60'%20rx='8'/%3e%3c/defs%3e%3cg%20fill='none'%20fill-rule='evenodd'%3e%3cuse%20fill='%236A78A1'%20xlink:href='%23a'/%3e%3cpath%20d='M50.07%2056.918V13.943L43.123%208%2020%2016.46v2.115l20.999-6.928V60H55v-3.105h-4.93v.023zM11%2043l11-2.273V35l-11%202.976V43zm0%2017h11v-6l-11%20.812V60zm0-8%2011-1.123V45l-11%201.957V52zm0-17%2011-3.093V26l-11%203.79V35zm25-14.278L29.51%2017%205%2025.3V60h3.218V27.003l18.328-5.688v38.527H36v-39.12z'%20fill='%23FFF'%20fill-rule='nonzero'/%3e%3c/g%3e%3c/svg%3e"
  , coAvatarRounded = "data:image/svg+xml,%3csvg%20width='60'%20height='60'%20viewBox='0%200%2060%2060'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3crect%20id='a'%20x='0'%20y='0'%20width='60'%20height='60'%20rx='30'/%3e%3c/defs%3e%3cg%20fill='none'%20fill-rule='evenodd'%3e%3cmask%20id='b'%20fill='%23fff'%3e%3cuse%20xlink:href='%23a'/%3e%3c/mask%3e%3cuse%20fill='%236A78A1'%20fill-rule='nonzero'%20xlink:href='%23a'/%3e%3cpath%20d='M48.464%2057.155v-39.67L42.074%2012%2020.8%2019.81v1.952l19.32-6.396V60H53v-2.866h-4.536v.021zM12.52%2044.308l10.12-2.098v-5.287L12.52%2039.67v4.638zm0%2015.692h10.12v-5.538l-10.12.75V60zm0-7.385%2010.12-1.036v-5.425L12.52%2047.96v4.655zm0-15.692%2010.12-2.855v-5.453l-10.12%203.499v4.81zm23-13.18-5.97-3.435L7%2027.969V60h2.96V29.541l16.862-5.25v35.563h8.698v-36.11z'%20fill='%23FFF'%20fill-rule='nonzero'%20mask='url(%23b)'/%3e%3c/g%3e%3c/svg%3e"
  , coAvatarRoundedRed = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='60px'%20height='60px'%20viewBox='0%200%2060%2060'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctitle%3eGroup%2018%20Copy%205备份%204%3c/title%3e%3cdefs%3e%3cradialGradient%20cx='72.9187455%25'%20cy='63.6664707%25'%20fx='72.9187455%25'%20fy='63.6664707%25'%20r='100%25'%20id='radialGradient-1'%3e%3cstop%20stop-color='%23FFE4E4'%20offset='0%25'%3e%3c/stop%3e%3cstop%20stop-color='%23FFE3E4'%20offset='100%25'%3e%3c/stop%3e%3c/radialGradient%3e%3ccircle%20id='path-2'%20cx='30'%20cy='30'%20r='30'%3e%3c/circle%3e%3clinearGradient%20x1='50%25'%20y1='0%25'%20x2='50%25'%20y2='100%25'%20id='linearGradient-4'%3e%3cstop%20stop-color='%23F52D2D'%20offset='0%25'%3e%3c/stop%3e%3cstop%20stop-color='%23FF8989'%20offset='100%25'%3e%3c/stop%3e%3c/linearGradient%3e%3c/defs%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='直播详情页快进-230221'%20transform='translate(-38.000000,%20-102.000000)'%3e%3cg%20id='Group-18-Copy-5备份-4'%20transform='translate(38.000000,%20102.000000)'%3e%3cmask%20id='mask-3'%20fill='white'%3e%3cuse%20xlink:href='%23path-2'%3e%3c/use%3e%3c/mask%3e%3cuse%20id='椭圆形'%20fill='url(%23radialGradient-1)'%20xlink:href='%23path-2'%3e%3c/use%3e%3cpath%20d='M29.4426668,22.4332024%20L34.7808486,25.6780509%20L34.7824147,59.7473937%20L27.0184833,59.7473937%20L27.0184833,26.1906309%20L11.9792046,31.1436506%20L11.9792046,59.9020514%20L9.33150852,59.9020514%20L9.34157665,29.6814775%20L29.4426668,22.4332024%20Z%20M24.293654,54.767246%20L24.293654,59.8017616%20L14.8386113,59.8017616%20L14.8386113,55.4531098%20L24.293654,54.767246%20Z%20M41.1558247,14.0809002%20L47.1210836,19.2801418%20L47.1210836,57.0140065%20L51.335158,57.0140065%20L51.335158,59.7375493%20L39.3314225,59.7375493%20L39.3314225,17.2798268%20L21.2994462,23.3567861%20L21.2994462,21.5011167%20L41.1558247,14.0809002%20Z%20M24.293654,46.8687371%20L24.293654,51.6585411%20L14.8386113,52.5720566%20L14.8386113,48.4582721%20L24.293654,46.8687371%20Z%20M24.293654,38.6997869%20L24.293654,43.4980928%20L14.8386113,45.3895601%20L14.8386113,41.187064%20L24.293654,38.6997869%20Z%20M24.293654,30.4833486%20L24.293654,35.4650065%20L14.8386113,38.0696334%20L14.8386113,33.6822752%20L24.293654,30.4833486%20Z'%20id='形状结合'%20fill='url(%23linearGradient-4)'%20fill-rule='nonzero'%20mask='url(%23mask-3)'%3e%3c/path%3e%3ccircle%20id='椭圆形'%20mask='url(%23mask-3)'%20cx='30'%20cy='30'%20r='30'%3e%3c/circle%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e"
  , whiteAvatar = "data:image/svg+xml,%3csvg%20width='104'%20height='64'%20viewBox='0%200%20104%2064'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%200h104v64H0z'%20fill='%23FFF'%20fill-rule='evenodd'/%3e%3c/svg%3e"
  , transparentAvatar = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGgAAABAAQMAAADMLaC5AAAAA1BMVEVHcEyC+tLSAAAAAXRSTlMAQObYZgAAABFJREFUKM9jYBgFo2AUDBQAAAOAAAHkup+5AAAAAElFTkSuQmCC"
  , lyAvatar = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOgAAACOBAMAAADJKlkMAAAAG1BMVEX39/fk5OT29vbn5+fq6urt7e3z8/Px8fHv7++H3Gq8AAAGpUlEQVR42u2Xy3cSMRSHYyy0S68ZWpbXlNfSFGtdGh7aJcFCuxyBDi6BWugSqLT9s71JAKvHc3TUlSdfeUyGmfnmdyfJTFkgEAgEAoFAIBAIBAKBQCAQCAT+e5ChtJ/u7fHLnFmkX/DQEvKfHCKN7tdSZFLyX0k5/r7VbyslvXybJz10C8MZuohJQl+E92Gpxzmdg99aJltiyVJI7cdZk31u+L0uq8czy7USS+QU6cMxwy/NYhNdQLx6JdmgedmJ7Y571S0vWRquaA+ImBG+sga2HDGkvFr06H0F91PO5HBmxOTGiD6cz6wUtjxPJR0DYaWfZtb6obqlRlIFAOcAgrbKUUk0Nd8rIClEP0oxVVKA6gnX0a2wu1U6W0bIfpAyKz15LH3Xk5YiPGNpKCUGkh5XuVsgKfZhS42kZw26titN0k4XuW3CuwdN0tNze4ZwfJ99eBh9uk4pvXnQcHHP4eDKSlkfXjWIVw0NLdevdYTckFSiay5EzMckHTGXtBoVQB2ZKJWUSwNEjsP+Rnr64FhAm1kMHd9KkTNJzYVoeyl30gb0hTlQxymTemkZXm+kG1xSe1XbXsosaKhTb5NW4BQWuXGkOimln6i8D/d7ULuC+CdJdwHauJFyllVw9Li870HlDwHSXtNMQ0GjloFan6T+mtbr1Vd1BS3rKUCUJJqkPUlNzICYDA1Jl9JJawpeF0FcppTuuHmgAK21lAaoAqgSLswVRHt+yOQZWQ8hqsCjIVPTUKtArvhH0kOYu5Lx0jRJPtl0ydRm4eablFp8/KN0AfMs5DN/IFVHZBy463RbJXzSmu9HUamj3DilpFzbpiZp88JJ334EydTr9Ek16OdjiNfSOlWXsFJ0E13EvvXeXToHZI86Uq0vUKr9tEmfOukCZAHmboK6dtLjaRJTUFdHvpUOqCnlY+lY4C7kUkuFlRrBnJTfUm3F+Qf6qB65GV6vpZLZptCRRCdFLzUwykBU/BPpvolIameDL3Ul2oxfNqr1GllUZFx5PwIyztA2JbfS+VqqoHXoh0x6qc5ZqZ8rRJf67g3N41Z6YL51JC5VfrHpSOf+LgNQewGQVvpEGNAH6gB3nHT8/TQ4i01U2QwZak4W3w+ZU9Ani5xapZSOhRE6DwfSJx3UQTQs2s1IpUQ7y5WXZhPzvbQhFnm9f3Od6smBM2OT5sik4K19RvpAfilXHbMJnisN7TQ47TGGT0kmE3uJ73r+fnpRvDhbDuqUFFNYTUTaCAgnHdMX5yW1Lq8vq++9xCGdA/qOxJzUdjbOPgK8TCNlw8nnRvGiarE9Z9Boxsj4qtO5QBu801ki+9IcNGil5MVO5w7lgJqxmysa9CO6CXuZ8rm3lHA+nE6HCSOkxM3D93oBt8+9klIhR6RWySlkgu4htjyb0vpUV5XAx8WR3K/nmy34poGP1uF6738FKWwxbVaPe1Rx8PUJIp3ZP0bym9gJtlF9w5cYU0RMU+9sfUJpcF1PKTk6L5e+sNyG/edWvorx0VV1RnQxCVfff6wtd86RylvprpbX52y3y67jy0n5jj9gpdOVu93rLo2ki5ve31g5Sqqf+6CXdP9ntLL10aEA+oszOabnV+/6ub1IahC9jF2ZVaBafnxxetFbYqpzyLQ/TzqD5Vnp/edes0wpTG3QKpE0uoSummdyUs8Lb8ZRIc8bUzXKiJma74ihanEmz5pYqXfZ6uy0MeKppM919/iwpm5Oru7F4Mg+w5+ilebLQmqScj3fy5lqf5+VPsPItZ8cSENJ9yI9Gh+Lnj4TH16yNOzm9el+8QTO3hWacNvmrKigZst7sBttpCWhjHkrdaRGO3knRdNmWHhXRh2bSb2c23mGqa5p9Tg6ykavqu1MtaFH1JESs++lLmnE1ZyraAzzvahH5c1zM39KNW8hK9SkrONibqXPEdNIzYlqc3UOcRZWAm9Qv799XtpK98QK5tLk+hDbxWWRkrYycAat3WXxze3S3Om4Xn5TeMZTRR3X6iNplgK5quS4wb6ANkkLvrxcCT1ni3whkiXbZ11SrgWZX2er1XggckjSnaOU4zIeIitjInnCJ2xIU+CdlAlmJ3KKQ8ThHf1c6mWnyCt35bg04cO4POuZVrZHt0UmZ7FMZC87Sj0BbSdygnM7vdo3R7deIvPfjPCritUHNaIF5HJzBGSp2R6Vey/bgEh+dL/I7ZExq+EY1+fC3dYc2R/hbmVeal9ujvV+f3xuvz1YmvWkPUsqiLMGAoFAIBAIBAKBQCAQCAQCgUAg8J/wFfUeqY3rWDqWAAAAAElFTkSuQmCC"
  , UserAvatar = "" + new URL("user.BS5Vxxmt.png",import.meta.url).href
  , newsAvatar = "" + new URL("def-n-avatar.CfzdNTse.svg",import.meta.url).href
  , profitHandler = (e, t) => {
    let r = 2
      , n = "--"
      , o = !1;
    if (t.arg) {
        const i = t.arg.split(":").join(" ")
          , l = /accurate(\d*)/.exec(i);
        l && (r = 4),
        l != null && l[1] && (r = +l[1]);
        const u = /default(\w+|[\u4E00-\u9FA5]+)(?=\s|$)/.exec(i);
        u && (n = u[1])
    }
    t.modifiers.np && (o = t.modifiers.np);
    const a = uXpProfitValue(t.value, r, n, o);
    e.innerText = a,
    e.classList.remove(uXpPlusClass, uXpMinusClass, uXpPlusBgClass, uXpMinusBgClass, uXpDefaultBgClass);
    const s = t.modifiers.bg ? uXpProfitBgClass(a) : uXpProfitClass(a);
    s && e.classList.add(s)
}
  , imgHandler = (e, t) => {
    let r = "";
    if (t.value) {
        if (typeof t.value != "string")
            throw new Error("[directive:def-img]绑定值不为字符串");
        r = t.value
    } else
        t.modifiers.m ? +e.dataset.sex == 2 ? r = girlAvatar : r = DefAvatar : t.modifiers.c ? r = coAvatar : t.modifiers.cr ? r = coAvatarRounded : t.modifiers.crr ? r = coAvatarRoundedRed : t.modifiers.w ? r = whiteAvatar : t.modifiers.t ? r = transparentAvatar : t.modifiers.ly ? r = lyAvatar : t.modifiers.n ? r = newsAvatar : t.modifiers.u && (r = UserAvatar);
    const n = () => {
        [void 0, null].includes(e.dataset.src) ? e.src = r : (e.src = e.dataset.src,
        e.addEventListener("error", () => {
            e.src = r
        }
        , {
            once: !0
        }))
    }
    ;
    if (t.modifiers.lazy)
        new MutationObserver( (o, a) => {
            const s = o.find(i => i.type === "attributes");
            (s == null ? void 0 : s.attributeName) === "data-src" && e.dataset.src && (n(),
            a.disconnect())
        }
        ).observe(e, {
            attributes: !0
        });
    else {
        if (!e.dataset.src && !r)
            throw new Error("[directive:def-img]缺少src参数");
        n()
    }
}
  , resizeObserverDirective = {
    mounted(e, t) {
        let r;
        typeof t.value == "function" ? r = useResizeObserver$1(e, t.value) : r = useResizeObserver$1(e, ...t.value),
        e.__NUXT_RESIZE_DIRECTIVE__ = r
    },
    beforeUnmount(e) {
        var t;
        (t = e.__NUXT_RESIZE_DIRECTIVE__) == null || t.stop()
    }
}
  , visibleHandler = (e, t) => {
    e.style.visibility = t.value ? "visible" : "hidden",
    t.modifiers.opacity && (e.style.opacity = t.value ? "1" : "0")
}
  , visibleDirective = {
    mounted: visibleHandler,
    updated: visibleHandler
}
  , intersectionObserver = {
    mounted(e, t) {
        typeof t.value == "function" ? useIntersectionObserver(e, t.value) : useIntersectionObserver(e, ...t.value)
    }
};
function useXpMount2body(e, t) {
    {
        const r = document.createElement("aside");
        document.body.appendChild(r);
        let n = null;
        const o = createApp({
            name: "",
            render: () => (n = h(e, toValue$1(t)),
            n)
        });
        return uXsMount2bodyHandler(o).directive("profit", profitHandler).directive("defImg", {
            mounted: imgHandler
        }).directive("intersectionObserver", intersectionObserver).directive("resizeObserver", resizeObserverDirective).directive("visible", visibleDirective).mount(r),
        {
            instance: n.component.exposed,
            unmount() {
                o.unmount(),
                document.body.removeChild(r)
            }
        }
    }
}
function objRouteGenerator(e, t) {
    return {
        path: e,
        fullPath: t + e
    }
}
function funcRouteGenerator(e, t) {
    return {
        path({params: r, query: n}={}) {
            return uXpUrlParamsExchange(e, r) + uXpUrlQueryExchange(n)
        },
        fullPath({params: r, query: n}={}) {
            return t + uXpUrlParamsExchange(e, r) + uXpUrlQueryExchange(n)
        }
    }
}
function uXsRoutes() {
    return {
        feedback: objRouteGenerator("/feedback/index", uXpConfig().mainHost),
        trade: funcRouteGenerator("/trade/purchase/{id}", uXpConfig().mainHost),
        invest: funcRouteGenerator("/trade/invest/{id}", uXpConfig().mainHost),
        contract: funcRouteGenerator("/contract", uXpConfig().mainHost),
        orderList: funcRouteGenerator("/trade/order", uXpConfig().mainHost),
        product: funcRouteGenerator("/product/{id}.html", uXpConfig().dcHost),
        manager: funcRouteGenerator("/manager/{id}", uXpConfig().dcHost),
        company: funcRouteGenerator("/company/{id}", uXpConfig().dcHost),
        position: funcRouteGenerator("/user/assets", uXpConfig().mainHost),
        vip: funcRouteGenerator("/user/vip", uXpConfig().mainHost),
        vipUpload: funcRouteGenerator("/user/vip/upload", uXpConfig().mainHost),
        crtUpload: funcRouteGenerator("/crtUpload", uXpConfig().mainHost),
        riskTest: objRouteGenerator("/quiz/risk-testing", uXpConfig().mainHost),
        sell: funcRouteGenerator("/trade/sell/{id}", uXpConfig().mainHost)
    }
}
const getUserInfo = e => uXpFetch("/sun/member/getUserInfoApi", {
    refresh: e,
    successProcess: !1,
    data: {
        sign: useUserStore().wxSign
    }
})
  , getAccountAuth = () => uXpFetch("/sun/member/getMasterInfo")
  , getP2PEmail = () => uXpFetch("/sun/user/navAuthorizationApplyEmailList")
  , applyP2P = e => uXpFetch("/sun/user/navAuthorizationApply", {
    data: {
        ...e,
        fund_ids: e.fund_ids.join(",")
    }
})
  , getCustomerService = e => uXpFetch("/sun/user/getCustomerService", {
    data: {
        customer_service_type: e
    }
})
  , useUserExtendStore = defineStore("userExtend", {
    state() {
        return {
            info: {},
            email: []
        }
    },
    actions: {
        getInfo() {
            return getAccountAuth().then( ({data: e}) => {
                this.info = e
            }
            )
        },
        getEmail() {
            return getP2PEmail().then( ({data: e}) => {
                this.email = e
            }
            )
        }
    }
});
function uXpFormatDateToZero(e="9999-12-31") {
    return new Date(e.replace(/-/g, "/"))
}
function uXpFormatWord(e, t, r) {
    let n = "";
    if (!/#{.*}/.test(e))
        throw new Error("模板缺少替换内容");
    return r === void 0 ? uXpIsEmpty(t, [""]) || (n = uXpFormatWord.replacement(e, t)) : r === !0 && (n = uXpFormatWord.replacement(e, t)),
    n
}
uXpFormatWord.replacement = (e, t) => (typeof t == "object" ? Object.entries(t).forEach( ([r,n]) => {
    e = e.replace(new RegExp(`#{${r}}`), n)
}
) : e = e.replace(/#{.*}/, t),
e);
function uXpStaticCompareList(e=!1) {
    let t;
    return typeof e == "boolean" ? t = e : t = uXpFundIs(e, "pub"),
    [{
        key: "业绩比较基准",
        value: "PUBBENCHMARK",
        filtered: !t
    }, {
        key: "沪深300",
        value: "IN00000008"
    }, {
        key: "南华商品",
        value: "IN0000008S"
    }, {
        key: "恒生指数",
        value: "IN00000009"
    }, {
        key: "中证全债",
        value: "IN00000077"
    }, {
        key: "中证转债",
        value: "IN0000008J"
    }, {
        key: "中证货币基金",
        value: "IN0000007G"
    }, {
        key: "中证500",
        value: "IN0000007M"
    }, {
        key: "中证800",
        value: "IN0000028E"
    }, {
        key: "中证1000",
        value: "IN0000008O"
    }, {
        key: "中证2000",
        value: "IN000002FC"
    }, {
        key: "中证全指",
        value: "IN0000007N"
    }, {
        key: "中证红利",
        value: "IN000002GP"
    }, {
        key: "中证A500",
        value: "IN000002GX"
    }, {
        key: "红利低波100",
        value: "IN000002GO"
    }, {
        key: "上证综合指数",
        value: "IN00000004"
    }, {
        key: "上证50",
        value: "IN0000008K"
    }, {
        key: "上证180",
        value: "IN0000008L"
    }, {
        key: "国证2000",
        value: "IN000002E3"
    }, {
        key: "标准普尔500",
        value: "IN0000008P"
    }, {
        key: "米筐小市值",
        value: "IN000002FA"
    }, {
        key: "米筐微盘股",
        value: "IN000002FF"
    }, {
        key: "科创50",
        value: "IN000002CP"
    }].filter(r => !r.filtered)
}
uXpStaticCompareList(!1).reduce( (e, t) => (e[t.value] = t.key,
e), {});
const uXpStaticOverProfitList = [{
    name: "超额收益(算术)",
    value: "compare",
    mode: 2
}, {
    name: "超额收益(几何)",
    value: "compare_geometry",
    mode: 1
}]
  , uXpStaticNavFlagList = [{
    name: "分红再投资",
    value: 1
}, {
    name: "分红不投资",
    value: 2
}]
  , uXpStaticPriStrategy = {
    1001: "股票策略",
    100101: "主观多头",
    10010101: "主观选股",
    10010102: "定增打新",
    100102: "量化多头",
    10010201: "沪深300指增",
    10010202: "中证500指增",
    10010203: "中证1000指增",
    10010204: "其他指增",
    10010205: "量化选股",
    100103: "股票多空",
    100104: "股票市场中性",
    1002: "债券策略",
    100201: "纯债策略",
    100202: "债券增强",
    100203: "债券复合",
    100204: "转债交易",
    1003: "期货及衍生品策略",
    100301: "主观CTA",
    10030101: "主观趋势",
    10030102: "主观套利",
    10030103: "主观多策略",
    100302: "量化CTA",
    10030201: "量化趋势",
    10030202: "量化套利",
    10030203: "量化多策略",
    100303: "期权策略",
    100304: "其他衍生品策略",
    1004: "多资产策略",
    100401: "宏观策略",
    100402: "套利策略",
    100403: "复合策略",
    1005: "组合基金",
    100501: "FOF",
    100502: "MOM"
}
  , uXpStaticPubStrategy = {
    101: "股票型",
    102: "混合型",
    103: "债券型",
    104: "货币型",
    105: "商品型",
    106: "市场中性型",
    107: "FOF",
    108: "海外型"
}
  , uXpStaticPubStrategyL2 = {
    10101: "主动",
    10102: "被动",
    10103: "指数增强",
    10201: "偏股",
    10202: "平衡",
    10203: "偏债",
    10301: "普通债券",
    10302: "可转债",
    10303: "指数",
    10401: "货币",
    10402: "理财",
    10701: "偏股",
    10702: "平衡",
    10703: "偏债",
    10801: "主动",
    10802: "被动",
    10803: "指数增强"
};
function format(e) {
    const t = {};
    for (const [r,n] of Object.entries(uXpStaticPriStrategy))
        new RegExp(`^\\d{${e}}$`).test(r) && (t[r] = n);
    return t
}
const uXpStaticPriStrategyL1 = format(4)
  , uXpStaticPriStrategyL2 = format(6)
  , uXpStaticPriStrategyL3 = format(8);
function uXpStaticGetStrategy(e, t=2) {
    const r = {
        ...uXpStaticPriStrategy,
        ...uXpStaticPubStrategy,
        ...uXpStaticPubStrategyL2
    }
      , n = new RegExp(`^${e}\\d{${t}}$`)
      , o = {};
    for (const [a,s] of Object.entries(r))
        n.test(a) && (o[a] = s);
    return o
}
const uXpStaticPriIndex = [{
    key: "排排网综合指数",
    value: "IN000002GK"
}, {
    key: "股票策略",
    value: "IN000002FK",
    children: [{
        key: "主观多头",
        value: "IN000002FP",
        children: [{
            key: "主观选股",
            value: "IN000002G5"
        }, {
            key: "定增打新",
            value: "IN000002G6"
        }]
    }, {
        key: "量化多头",
        value: "IN000002FQ",
        children: [{
            key: "沪深300指增",
            value: "IN000002G7"
        }, {
            key: "中证500指增",
            value: "IN000002G8"
        }, {
            key: "中证1000指增",
            value: "IN000002G9"
        }, {
            key: "量化选股",
            value: "IN000002GB"
        }, {
            key: "其他指增",
            value: "IN000002GA"
        }]
    }, {
        key: "股票多空",
        value: "IN000002FR"
    }, {
        key: "股票市场中性",
        value: "IN000002FS"
    }]
}, {
    key: "债券策略",
    value: "IN000002FL",
    children: [{
        key: "纯债策略",
        value: "IN000002FT"
    }, {
        key: "债券增强",
        value: "IN000002FU"
    }, {
        key: "转债交易",
        value: "IN000002FW"
    }, {
        key: "债券复合",
        value: "IN000002FV"
    }]
}, {
    key: "期货及衍生品策略",
    value: "IN000002FM",
    children: [{
        key: "主观CTA",
        value: "IN000002FX",
        children: [{
            key: "主观趋势",
            value: "IN000002GC"
        }, {
            key: "主观套利",
            value: "IN000002GD"
        }, {
            key: "主观多策略",
            value: "IN000002GE"
        }]
    }, {
        key: "量化CTA",
        value: "IN000002FY",
        children: [{
            key: "量化趋势",
            value: "IN000002GF"
        }, {
            key: "量化套利",
            value: "IN000002GG"
        }, {
            key: "量化多策略",
            value: "IN000002GH"
        }]
    }, {
        key: "期权策略",
        value: "IN000002FZ"
    }]
}, {
    key: "多资产策略",
    value: "IN000002FN",
    children: [{
        key: "宏观策略",
        value: "IN000002G0"
    }, {
        key: "套利策略",
        value: "IN000002G1"
    }, {
        key: "复合策略",
        value: "IN000002G2"
    }]
}, {
    key: "组合基金",
    value: "IN000002FO",
    children: [{
        key: "FOF",
        value: "IN000002G3"
    }, {
        key: "MOM",
        value: "IN000002G4"
    }]
}]
  , uXpStaticPriPPW = ( () => {
    const e = [];
    for (const t of uXpStaticPriIndex) {
        const r = JSON.parse(JSON.stringify(t));
        r.value === "IN000002GK" ? (r.children = [{
            key: r.key,
            value: r.value
        }],
        r.value = "IN000002GK-1") : r.children && (r.children.unshift({
            key: r.key,
            displayKey: "不限",
            value: r.value
        }),
        r.value = r.value + "-1"),
        e.push(r)
    }
    return e
}
)()
  , uXpStaticTel = "400-666-7388";
Object.entries({
    djzf: "267",
    phbd: "419",
    smbk: "423",
    jjzs: "435",
    gpzs: "437",
    zqzs: "438",
    qhzs: "439",
    xtzs: "440",
    hjzs: "441",
    whzs: "442",
    lczs: "443",
    smgs: "453",
    smjj: "454",
    smjl: "455",
    jxsd: "457",
    lcxy: "502",
    yjzx: "504",
    hybg: "504",
    dczs: "506",
    xxzs: "507"
}).reduce( (e, [t,r]) => [...e, {
    path: `/${t}`,
    redirect: `/news/list-${r}.html`
}], []),
["bxxy", "pjbg", "smxy", "gmxy", "announce"].reduce( (e, t) => [...e, {
    path: `/${t}`,
    redirect: "/news"
}], []);
const uXpStaticFOFEmailURL = e => `${uXpConfig().fofHost}/nav-database/email-configuration${uXpFormatWord("?email=#{email}", e)}`
  , uXpStaticCustomerRiskLevel = {
    0: "C1-风险承受能力最低类别",
    1: "C1-保守型",
    2: "C2-稳健型",
    3: "C3-平衡型",
    4: "C4-成长型",
    5: "C5-进取型"
}
  , getShelfFundList = e => uXpFetch("/sun/Shelf/fundList", {
    data: e
})
  , getShelfSaleSelect = e => uXpFetch("/sun/shelf/saleSelect", {
    data: e
})
  , getSunFundInfo = e => uXpFetch("/sun/fund/baseInfo", {
    data: {
        id: e
    }
})
  , getPubFundInfo = e => uXpFetch("/pub/pubFund/baseInfo", {
    data: {
        id: e
    }
})
  , getSunRelationManager = e => uXpFetch("/sun/fund/relationManager", {
    data: {
        id: e
    }
})
  , getPubRelationManager = e => uXpFetch("/pub/pubFund/relationManager", {
    data: {
        id: e
    }
})
  , getManagerInfo = e => uXpFetch("/sun/Manager/baseInfo", {
    data: {
        id: e
    }
})
  , decodeNav = e => uXpFetch("/sun/fund/style", {
    data: {
        id: e
    }
}).then( ({data: t}) => Function(`return ${t}`)()).catch( () => {}
)
  , getPriProductPageDetail = e => uXpFetch("/sun/fund/detail", {
    data: {
        id: e
    }
})
  , getPubProductPageDetail = e => uXpFetch("/pub/pubFund/detail", {
    data: {
        id: e
    }
})
  , getRangeGain = e => {
    const t = uXpFundIs(e.id, "pri") ? "/sun/fund/performanceRange" : "/pub/pubFund/performanceRange";
    return uXpFetch(t, {
        data: e,
        requireUserid: !0
    })
}
  , getOldProfitRisk = e => {
    const t = uXpFundIs(e, "pri") ? "/sun/fund/fundIndexInfo" : "/pub/pubFund/fundIndexInfo";
    return uXpFetch(t, {
        data: {
            id: e
        }
    })
}
  , getProfitRiskIndicators = e => uXpFetch(uXpFundIs(e.id, "pri") ? "/sun/fund/fundIndexInfoNew" : "/pub/PubFund/fundIndexInfoNew", {
    data: e
})
  , tradingRules = e => uXpFetch("/pub/pubFund/tradingRules", {
    data: {
        id: e
    }
})
  , announceList = e => uXpFetch("/pub/pubFund/announceList", {
    data: {
        ...e,
        with_total: 1
    }
})
  , assetSizeList = e => uXpFetch("/pub/pubFund/assetSizeList", {
    data: e
})
  , getPubAssetSize = e => uXpFetch("/pub/pubChart/assetSize", {
    data: {
        fund_id: e
    }
})
  , profitProbability = e => uXpFetch("/pub/pubFund/profitProbability", {
    data: {
        id: e
    }
})
  , pubFundHolding = (e, t) => uXpFetch("/pub/pubFund/holding", {
    data: {
        id: e,
        holding_date: t
    }
})
  , holderStructure = e => uXpFetch("/pub/pubFund/holderStructure", {
    data: {
        fund_id: e
    }
})
  , pubDistributionList = e => uXpFetch("/pub/pubFund/distributionList", {
    data: {
        id: e
    }
})
  , getFundSameStrategyRandomList = e => uXpFetch(e.startsWith("MF") ? "/pub/PubFund/sameStrategyFund" : "/sun/Fund/getFundSameStrategyRandomList", {
    data: {
        fund_id: e
    }
})
  , rongzhiTrend = e => uXpFetch(e.startsWith("MF") ? "/pub/pubChart/rongzhiTrend/" : "/sun/chart/rongzhiTrend", {
    data: {
        fund_id: e
    },
    requireUserid: !0
})
  , getPubNavData = e => uXpFetch("/pub/pubFund/getNavData", {
    data: e
})
  , getPriNavData = e => uXpFetch("/sun/fund/getNavData", {
    method: "POST",
    encryptData: e,
    encryptKey: useEnvStore().a,
    requireUserid: !0
})
  , getNavMissingDate = (e, t) => uXpFetch("/sun/fund/getNavMissingDate", {
    method: "POST",
    data: {
        id: e,
        from_asset: t
    }
})
  , getAnnounceDetail = e => uXpFetch("/pub/pubFund/announceDetail", {
    method: "POST",
    data: {
        ann_id: e
    }
})
  , getBonus = e => uXpFetch("/sun/fund/distributionList", {
    data: {
        id: e
    },
    requireUserid: !0
})
  , holdingDate = e => uXpFetch("/pub/pubFund/holdingDate", {
    method: "POST",
    data: {
        id: e
    }
})
  , getFundPNR = e => {
    const t = uXpFundIs(e, "pri") ? "/sun/fund/incomeIndex" : "/pub/pubfund/incomeIndex";
    return uXpFetch(t, {
        data: {
            id: e
        }
    })
}
  , signRiskApply = (e, t) => uXpFetch("/sun/user/signRiskApply", {
    data: {
        fund_id: e,
        risk_level: t,
        client: useEnvStore().isPc ? "PC" : "Mobile"
    }
})
  , checkRiskApply = () => uXpFetch("/sun/user/checkRiskApply")
  , postApplyNav = e => uXpFetch("/sun/fund/applyApi", {
    data: {
        id: e
    }
})
  , getFundScale = e => uXpFetch("/sun/Fund/assetSizeList", {
    data: e
});
function uXpProductRiskLevel(e) {
    return {
        1: "R1-低风险",
        2: "R2-中低风险",
        3: "R3-中风险",
        4: "R4-中高风险",
        5: "R5-高风险"
    }[e]
}
function uXpProductFeeCalc(e) {
    return (e == null ? void 0 : e.type) === void 0 ? "详见产品合同" : e.type !== 2 ? e.fee[0].fee : e.fee.map(t => `${t.limit}：${t.fee}`).join(`
`)
}
async function uXpProductRiskMismatch(e) {
    const t = useMounted();
    if (await until(computed( () => useUserStore().loginStatus)).not.toBe("waiting"),
    await useUserStore().getInvestorInfo(),
    await until(t).toBe(!0),
    useUserStore().info.evaluation_result === 0 && e > 1 || useUserStore().info.evaluation_result > 0 && useUserStore().info.evaluation_result < e) {
        const r = await checkRiskApply();
        return r.data.status === 1 ? {
            type: "1",
            title: "风险承受能力不匹配警示",
            content: "根据您目前的风险测评结果，您将要查看或向我司咨询了解的金融产品风险等级可能高于您目前的风险等级，与您的风险承受能力不匹配。特书面警示：购买该产品可能产生损失及不利后果，请您充分评估投资目标和自身风险承受能力，谨慎作出投资决策。若您仍需了解或索取更多信息或详情须向我司作出书面申请，请仔细阅读、理解以下《申请书》内容，并在审慎评估后进行签署。",
            confirmText: "申请查看",
            cancelText: "退出",
            file: r.data.pdf_url,
            showCancelButton: !0
        } : {
            title: "该产品超出风险承受能力提醒",
            content: `产品与投资者风险承受能力不匹配提醒：您的风险评级是<span class="c-red">${useUserStore().evaluationLabel}</span>，低于该产品风险等级<span class="c-red">（${uXpProductRiskLevel(e)}）</span>，特书面警示：您的风险承受能力与该产品风险等级不匹配，我司不得主动向您推介该产品且无法为您提供该产品的销售服务。点击继续操作，即表明您在知悉理解上述不匹配意见后，依然要求通过我司平台了解该产品相关信息，且您确认我司及销售人员不存在主动推介及销售该产品的行为，并自愿承担可能产生的任何后果。`,
            confirmText: "我已知悉并继续"
        }
    } else
        return {}
}
function uXpProductDefaultRival({base: e, market: t}) {
    return uXpFundIs(e.fund_id, "pub") && e.compare_id ? e.compare_id : uXpFundIs(e.fund_id, "pri") && (t != null && t.compare_benchmark_index || e.primary_benchmark_id) ? (t == null ? void 0 : t.compare_benchmark_index) || e.primary_benchmark_id : ""
}
function uXpProductLegendVisible(e) {
    return !(e[1] === 100104 || e[2] === 10030102 || e[2] === 10030202 || e[1] === 100402)
}
function uXpProductIsZG(e) {
    return [3, 4, 8, 9].includes(+e)
}
const uXpProductScale = {
    chartHandler(e, t) {
        const r = []
          , n = [];
        let o = -1 / 0
          , a = 0
          , s = "1970-01-01"
          , i = 0;
        const l = [];
        return e.forEach(u => {
            ( () => {
                if (t.length && a < t.length) {
                    const f = dayjs(s).add(dayjs(u.fund_asset_size_date).diff(dayjs(s), "millisecond") / 2, "ms").format("YYYY-MM-DD")
                      , d = +i + (+u.fund_asset_size * 1e4 - +i) / 2;
                    let p = !1;
                    for (; a < t.length; ) {
                        if (+uXpFormatDateToZero(t[a]) > +uXpFormatDateToZero(u.fund_asset_size_date))
                            return;
                        a++,
                        !p && (p = !0,
                        r.push(""),
                        n.push(null),
                        l.push({
                            xAxis: f,
                            yAxis: d
                        }))
                    }
                }
            }
            )(),
            s = u.fund_asset_size_date,
            i = +u.fund_asset_size * 1e4,
            r.push(u.fund_asset_size_date),
            o = Math.max(o, +u.fund_asset_size * 1e4),
            n.push(+u.fund_asset_size * 1e4)
        }
        ),
        {
            x: r,
            y: n,
            markPointData: l,
            max: o
        }
    }
};
function uXpProductShowShortTip(e) {
    return [1, 3].includes(e) || e === 13 && new Date().getMonth() + 1 < 7
}
function uXpProductIsValid(e) {
    return e.is_wealth === 1 || e.is_show_index === 1
}
const uXpProductNAVSize = 10;
function uXpProductIsLiquidated(e) {
    return e.fund_status_id !== void 0 ? [4, 5, 8, 9].includes(e.fund_status_id) : e.fund_status !== void 0 ? e.fund_status.includes("清算") : !1
}
function uXpProductIsNavGuidance(e) {
    return e.is_wealth !== 1 && e.is_show_index !== 1 && !uXpProductIsLiquidated(e)
}
function uXpProductIsSale(e) {
    return uXpFundIs(e.fund_id, "pri") ? e.is_online_sale === 1 : e.is_sale === 1
}
function uXpProductPubBuyLimitCalc(e, t) {
    const r = +e;
    return isNaN$1(r) ? e : r > 1e9 || t && r === 0 ? "无限额" : uXpAssetExchange(r)
}
function uXpProductIsMonetary(e) {
    return unref(e).performance_disclosure_type === 2
}
function uXpProductIsShare(e, t) {
    var r;
    return e.is_wealth === 1 && !!((r = e.relation_fund_list) != null && r.length) && (t !== void 0 ? e.is_shareclass === t : [0, 1].includes(e.is_shareclass))
}
const uXpProductBuyProcess = [{
    name: "基金认购",
    value: '在认购期内，投资者可以提交基金认购申请，到基金成立期间，认购金额可享受银行<span class="c-black fw-700">活期收益</span>。新发基金如果发生比例配售，退回的资金会在募集结束后退回银行卡。'
}, {
    name: "基金成立",
    value: "基金一般会在募集结束后7个交易日左右成立，成立后的下一个交易日可以在持有详情中查询到对应的基金份额。"
}, {
    name: "基金建仓与运作",
    value: "基金成立后，基金经理一般会在3个月以内对基金进行投资建仓，这个期间称为基金的封闭建仓期，建仓期内会定期公布净值，详情以基金合同或基金管理人发布的公告内容为准。"
}, {
    name: "基金开放期",
    value: "根据每个基金的封闭时间不同，一般在封闭建仓期结束后开放买入与卖出，详情以基金合同或基金管理人发布的公告内容为准。"
}];
function uXpProductEarlierDate(e) {
    return e.filter(Boolean).length < 2 ? e.filter(Boolean).find(t => t) : e.sort( (t, r) => +uXpFormatDateToZero(t) - +uXpFormatDateToZero(r))[0]
}
function uXpProductIsP2PApplicable(e) {
    return +e.fund_type == 6 && !e.is_wealth && !e.is_show_index && (e.trust_id || e.company_id) && e.fund_status_id === 2
}
function uXpProductCLRQKeyName(e) {
    return unref(e).is_wealth && unref(e).is_shareclass ? "份额设立日" : "成立日期"
}
function userCheck(e, t) {
    return until(computed( () => useUserStore().loginStatus)).not.toBe("waiting").then( () => {
        let r = {
            closeable: !1,
            onlyCheck: !0,
            onlyLogin: !1,
            onlySuccess: !0,
            checkQualified: !0
        };
        return e instanceof Function ? t = e : r = {
            ...r,
            ...e
        },
        uXsCheckHandler(r, t)
    }
    )
}
async function enregisterCommonCheck() {
    return await useUserStore().getInvestorInfo(),
    useUserStore().info.real_name_auth !== 1 || useUserStore().isCertificateExpired || !useUserStore().isOtherCompleted || !useUserStore().isSpecialEvaluated
}
async function uXpEnregisterPriCheck(e, t) {
    return await userCheck().catch( () => Promise.reject(new Error("[EnregisterPriCheck]弱实名未通过",{
        cause: {
            status: 1
        }
    }))),
    await enregisterCommonCheck() || useUserStore().info.is_special_investor || (uXpProductIsZG(t) ? !useUserStore().isManagementEffective : !useUserStore().isInvestorEffective) ? Promise.reject(new Error("[EnregisterPriCheck]强实名未通过",{
        cause: {
            status: 2
        }
    })) : Promise.resolve()
}
const useReportStore = defineStore("report", {
    state: () => ({
        wxSystemInfo: {}
    }),
    actions: {
        decodeWeAppSystemInfo() {
            return JSON.parse(useRoute$1().query.systemInfo || "{}")
        }
    }
})
  , encode = async e => {
    const {JSEncrypt: t} = await __vitePreload(async () => {
        const {JSEncrypt: c} = await import("./YsuGZQKX.js");
        return {
            JSEncrypt: c
        }
    }
    , __vite__mapDeps([122, 123]), import.meta.url)
      , {hex2b64: r} = await __vitePreload(async () => {
        const {hex2b64: c} = await import("./qjhiAhXC.js").then(f => f.f);
        return {
            hex2b64: c
        }
    }
    , [], import.meta.url)
      , n = new t;
    n.setPublicKey(uXpConfig().reportPublicKey);
    const o = function(c) {
        const f = n.getKey();
        try {
            let d = "";
            const p = [];
            p.push(0);
            let m = 0;
            const g = c.length;
            let _, b = 0;
            for (let y = 0; y < g; y++)
                _ = c.charCodeAt(y),
                _ >= 65536 && _ <= 1114111 ? m += 4 : _ >= 2048 && _ <= 65535 ? m += 3 : _ >= 128 && _ <= 2047 ? m += 2 : m += 1,
                (m % 117 >= 114 || m % 117 === 0) && m - b >= 114 && (p.push(y),
                b = m);
            if (p.length > 1) {
                for (let y = 0; y < p.length - 1; y++) {
                    let v;
                    y === 0 ? v = c.substring(0, p[y + 1] + 1) : v = c.substring(p[y] + 1, p[y + 1] + 1),
                    d += f.encrypt(v)
                }
                if (p[p.length - 1] !== c.length - 1) {
                    const y = c.substring(p[p.length - 1] + 1);
                    d += f.encrypt(y)
                }
                return r(d)
            }
            return r(f.encrypt(c))
        } catch {
            return !1
        }
    }
      , a = useEnvStore().isPc ? uXpConfig().reportPcToken : uXpConfig().reportMobileToken
      , s = (+new Date + Math.floor(Math.random() * 1e8)).toString()
      , i = ~~(+new Date / 1e3);
    let l = [a, i, s.split("").reverse().join(""), SHA1(a.substring(0, 16)).toString()];
    l = l.sort().join("");
    const u = SHA1(l).toString() + SHA1(l.split("").reverse().join("")).toString();
    return o(window.btoa(unescape(encodeURIComponent(JSON.stringify({
        ...e,
        nonce: s,
        ts: i,
        sign: u
    })))).replace(/\//g, "-"))
}
;
async function uXpReport(e, t={}) {
    await until(computed( () => useUserStore().loginStatus)).not.toBe("waiting");
    const r = window.navigator.userAgent
      , n = {
        "iPhone|iPad": "iOS",
        Macintosh: "mac",
        Android: "Android",
        windows: "windows"
    };
    let o = `其他(${r} platform: ${window.navigator.platform})`
      , a = useEnvStore().fromApp ? "app" : "mobile";
    for (const f of Object.keys(n))
        new RegExp(f,"i").test(r) && (o = n[f]);
    /windows|mac/.test(o) && (a = "pc");
    const s = {
        click: {
            location: t.location,
            click_name: t.click_name,
            ad_key_word: t.ad_key_word,
            item_type: t.item_type,
            item_id: t.item_id,
            item_name: t.item_name
        },
        login: {},
        pageview: {
            item_id: t.item_id || "",
            item_name: t.item_name || "",
            item_type: t.item_type || null,
            item_company_id: t.item_company_id || null,
            item_company_name: t.item_company_name || null
        },
        pk: {
            pk_type: t.pk_type,
            item_list_id: t.item_list_id
        },
        portfolio: {
            portfolio_type: t.portfolio_type || 0,
            item_list_id: t.item_list_id
        }
    }[e]
      , i = useEnvStore().fromWeApp ? ( () => {
        const f = new URLSearchParams(location.search);
        return f.delete("fromWeApp"),
        f.delete("fromPubWeApp"),
        f.delete("wxSign"),
        f.delete("pp_token"),
        f.delete("systemInfo"),
        location.href.split("?")[0] + "?" + f.toString()
    }
    )() : location.href
      , l = {
        event_name: `events_${e}`,
        userid: t.userid || useUserStore().info.uid || 0,
        page_name: t.page_name ?? document.title,
        page_url: i,
        time: useDateFormat(useNow(), "YYYY-MM-DD HH:mm:ss").value
    };
    let u = {};
    if (useEnvStore().fromWeApp) {
        const f = useReportStore().wxSystemInfo;
        a = f.platform,
        u = {
            equ_id: f.equ_id,
            os: f.os,
            os_version: f.os_version,
            platform: f.platform,
            app_version: f.app_version,
            app_name: f.app_name,
            equ_model: f.equ_model
        }
    } else {
        const f = []
          , d = []
          , p = navigator.userAgent.match(/([^)]*)$/);
        p && p[1].split(" ").filter(Boolean).forEach(m => {
            const [g,_] = m.split("/");
            d.push(g || ""),
            f.push(_ || "")
        }
        ),
        u = {
            equ_id: "",
            os: o,
            platform: a,
            app_version: useEnvStore().appVersion || "",
            app_name: "",
            equ_model: f.join("~"),
            equ_company: d.join("~")
        }
    }
    const c = {
        ...u,
        ...s,
        ...l
    };
    return e === "click" && t.page_url && (c.page_url = t.page_url),
    useEnvStore().fromApp ? (uXsJsbridgeCall("eventReport", c),
    Promise.resolve()) : uXpFetch(uXpConfig().trackHost + "/api/main/events/report", {
        method: "POST",
        extraHeaders: {
            platform: encodeURIComponent(a)
        },
        data: {
            data: await encode(c),
            url: i
        },
        successProcess: !1
    })
}
ref("");
function useXsReportGJFX(e) {
    const t = useState( () => shallowRef({}), "$TBb6XVK5AN");
    return e && (t.value = e),
    t
}
const uXsLogin = {
    comp: void 0,
    async show(e) {
        uXsLogin.comp || (uXsLogin.comp = useXpMount2body((await __vitePreload(async () => {
            const {default: t} = await import("./CTPfC6uf.js");
            return {
                default: t
            }
        }
        , __vite__mapDeps([124, 60, 2, 3, 40, 61, 41, 23, 42, 25, 125, 110, 120, 126]), import.meta.url)).default).instance),
        uXsLogin.comp.display(e)
    },
    hide() {
        uXsLogin.comp.hide()
    }
}
  , uXsAuth = {
    comp: void 0,
    async show(e) {
        uXsAuth.comp || (uXsAuth.comp = useXpMount2body((await __vitePreload(async () => {
            const {default: t} = await import("./D9dRy5ZG.js");
            return {
                default: t
            }
        }
        , __vite__mapDeps([127, 2, 3, 41, 23, 42, 45, 46, 37, 12, 13, 14, 38, 39, 40, 21, 22, 43, 1, 4, 33, 34, 128]), import.meta.url)).default).instance),
        uXsAuth.comp.show(e)
    },
    hide() {
        uXsAuth.comp.hide()
    }
}
  , uXsAppoint = {
    comp: void 0,
    async show(e) {
        uXsAppoint.comp || (uXsAppoint.comp = useXpMount2body((await __vitePreload(async () => {
            const {default: t} = await import("./BaxF9V-l.js");
            return {
                default: t
            }
        }
        , __vite__mapDeps([129, 130, 2, 3, 45, 46, 125, 131]), import.meta.url)).default).instance),
        uXsAppoint.comp.show(e)
    },
    hide() {
        uXsAppoint.comp.hide()
    }
}
  , uXsWxService = {
    comp: void 0,
    async show() {
        uXsWxService.comp || (uXsWxService.comp = useXpMount2body((await __vitePreload(async () => {
            const {default: e} = await import("./BdXMsUsu.js");
            return {
                default: e
            }
        }
        , __vite__mapDeps([132, 55, 2, 3, 56]), import.meta.url)).default).instance),
        uXsWxService.comp.show()
    },
    hide() {
        uXsWxService.comp.hide()
    }
}
  , DEFAULT_CONFIG = {
    autofocus: !1
}
  , MESSAGE_BOX_DEFAULT_OPTS = {
    alert: {
        closeOnPressEscape: !1,
        closeOnClickModal: !1
    },
    confirm: {
        showCancelButton: !0
    },
    prompt: {
        showCancelButton: !0,
        showInput: !0
    }
};
function uXsMessageBox(e) {
    const t = e.boxType || "alert"
      , r = {
        ...DEFAULT_CONFIG,
        ...MESSAGE_BOX_DEFAULT_OPTS[t],
        cancelButtonClass: `is-text ${e.cancelButtonClass || ""}`,
        modalClass: [e.backdropFilter && "backdrop-filter-6", e.enableWhitespace && "enable-whitespace"].filter(Boolean).join(" "),
        ...e,
        customClass: ["xs-message-box", e.customClass].filter(Boolean).join(" ")
    };
    return e.cancelButtonText && !("showCancelButton"in e) && (r.showCancelButton = !0),
    !e.callback && (e.confirmCb || e.cancelCb) && (r.callback = n => {
        n === "confirm" ? e.confirmCb && e.confirmCb() : n === "cancel" ? e.cancelCb && e.cancelCb() : n === "close" && e.closeCb && e.closeCb()
    }
    ),
    ElMessageBox[t](e.message, r)
}
function uXsMessage(e, t={}) {
    return typeof t == "string" && (t = {
        type: t
    }),
    ElMessage({
        ...t,
        offset: 72,
        message: e
    })
}
function uXsCheckHandler(e, t) {
    const r = () => !e.onlySuccess && (t == null ? void 0 : t());
    if (useUserStore().loginStatus === "undone")
        return r(),
        e.onlyCheck || uXsLogin.show({
            closeable: e.closeable
        }),
        Promise.reject(new Error("未登录"));
    if (!e.onlyLogin && (!useUserStore().isCertificated || !useUserStore().isEvaluated || e.checkQualified && !useUserStore().isQualified))
        return r(),
        e.onlyCheck || uXsAuth.show({
            closeable: e.closeable,
            checkQualified: e.checkQualified
        }),
        Promise.reject(new Error("未认证"));
    t == null || t()
}
function uXsDownload(e, t="default.png") {
    const r = document.createElement("a");
    r.href = e,
    r.download = t,
    r.dispatchEvent(new MouseEvent("click"))
}
function uXsUnreceivedCodeTips() {
    return uXsMessageBox({
        title: "收不到验证码",
        dangerouslyUseHTMLString: !0,
        message: `<p>如果您收不到验证码，请确认以下信息：</p>
<ul style="margin-top: 16px;padding-left: 20px;">
<li style="list-style: disc;line-height: 26px">您输入的手机号是否准确无误； </li>
<li style="list-style: disc;line-height: 26px">您的手机信号是否畅通，请保证手机信号正常井能接收短信;</li>
<li style="list-style: disc;line-height: 26px">您的手机号是否欠费停机，请缴费恢复后再次尝试；</li>
<li style="list-style: disc;line-height: 26px">您的手机中是否安装了短信拦截软件，请删除软件或找回短信验证码；</li>
</ul>
<div style="margin-top: 16px">如果确认后仍无法收到验证码，您可以前往<a style="color: #007aff" target="_blank" href="${uXsRoutes().feedback.fullPath}">【意见反馈】</a>页面提交反馈给我们，我们会尽快查看与核实。</div>
`,
        confirmButtonText: "我知道了",
        customStyle: {
            "--el-messagebox-width": "500px"
        }
    })
}
const uXsCopy2Favor = {
    comp: void 0,
    async show(e) {
        uXsCopy2Favor.comp || (uXsCopy2Favor.comp = useXpMount2body((await __vitePreload(async () => {
            const {default: t} = await import("./Bk2rD15r.js");
            return {
                default: t
            }
        }
        , __vite__mapDeps([133, 41, 2, 3, 23, 42, 30, 31, 12, 13, 14, 49, 11, 15, 16, 134, 87]), import.meta.url)).default).instance),
        uXsCopy2Favor.comp.show(e)
    },
    hide() {
        var e;
        (e = uXsCopy2Favor.comp) == null || e.hide()
    }
}
  , uXsStoreCollectHandler = e => ElMessage.success(e.collected ? e.cancel ?? `取消${e.text}成功` : e.add ?? `${e.text}成功`)
  , uXsMount2bodyHandler = e => e.provide(ID_INJECTION_KEY, {
    prefix: 1024,
    current: 0
}).provide(ZINDEX_INJECTION_KEY, {
    current: useZIndex().currentZIndex.value - 2e3
});
function uXsAssetsExchange(e) {
    return e < 1e4 ? e + "元" : e >= 1e4 && e < 1e8 ? (+e / 1e4).toFixed(2) + "万元" : (+e / 1e8).toFixed(2) + "亿元"
}
const uXsP2PApply = {
    comp: void 0,
    async show(e) {
        {
            const t = useState( () => ({
                modelValue: !0,
                "onUpdate:modelValue": r => {
                    t.value.modelValue = r
                }
                ,
                fund: {}
            }), "$AyrX0F365v");
            uXsP2PApply.comp ?? (uXsP2PApply.comp = useXpMount2body((await __vitePreload(async () => {
                const {default: r} = await import("./CqhE9Pb7.js");
                return {
                    default: r
                }
            }
            , __vite__mapDeps([135, 17, 2, 3, 12, 13, 14, 21, 41, 23, 42, 18, 19, 136]), import.meta.url)).default, t.value)),
            t.value.modelValue = !0,
            t.value.fund = e.fund
        }
    },
    check(e) {
        return uXsGJFXPreCheck().then(t => {
            var r, n, o, a;
            if ([2, 3].includes(t == null ? void 0 : t.company_type)) {
                if (((r = t == null ? void 0 : t.sub_info) == null ? void 0 : r.audit_status) === 1)
                    throw uXsMessageBox({
                        message: "您提交的身份材料正在审核中，请耐心等待"
                    }),
                    new Error("[P2PApply]二次提交审核中",{
                        cause: {
                            status: 1
                        }
                    });
                if (((n = t == null ? void 0 : t.sub_info) == null ? void 0 : n.audit_status) === 3 || !((o = t == null ? void 0 : t.business_license) != null && o.length) || !((a = t == null ? void 0 : t.financial_business_license) != null && a.length))
                    throw window.open(uXsRoutes().crtUpload.fullPath({
                        query: {
                            back_url: location.href,
                            apply_type: 1
                        }
                    })),
                    new Error("[P2PApply]对应机构类型材料缺失")
            }
            return useUserExtendStore().getInfo()
        }
        ).then(async () => {
            if (useUserExtendStore().info.is_fof_master) {
                if (await useUserExtendStore().getEmail(),
                !useUserExtendStore().email.length)
                    return window.open(uXpStaticFOFEmailURL());
                if (!uXpProductIsP2PApplicable(e))
                    return uXsMessageBox({
                        message: "该基金暂不支持申请点对点净值，我们正在积极对接中，请耐心等待"
                    });
                uXsP2PApply.show({
                    fund: e
                });
                return
            }
            if (useUserStore().info.is_special_investor || !useUserStore().isInvestorEffective)
                return uXsMessageBox({
                    message: `请先拨打客服电话${uXpStaticTel}，开通高阶分析功能`,
                    confirmButtonText: "我知道了"
                });
            uXsMessageBox({
                message: "您的自建净值库功能尚未开通，请先联系您的客户成功经理。",
                confirmButtonText: "联系客户成功经理",
                cancelButtonText: "取消",
                callback(t) {
                    t === "confirm" && uXsAppoint.show({
                        content: "开通【自建净值库】功能",
                        id: e.fund_id,
                        cont: "自建净值库功能开通申请已提交成功，您的客户成功经理稍后将与您进行联系"
                    })
                }
            })
        }
        )
    }
};
function uXsGJFXPreCheck() {
    return uXpEnregisterPriCheck().catch(async e => {
        if (e.cause.status === 2) {
            uXpReport("click", useXsReportGJFX().value);
            const {data: t} = await getOrgRecord();
            if ((t == null ? void 0 : t.audit_status) === 2)
                return t;
            if ((t == null ? void 0 : t.audit_status) === 1)
                throw uXsMessageBox({
                    message: "您提交的身份材料正在审核中，请耐心等待"
                }),
                new Error("审核中",{
                    cause: {
                        status: 1
                    }
                });
            if (!(t != null && t.audit_status) || [3, 4].includes(t.audit_status)) {
                const r = useState( () => ({
                    modelValue: !0,
                    "onUpdate:modelValue": n => {
                        r.value.modelValue = n
                    }
                }), "$uSHhTP6s8m");
                throw uXsGJFXPreCheck.mark ?? (uXsGJFXPreCheck.mark = useXpMount2body((await __vitePreload(async () => {
                    const {default: n} = await import("./Dslga1CL.js");
                    return {
                        default: n
                    }
                }
                , __vite__mapDeps([137, 18, 2, 3, 13, 19, 10, 138]), import.meta.url)).default, r.value)),
                r.value.modelValue = !0,
                new Error("未通过",{
                    cause: {
                        status: 2
                    }
                })
            }
        }
    }
    )
}
function uXsFetchCatch(e) {
    try {
        ElMessage.error(e.result.msg)
    } catch (t) {
        console.error(t)
    }
}
function uXsFetchNotSuccess(e) {
    var t;
    ((t = e == null ? void 0 : e.extra) == null ? void 0 : t.to_login) === 1 && location.reload()
}
class ResError extends Error {
    constructor(r, n=null) {
        super(r);
        ne(this, "name", "ResError");
        ne(this, "result", null);
        n === null ? this.result = {
            msg: r
        } : this.result = n
    }
}
const MD5 = e => md5(e).toString()
  , Crypto = new class {
    constructor() {
        ne(this, "defaultToken", "814a43980a8952c35b75d1502c61ca84");
        ne(this, "token", "");
        ne(this, "kk");
        ne(this, "iv");
        this.setToken(this.defaultToken)
    }
    setToken(e) {
        this.token = e,
        this.kk = UTF8.parse(this.token),
        this.iv = UTF8.parse(this.token.slice(16, 32))
    }
    encrypt(e, t) {
        this.setToken(t && MD5(t) || this.defaultToken);
        const r = AES.encrypt(JSON.stringify(e), this.kk, {
            iv: this.iv,
            padding: pkcs7
        });
        return window.btoa(r.toString())
    }
}
  , decrypt = data => {
    var _a = {}
      , _0xb483 = ["_decode", "http://www.sojson.com/javascriptobfuscator.html"];
    (function(e) {
        e[_0xb483[0]] = _0xb483[1]
    }
    )(_a);
    var __Ox11208b = ["encode", "aes", "wxSign", "data", "atob", "parse", "slice", "decrypt", "script", "createElement", "text", "key", "appendChild", "body", "window.", "id", "", "join", "reverse", "split", "length", "charCodeAt", "fromCharCode", "undefined", "log", "删除", "版本号，js会定", "期弹窗，", "还请支持我们的工作", "jsjia", "mi.com"];
    if (data && data[__Ox11208b[0]] === __Ox11208b[1]) {
        const e = MD5(useUserStore()[__Ox11208b[2]]);
        let t = AES[__Ox11208b[7]](window[__Ox11208b[4]](data[__Ox11208b[3]]), UTF8[__Ox11208b[5]](e), {
            iv: UTF8[__Ox11208b[5]](e[__Ox11208b[6]](16, 32)),
            padding: pkcs7
        });
        data = JSON[__Ox11208b[5]](t.toString(UTF8))[__Ox11208b[3]]
    } else if (data && data[__Ox11208b[0]]) {
        let script = document[__Ox11208b[9]](__Ox11208b[8]);
        script[__Ox11208b[10]] = data[__Ox11208b[11]],
        document[__Ox11208b[13]][__Ox11208b[12]](script);
        let key = ( () => {
            let code = data[__Ox11208b[0]]
              , key = eval(__Ox11208b[14] + data[__Ox11208b[15]]);
            return code === 3 ? key = key[__Ox11208b[19]](__Ox11208b[16])[__Ox11208b[18]]()[__Ox11208b[17]](__Ox11208b[16]) : code === 4 ? key = key[__Ox11208b[6]](2) : code === 5 ? key = key[__Ox11208b[6]](0, key[__Ox11208b[20]] - 2) : code === 6 ? key = key[__Ox11208b[6]](1, key[__Ox11208b[20]] - 1) : code === 7 ? key = key[__Ox11208b[6]](2, key[__Ox11208b[20]] - 1) : code === 8 ? key = key[__Ox11208b[6]](1, key[__Ox11208b[20]] - 2) : code === 9 ? key = key[0] + key[__Ox11208b[6]](2, key[__Ox11208b[20]]) : code === 10 && (key = key[__Ox11208b[6]](0, key[__Ox11208b[20]] - 2) + key[key[__Ox11208b[20]] - 1]),
            key
        }
        )()
          , datas = data[__Ox11208b[3]];
        if (key !== void 0)
            if (data[__Ox11208b[0]] > 2) {
                let e = MD5(key)
                  , t = UTF8[__Ox11208b[5]](e)
                  , r = UTF8[__Ox11208b[5]](e[__Ox11208b[6]](16, 32))
                  , o = AES[__Ox11208b[7]](window[__Ox11208b[4]](datas), t, {
                    iv: r,
                    padding: pkcs7
                }).toString(UTF8);
                data = JSON[__Ox11208b[5]](o)
            } else {
                let e = window[__Ox11208b[4]](datas)
                  , t = key[__Ox11208b[20]]
                  , r = __Ox11208b[16];
                for (let n = 0; n < e[__Ox11208b[20]]; n++) {
                    let o = n % t;
                    r += String[__Ox11208b[22]](e[__Ox11208b[21]](n) ^ key[__Ox11208b[21]](o))
                }
                data = JSON[__Ox11208b[5]](window[__Ox11208b[4]](r))
            }
    }
    return data
}
  , onRequest = ({options: e}) => {
    if (e.data instanceof FormData) {
        e.body = e.data,
        e.method = "POST";
        return
    }
    e.data || (e.data = {}),
    e.encryptData && (uXpConfig().reqLoose ? e.data = {
        ...e.data,
        ...e.encryptData,
        sign_off: 1
    } : e.data.sdata = Crypto.encrypt(e.encryptData, useEnvStore().isMiniProgram ? useUserStore().wxSign : e.encryptKey)),
    (e.refresh || useRoute$1().query.reflash === "1") && (e.data.reflash_cache = 1),
    useUserStore().info.uid && (e.data.USER_ID = useUserStore().info.uid),
    useEnvStore().isMobile && (e.data.from_wx = useEnvStore().isMiniProgram ? 1 : 0,
    e.data.sign = useUserStore().wxSign,
    e.data.pp_token = useUserStore().ppToken,
    e.data.from_app = +useEnvStore().fromApp),
    Object.keys(e.data).length && (e.method === "GET" ? e.query = e.data : e.body = lib.stringify(e.data))
}
  , onResponse = function({response: e}) {
    if (typeof e._data == "string")
        try {
            e._data = JSON.parse(e._data)
        } catch {}
    try {
        e._data.data = JSON.parse(e._data)
    } catch {}
    e._data.data = decrypt(e._data.data)
};
async function uXpFetch(e, t={}) {
    const n = {
        ...{
            baseURL: uXpConfig().apiHost,
            headers: {
                "Content-type": "application/x-www-form-urlencoded",
                "X-Requested-With": useEnvStore().a
            },
            credentials: "include",
            timeout: 3e4,
            method: "GET",
            successProcess: !0,
            onRequest,
            onResponse
        },
        ...t
    };
    n.baseURL !== uXpConfig().apiHost && delete n.headers["X-Requested-With"],
    n.data instanceof FormData && delete n.headers["Content-type"];
    let o;
    const a = $fetch;
    return n.requireUserid && await until(computed( () => useUserStore().loginStatus)).not.toBe("waiting"),
    n.successProcess ? o = a(e, n).then(s => {
        if (s.status !== 1)
            throw uXsFetchNotSuccess(s),
            new ResError(s.msg,s);
        return s
    }
    ) : o = a(e, n),
    o
}

var xxx = '';
var _uXpFetch = uXpFetch;
uXpFetch = function (e, t) {
    xxx+=e;
    console.log(xxx);
    return _uXpFetch(e, t);
}

const getInvestorInfo = e => uXpFetch("/trade/Account/investorInfo", {
    refresh: e
})
  , buySellRateRule = e => uXpFetch("/trade/PubTrade/buySellRateRule", {
    method: "POST",
    encryptKey: useEnvStore().a,
    encryptData: e
})
  , avatar1 = "" + new URL("userDefAvatar1.BiOtUGwX.png",import.meta.url).href
  , avatar2 = "" + new URL("userDefAvatar2.fMTbtlAk.png",import.meta.url).href
  , postViewLog = e => userCheck( () => {
    uXpFetch("/DirectPP/index", {
        data: {
            token: useUserStore().token,
            app_type: 1,
            app_install_version: "9.1.1",
            interface_type: "apply_view_detail_log",
            ...e
        },
        baseURL: uXpConfig().appApiHost,
        method: "post",
        successProcess: !1
    })
}
)
  , postWebIMReport = e => userCheck( () => {
    uXpFetch("/WebIM/index", {
        data: {
            token: useUserStore().token,
            app_type: 1,
            app_install_version: "9.1.1",
            interface_type: "apply_view_detail_log",
            ...e
        },
        baseURL: uXpConfig().appApiHost,
        method: "post",
        successProcess: !1
    })
}
);
function toggleCollection(e, t, r=1, n) {
    return r === 1 && /^(HF|MF)/i.test(e) && postViewLog({
        view_position: 11,
        view_key: e
    }),
    uXpFetch(`/sun/ApCollection/${r ? "newCollection" : "removeCollection"}`, {
        data: {
            key: e,
            type: t,
            group_id: void 0
        }
    })
}
const getCollection = (e="all", t=0) => uXpFetch("/sun/User/myFundCollectList", {
    data: {
        group_id: e,
        is_select: t
    }
})
  , getCollectionIds = e => uXpFetch("/sun/user/myCollectIds", {
    data: {
        list_type: e
    }
})
  , getCollectionStatus = e => uXpFetch("/sun/ApCollection/getCollectionStatus", {
    data: e
})
  , getGroupList = e => uXpFetch("/sun/User/myFundCollectGroup", {
    data: e
})
  , postAddGroup = e => uXpFetch("/sun/ApCollection/newGroup", {
    data: {
        group_name: e
    }
})
  , moveFund = e => uXpFetch("/sun/ApCollection/moveCollection", {
    data: {
        ...e,
        key: JSON.stringify(e.key),
        to_group_id: JSON.stringify(e.to_group_id)
    }
})
  , getIMsignature = () => uXpFetch("/sun/member/getIMsignature", {
    method: "POST"
})
  , getTotalUserPC = () => uXpFetch("/WebIM/index", {
    baseURL: uXpConfig().appApiHost,
    method: "post",
    data: {
        token: useUserStore().token,
        interface_type: "get_total_user_PC",
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0"
    },
    successProcess: !1
})
  , getChatListByPN = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "get_chat_list_by_platform_name",
        platform_name: JSON.stringify(e)
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getViewList = (e, t) => uXpFetch("/DirectLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: e,
        ...t
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getIMUserInfo = () => uXpFetch("/DirectPP/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "get_user_info_by_token"
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getSuperInfo = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "chat_customer_info",
        user_key: e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getWelcomeMsgList = () => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "get_welcome_msg_list"
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , checkGroup = (e, t={}) => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.18.0",
        interface_type: "super_check_user_has_group",
        company_id: e,
        ...t
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , createGroup = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.18.0",
        interface_type: "create_group_by_admin",
        ...e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getGroupInfo = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "get_group_info",
        group_id: e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , modifyGroupData = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "modify_group_data",
        ...e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getManagerAgentInfo = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "manager_agent_info",
        user_key: e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , deleteGroupMember = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "delete_group_member",
        ...e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , sendTextMessage = (e, t, r) => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.16.0",
        interface_type: "send_text_message",
        from_platform_name: e,
        to_platform_name: t,
        message: r
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getSuperQuestionList = e => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.19.0",
        interface_type: "get_super_subject_list",
        company_id: e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getGroupSubjectApply = (e, t) => uXpFetch("/WebIM/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.19.0",
        interface_type: "get_group_subject_reply",
        subject_id: t,
        group_id: e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , getGroupInviteList = (e, t=10) => uXpFetch("/SuperLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.19.0",
        interface_type: "get_group_invite_list",
        page: e,
        rows: t
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , applyChatTop = e => uXpFetch("/DirectLink/index", {
    data: {
        token: useUserStore().token,
        log_type: "chat",
        scene: 1,
        app_type: 1,
        business_type: 1,
        app_install_version: "8.18.0",
        interface_type: "apply_chat_top",
        chat_top_json: e
    },
    baseURL: uXpConfig().appApiHost,
    method: "post",
    successProcess: !1
})
  , useTimStore = defineStore("tim", {
    state: () => ({
        tim: null,
        ready: !1,
        show: !0,
        user_key: "",
        link_name: "",
        gid: "",
        personnel_name: "",
        company_name: "",
        company_id: "",
        account_type: "",
        consultation_type: 0,
        fund_short_name: "",
        content_key: "",
        content: "",
        platform_name: "",
        helper: {
            helper_name: "",
            helper_icon: "",
            helper_id: ""
        },
        timInfo: {
            super_list: [],
            auto_reply_config: {},
            super_scroll_config: [],
            is_mark_tonghang: 0
        },
        imInfo: {},
        chatSource: "",
        clearUnreadPN: "",
        otherPN: "",
        chatMsg: {},
        superUnreadCount: 0,
        groups: null,
        extra: null,
        imUserInfoLoaded: !1,
        inviteNum: -1
    }),
    getters: {
        totalUnread() {
            return this.inviteNum === -1 ? 0 : this.superUnreadCount + this.inviteNum
        }
    },
    actions: {
        async getUserInfo() {
            try {
                const e = await getIMUserInfo();
                e.status === 0 && (this.timInfo = e.data,
                this.imUserInfoLoaded = !0)
            } catch {}
        },
        userInfoLoaded() {
            this.imUserInfoLoaded = !0
        },
        setTimShow(e) {
            this.show = e
        },
        setTimIns(e) {
            this.tim = e,
            window.tim = this.tim
        },
        setTimReady(e) {
            this.ready = e
        },
        setLinkName(e="") {
            this.link_name = e
        },
        setTim(e) {
            this.user_key = e.user_key || this.user_key,
            this.link_name = e.link_name,
            this.gid = e.gid || "",
            this.personnel_name = e.personnel_name || this.personnel_name,
            this.company_name = e.company_name || this.company_name,
            this.company_id = e.company_id || this.company_id,
            this.content_key = e.content_key || this.content_key,
            this.consultation_type = e.consultation_type,
            this.fund_short_name = e.fund_short_name,
            this.content = e.content,
            this.account_type = e.account_type || 2,
            e.source && (this.chatSource = e.source)
        },
        setChatMsg(e) {
            this.chatMsg = e
        },
        setPN(e) {
            this.platform_name = e
        },
        setSuperUnreadCount(e) {
            this.superUnreadCount = e < 0 ? 0 : e
        },
        setInviteNum(e) {
            this.inviteNum = e < 0 ? 0 : e
        },
        setTimInfo(e) {
            this.timInfo = e
        },
        setHelper(e) {
            this.helper = {
                helper_icon: e.helper_icon,
                helper_id: e.helper_id,
                helper_name: e.helper_name
            }
        },
        setIMInfo(e) {
            this.imInfo = e
        },
        setOtherPN(e) {
            this.otherPN = e
        },
        setClearUnreadPN(e) {
            this.clearUnreadPN = e
        },
        clearSource() {
            this.chatSource = ""
        },
        setGroups(e) {
            this.groups = e
        },
        setExtra(e) {
            this.extra = e
        },
        CLEAR_CONSULTATION() {
            this.content_key = "",
            this.consultation_type = 0,
            this.fund_short_name = ""
        },
        SET_LINE_STATE(e) {
            this.timInfo.line_state = e
        },
        applyChatTop(e, t, r) {
            let n = [...this.timInfo.chat_top];
            t ? n.unshift(e) : n = n.filter(o => o !== e),
            applyChatTop(JSON.stringify(n)).then(o => {
                (o == null ? void 0 : o.status) === 0 && (this.timInfo.chat_top = n,
                r && r())
            }
            )
        }
    }
});
function useXpUserDone() {
    return until(computed( () => useUserStore().loginStatus)).toBe("done")
}
const useUserStore = defineStore("user", {
    state: () => ({
        info: {},
        investorInfo: {},
        token: "",
        collection: new Set,
        collectLoading: !1,
        collectLoaded: new Set,
        autologinDone: !1,
        ppToken: "",
        wxSign: ""
    }),
    actions: {
        async getUserInfo(e) {
            if (e || this.info.uid === void 0)
                try {
                    const t = await getUserInfo(e);
                    if ((t == null ? void 0 : t.status) !== 1)
                        return this.info.uid = "",
                        this.info.icon = avatar1,
                        Promise.reject(new Error("未获取到用户信息"));
                    this.info = t.data,
                    useEnvStore().isMiniProgram && (this.token = this.info.quiz_token),
                    this.info.icon || (this.info.icon = this.info.sex === 2 ? avatar2 : avatar1),
                    this.info.type !== 1 && useTimStore().userInfoLoaded()
                } catch (t) {
                    return console.error(t),
                    Promise.reject(new Error("请求错误"))
                }
            return this.info
        },
        async getInvestorInfo(e) {
            if (e || this.investorInfo.userid === void 0)
                try {
                    await useXpUserDone();
                    const t = await getInvestorInfo(e);
                    if ((t == null ? void 0 : t.status) !== 1)
                        return this.investorInfo.userid = 0,
                        Promise.reject(new Error("未获取到用户信息"));
                    this.investorInfo = t.data
                } catch (t) {
                    return console.error(t),
                    Promise.reject(new Error("请求错误"))
                }
            return this.investorInfo
        },
        async toggleCollect(e, t) {
            return await new Promise( (r, n) => {
                userCheck({
                    onlyCheck: !1,
                    onlyLogin: !0
                }, async () => {
                    const o = this.toggleCollect.prototype;
                    if (o.loading)
                        return;
                    const a = typeof e == "string" ? e : e.id
                      , s = typeof e == "string" ? this.collection.has(e) : e.collected ?? this.collection.has(e.id)
                      , i = typeof e == "string" || e.type === void 0 ? uXpCollectType(a) : e.type;
                    o.loading = !0;
                    const {data: l, status: u, msg: c} = await toggleCollection(a, i, +!s);
                    if (o.loading = !1,
                    u === 1) {
                        if (t !== !1) {
                            const f = ((t == null ? void 0 : t.textType) ?? (uXpThisIdIs(a, "fund") ? 1 : void 0)) === 1 ? "自选" : "关注";
                            uXsStoreCollectHandler({
                                collected: s,
                                add: t == null ? void 0 : t.up,
                                cancel: t == null ? void 0 : t.down,
                                text: f
                            })
                        }
                        a.split(",").forEach(f => {
                            s ? this.collection.delete(f) : this.collection.add(f)
                        }
                        ),
                        r({
                            method: s ? "cancel" : "add",
                            data: l
                        })
                    } else
                        n(new Error(c))
                }
                )
            }
            )
        },
        initCollect(e="fund") {
            const t = e.split(",").filter(r => !this.collectLoaded.has(r));
            if (!(this.collectLoading || this.collectLoaded.has(e) || !t.length))
                return this.collectLoading = !0,
                getCollectionIds(t.join(",")).then(r => {
                    r.status === 1 && (t.forEach(n => this.collectLoaded.add(n)),
                    (r.data ?? []).forEach(n => {
                        this.collection.add(n)
                    }
                    ))
                }
                ).finally( () => {
                    this.collectLoading = !1
                }
                )
        }
    },
    getters: {
        isNewComer() {
            return this.info.createtime ? (new Date().getTime() - new Date(this.info.createtime).getTime()) / (1e3 * 60 * 60 * 24) <= 30 : !1
        },
        loginStatus() {
            return this.info.uid === void 0 ? "waiting" : this.info.uid === "" ? "undone" : "done"
        },
        isCertificated() {
            return +this.info.certification == 1
        },
        isCertificateExpired() {
            return +new Date > +uXpFormatDateToZero(this.info.card_end_date)
        },
        isEvaluated() {
            return this.info.evaluation_result !== -1 && this.info.evaluation_expiration_status !== 1
        },
        isSpecialEvaluated() {
            return this.investorInfo.evaluation_result !== -1 && this.investorInfo.evaluation_expiration_status !== 1
        },
        isQualified() {
            return +this.info.qualified_investor == 1
        },
        pass() {
            return +this.info.uid > 0 && this.isCertificated && this.isEvaluated && this.isQualified
        },
        isSuperService() {
            return this.info.type === 5
        },
        isAgentB() {
            return this.info.type === 6
        },
        isPartner() {
            return +this.info.source == 30005 || +this.info.source == 31002
        },
        isManager() {
            return [31001, 31002].includes(+this.info.source)
        },
        isOtherCompleted() {
            return !!(this.info.current_residence_country && this.info.current_address && (this.info.sub_profession || this.info.profession !== "") && this.info.tax_status && this.info.email)
        },
        isInvestorEffective() {
            return this.info.investor_type !== 0 && this.info.investor_auth_expire_flag === 0
        },
        isManagementEffective() {
            return this.info.management_type !== 0 && this.info.management_auth_expire_flag === 0
        },
        sex() {
            return ["未知", "男", "女"][this.info.sex] || ""
        },
        infoLabel() {
            const e = this.info.evaluation_result;
            return +this.info.quiz_id == 27 ? `C5 - ${{
                1: "稳健型",
                2: "成长型",
                3: "进取型"
            }[e]}` : `C${e === 0 ? 1 : e} - ${{
                0: "风险承受能力最低类别",
                1: "保守型",
                2: "稳健型",
                3: "平衡型",
                4: "成长型",
                5: "进取型"
            }[e]}`
        },
        evaluationLabel() {
            const e = this.investorInfo.evaluation_result;
            return e === void 0 ? "" : e === -1 ? "未测评" : +this.info.quiz_id == 27 ? `C5 - ${{
                1: "稳健型",
                2: "成长型",
                3: "进取型"
            }[e]}` : `C${e === 0 ? 1 : e} - ${{
                0: "风险承受能力最低类别",
                1: "保守型",
                2: "稳健型",
                3: "平衡型",
                4: "成长型",
                5: "进取型"
            }[e]}`
        },
        evaluationTip() {
            return this.info.quiz_id !== 27 ? {
                0: "适合您的基金产品风险等级为：R1",
                1: "适合您的基金产品风险等级为：R1",
                2: "适合您的基金产品风险等级为：R1~R2",
                3: "适合您的基金产品风险等级为：R1~R3",
                4: "适合您的基金产品风险等级为：R1~R4",
                5: "适合您的基金产品风险等级为：R1~R5"
            }[this.investorInfo.evaluation_result] : "适合购买R5及以下级别的基金产品"
        },
        cardTypeLabel() {
            switch (+this.info.card_type) {
            case 1:
                return "身份证";
            case 3:
                return "护照/非大陆居民";
            case 5:
                return "台湾居民来往大陆通行证";
            case 9:
                return "港澳居民来往大陆通行证";
            case -1:
                return "其他";
            default:
                return ""
            }
        }
    }
})
  , record_user_cookie_client_deCstwNrmv = defineNuxtPlugin({
    name: "record-user-cookie",
    setup() {
        useEnvStore().isMiniProgram || (useUserStore().token = useCookie("http_tK_cache", {
            domain: ".simuwang.com",
            readonly: !0
        }).value)
    }
})
  , pageview_reporter_client_6LZSghv3rL = defineNuxtPlugin({
    name: "pageview-reporter",
    parallel: !0,
    setup() {
        let e = {
            disableReport: !1
        }
          , t = !0;
        const r = new MutationObserver( () => {
            let o = e.disableReport;
            typeof o == "function" && (o = o()),
            !o && !useError().value && !t && (t = !0,
            uXpReport("pageview", {
                item_name: document.title
            }))
        }
        )
          , n = () => {
            try {
                n.hasSet || (r.observe(document.querySelector("title"), {
                    childList: !0
                }),
                n.hasSet = !0)
            } catch (o) {
                console.warn(`[pageview-reporter]title标签不存在${o}`)
            }
        }
        ;
        n.hasSet = !1,
        n(),
        addRouteMiddleware("pageview-report", o => {
            e = o.meta,
            t = !1,
            n()
        }
        , {
            global: !0
        })
    }
})
  , cookie_recorder_client_nH2YMH4ifC = defineNuxtPlugin({
    name: "cookie-recorder",
    parallel: !0,
    setup() {
        function e(g, _) {
            if (_) {
                const b = useCookie(g, {
                    maxAge: 86400,
                    path: "/",
                    domain: location.href.includes("ppwfund.com") ? ".ppwfund.com" : ".simuwang.com",
                    secure: !1
                });
                b.value = _
            }
        }
        const t = useUrlSearchParams("history")
          , r = parseInt(t.utm_source);
        r > 0 && e("rz_utm_source", r);
        const n = t.utm_campaign
          , o = t.utm_sign
          , a = t.utm_platform
          , s = t.utm_term
          , i = t.utm_content
          , l = t.inviter_key
          , u = t.bd_vid
          , c = t.sg_vid
          , f = t.clickid
          , d = t.uctrackid
          , p = t.qhclickid
          , m = t.utm_medium;
        e("ss_utm_campaign", n),
        e("ss_utm_sign", o),
        e("ss_utm_platform", a),
        e("ss_utm_term", s),
        e("ss_utm_content", i),
        e("utm_medium", m),
        u != null && u !== "" && (e("ss_bd_vid", u),
        e("ss_bd_login_url", location.href)),
        c && e("ss_sg_login_url", location.href),
        f && e("ss_clickid", f),
        e("inviter_key", l),
        d != null && d !== "" && e("ss_urtrack_url", location.href),
        e("ss_qhclickid", p)
    }
})
  , directives_guLw4sRoxc = defineNuxtPlugin(e => {
    e.vueApp.directive("profit", {
        mounted: profitHandler,
        updated: profitHandler,
        getSSRProps() {
            return {}
        }
    }),
    e.vueApp.directive("userCheck", {
        mounted(t, r) {
            let n = !1;
            t.addEventListener("click", o => {
                n || (o.stopPropagation(),
                o.preventDefault()),
                userCheck({
                    onlyCheck: !1,
                    onlyLogin: r.modifiers.login ?? !1
                }, () => {
                    n = !0,
                    r.value()
                }
                )
            }
            , !0)
        },
        getSSRProps() {
            return {}
        }
    }),
    e.vueApp.directive("defImg", {
        mounted: imgHandler,
        getSSRProps() {
            return {}
        }
    }),
    e.vueApp.directive("intersectionObserver", {
        ...intersectionObserver,
        getSSRProps() {
            return {}
        }
    }),
    e.vueApp.directive("resizeObserver", {
        ...resizeObserverDirective,
        getSSRProps() {
            return {}
        }
    }),
    e.vueApp.directive("visible", {
        ...visibleDirective,
        getSSRProps(t) {
            const r = {
                visibility: t.value ? "visible" : "hidden"
            };
            return t.modifiers.opacity && (r.opacity = t.value ? "1" : "0"),
            {
                style: r
            }
        }
    }),
    e.vueApp.directive("noncopyable", {
        mounted(t) {
            t.addEventListener("copy", r => r.preventDefault()),
            t.addEventListener("contextmenu", r => r.preventDefault()),
            t.addEventListener("selectstart", r => r.preventDefault())
        },
        getSSRProps() {
            return {}
        }
    })
}
)
  , auto_login_client_djXVhz91IK = defineNuxtPlugin({
    name: "auto-login",
    parallel: !0,
    setup() {
        const e = useCookie("rz_rem_u_p", {
            domain: ".simuwang.com"
        });
        e.value && !useEnvStore().fromApp && !useEnvStore().fromWeApp ? until(computed( () => useUserStore().loginStatus)).not.toBe("waiting").then( () => {
            useUserStore().loginStatus === "undone" && e.value ? autoLogin().then( ({data: t, status: r}) => {
                [1, 100].includes(r) ? uXpReport("login", {
                    userid: t.userid
                }).finally( () => location.reload()) : (e.value = null,
                useUserStore().autologinDone = !0)
            }
            ) : useUserStore().autologinDone = !0
        }
        ) : useUserStore().autologinDone = !0
    }
})
  , on_load_client_hltbrSGs5D = defineNuxtPlugin(async () => {
    let e, t;
    addRouteMiddleware("user-check", r => {
        !r.meta.disableUserCheck && !useError().value && userCheck({
            onlyCheck: !1
        })
    }
    , {
        global: !0
    }),
    onNuxtReady( () => {
        useUserStore().getUserInfo(),
        useTimStore().getUserInfo()
    }
    ),
    useXpMount2body(([e,t] = executeAsync( () => __vitePreload( () => import("./GcsWccdl.js"), __vite__mapDeps([139, 45, 2, 3, 46, 1, 4, 83, 84, 30, 31, 13, 32, 21, 108, 109, 18, 19, 120, 64, 33, 34, 140]), import.meta.url)),
    e = await e,
    t(),
    e).default),
    useXpMount2body(([e,t] = executeAsync( () => __vitePreload( () => import("./CKKMvVcK.js"), __vite__mapDeps([141, 45, 2, 3, 46, 142]), import.meta.url)),
    e = await e,
    t(),
    e).default),
    addRouteMiddleware("route-check", () => {
        ["simuwang.com", "ppwfund.com"].includes(location.host) && (location.href = location.protocol + "//www." + location.hostname + location.pathname + location.search)
    }
    , {
        global: !0
    })
}
)
  , plugins = [payloadPlugin, revive_payload_client_SjK25sGxMS, unhead_pUDVp0zH3P, plugin$1, payload_client_lPSv2tCcmY, navigation_repaint_client_h7iwmAtPle, check_outdated_build_client_uUlFLFLDzj, chunk_reload_client_v4j2JHeOxa, plugin, components_plugin_KR1HBZs4kY, prefetch_client_i4jq2g8RpK, element_plus_teleports_plugin_h4Dmekbj62, element_plus_injection_plugin_1RNPi6ogby, plugin_wy0B721ODc, unocss_MzCDxu9LMj, _01_pc_mobile_redirect_TYARZqG7C1, record_user_cookie_client_deCstwNrmv, pageview_reporter_client_6LZSghv3rL, cookie_recorder_client_nH2YMH4ifC, directives_guLw4sRoxc, auto_login_client_djXVhz91IK, on_load_client_hltbrSGs5D]
  , RouteProvider = defineComponent({
    props: {
        vnode: {
            type: Object,
            required: !0
        },
        route: {
            type: Object,
            required: !0
        },
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean
    },
    setup(e) {
        const t = e.renderKey
          , r = e.route
          , n = {};
        for (const o in e.route)
            Object.defineProperty(n, o, {
                get: () => t === e.renderKey ? e.route[o] : r[o],
                enumerable: !0
            });
        return provide(PageRouteSymbol, shallowReactive(n)),
        () => h(e.vnode, {
            ref: e.vnodeRef
        })
    }
})
  , __nuxt_component_0 = defineComponent({
    name: "NuxtPage",
    inheritAttrs: !1,
    props: {
        name: {
            type: String
        },
        transition: {
            type: [Boolean, Object],
            default: void 0
        },
        keepalive: {
            type: [Boolean, Object],
            default: void 0
        },
        route: {
            type: Object
        },
        pageKey: {
            type: [Function, String],
            default: null
        }
    },
    setup(e, {attrs: t, slots: r, expose: n}) {
        const o = useNuxtApp()
          , a = ref()
          , s = inject(PageRouteSymbol, null);
        let i;
        n({
            pageRef: a
        });
        const l = inject(LayoutMetaSymbol, null);
        let u;
        const c = o.deferHydration();
        if (o.isHydrating) {
            const f = o.hooks.hookOnce("app:error", c);
            useRouter().beforeEach(f)
        }
        return e.pageKey && watch( () => e.pageKey, (f, d) => {
            f !== d && o.callHook("page:loading:start")
        }
        ),
        () => h(RouterView, {
            name: e.name,
            route: e.route,
            ...t
        }, {
            default: f => {
                const d = haveParentRoutesRendered(s, f.route, f.Component)
                  , p = s && s.matched.length === f.route.matched.length;
                if (!f.Component) {
                    if (u && !p)
                        return u;
                    c();
                    return
                }
                if (u && l && !l.isCurrent(f.route))
                    return u;
                if (d && s && (!l || l != null && l.isCurrent(s)))
                    return p ? u : null;
                const m = generateRouteKey$1(f, e.pageKey);
                !o.isHydrating && !hasChildrenRoutes(s, f.route, f.Component) && i === m && o.callHook("page:loading:end"),
                i = m;
                const g = !!(e.transition ?? f.route.meta.pageTransition ?? appPageTransition)
                  , _ = g && _mergeTransitionProps([e.transition, f.route.meta.pageTransition, appPageTransition, {
                    onAfterLeave: () => {
                        o.callHook("page:transition:finish", f.Component)
                    }
                }].filter(Boolean))
                  , b = e.keepalive ?? f.route.meta.keepalive ?? appKeepalive;
                return u = _wrapIf(Transition, g && _, wrapInKeepAlive(b, h(Suspense, {
                    suspensible: !0,
                    onPending: () => o.callHook("page:start", f.Component),
                    onResolve: () => {
                        nextTick( () => o.callHook("page:finish", f.Component).then( () => o.callHook("page:loading:end")).finally(c))
                    }
                }, {
                    default: () => {
                        const y = h(RouteProvider, {
                            key: m || void 0,
                            vnode: r.default ? h(Fragment, void 0, r.default(f)) : f.Component,
                            route: f.route,
                            renderKey: m || void 0,
                            trackRootNodes: g,
                            vnodeRef: a
                        });
                        return b && (y.type.name = f.Component.type.name || f.Component.type.__name || "RouteProvider"),
                        y
                    }
                }))).default(),
                u
            }
        })
    }
});
function _mergeTransitionProps(e) {
    const t = e.map(r => ({
        ...r,
        onAfterLeave: r.onAfterLeave ? toArray(r.onAfterLeave) : void 0
    }));
    return defu(...t)
}
function haveParentRoutesRendered(e, t, r) {
    if (!e)
        return !1;
    const n = t.matched.findIndex(o => {
        var a;
        return ((a = o.components) == null ? void 0 : a.default) === (r == null ? void 0 : r.type)
    }
    );
    return !n || n === -1 ? !1 : t.matched.slice(0, n).some( (o, a) => {
        var s, i, l;
        return ((s = o.components) == null ? void 0 : s.default) !== ((l = (i = e.matched[a]) == null ? void 0 : i.components) == null ? void 0 : l.default)
    }
    ) || r && generateRouteKey$1({
        route: t,
        Component: r
    }) !== generateRouteKey$1({
        route: e,
        Component: r
    })
}
function hasChildrenRoutes(e, t, r) {
    return e ? t.matched.findIndex(o => {
        var a;
        return ((a = o.components) == null ? void 0 : a.default) === (r == null ? void 0 : r.type)
    }
    ) < t.matched.length - 1 : !1
}
const LayoutLoader = defineComponent({
    name: "LayoutLoader",
    inheritAttrs: !1,
    props: {
        name: String,
        layoutProps: Object
    },
    async setup(e, t) {
        const r = await layouts[e.name]().then(n => n.default || n);
        return () => h(r, e.layoutProps, t.slots)
    }
})
  , __nuxt_component_1 = defineComponent({
    name: "NuxtLayout",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean, Object],
            default: null
        },
        fallback: {
            type: [String, Object],
            default: null
        }
    },
    setup(e, t) {
        const r = useNuxtApp()
          , n = inject(PageRouteSymbol)
          , o = n === useRoute$1() ? useRoute() : n
          , a = computed( () => {
            let l = unref(e.name) ?? o.meta.layout ?? "default";
            return l && !(l in layouts) && e.fallback && (l = unref(e.fallback)),
            l
        }
        )
          , s = ref();
        t.expose({
            layoutRef: s
        });
        const i = r.deferHydration();
        if (r.isHydrating) {
            const l = r.hooks.hookOnce("app:error", i);
            useRouter().beforeEach(l)
        }
        return () => {
            const l = a.value && a.value in layouts
              , u = o.meta.layoutTransition ?? appLayoutTransition;
            return _wrapIf(Transition, l && u, {
                default: () => h(Suspense, {
                    suspensible: !0,
                    onResolve: () => {
                        nextTick(i)
                    }
                }, {
                    default: () => h(LayoutProvider, {
                        layoutProps: mergeProps(t.attrs, {
                            ref: s
                        }),
                        key: a.value || void 0,
                        name: a.value,
                        shouldProvide: !e.name,
                        hasTransition: !!u
                    }, t.slots)
                })
            }).default()
        }
    }
})
  , LayoutProvider = defineComponent({
    name: "NuxtLayoutProvider",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean]
        },
        layoutProps: {
            type: Object
        },
        hasTransition: {
            type: Boolean
        },
        shouldProvide: {
            type: Boolean
        }
    },
    setup(e, t) {
        const r = e.name;
        return e.shouldProvide && provide(LayoutMetaSymbol, {
            isCurrent: n => r === (n.meta.layout ?? "default")
        }),
        () => {
            var n, o;
            return !r || typeof r == "string" && !(r in layouts) ? (o = (n = t.slots).default) == null ? void 0 : o.call(n) : h(LayoutLoader, {
                key: r,
                layoutProps: e.layoutProps,
                name: r
            }, t.slots)
        }
    }
});
/*! Element Plus v2.8.7 */
var zhCn = {
    name: "zh-cn",
    el: {
        breadcrumb: {
            label: "面包屑"
        },
        colorpicker: {
            confirm: "确定",
            clear: "清空",
            defaultLabel: "颜色选择器",
            description: "当前颜色 {color}，按 Enter 键选择新颜色",
            alphaLabel: "选择透明度的值"
        },
        datepicker: {
            now: "此刻",
            today: "今天",
            cancel: "取消",
            clear: "清空",
            confirm: "确定",
            dateTablePrompt: "使用方向键与 Enter 键可选择日期",
            monthTablePrompt: "使用方向键与 Enter 键可选择月份",
            yearTablePrompt: "使用方向键与 Enter 键可选择年份",
            selectedDate: "已选日期",
            selectDate: "选择日期",
            selectTime: "选择时间",
            startDate: "开始日期",
            startTime: "开始时间",
            endDate: "结束日期",
            endTime: "结束时间",
            prevYear: "前一年",
            nextYear: "后一年",
            prevMonth: "上个月",
            nextMonth: "下个月",
            year: "年",
            month1: "1 月",
            month2: "2 月",
            month3: "3 月",
            month4: "4 月",
            month5: "5 月",
            month6: "6 月",
            month7: "7 月",
            month8: "8 月",
            month9: "9 月",
            month10: "10 月",
            month11: "11 月",
            month12: "12 月",
            weeks: {
                sun: "日",
                mon: "一",
                tue: "二",
                wed: "三",
                thu: "四",
                fri: "五",
                sat: "六"
            },
            weeksFull: {
                sun: "星期日",
                mon: "星期一",
                tue: "星期二",
                wed: "星期三",
                thu: "星期四",
                fri: "星期五",
                sat: "星期六"
            },
            months: {
                jan: "一月",
                feb: "二月",
                mar: "三月",
                apr: "四月",
                may: "五月",
                jun: "六月",
                jul: "七月",
                aug: "八月",
                sep: "九月",
                oct: "十月",
                nov: "十一月",
                dec: "十二月"
            }
        },
        inputNumber: {
            decrease: "减少数值",
            increase: "增加数值"
        },
        select: {
            loading: "加载中",
            noMatch: "无匹配数据",
            noData: "无数据",
            placeholder: "请选择"
        },
        dropdown: {
            toggleDropdown: "切换下拉选项"
        },
        mention: {
            loading: "加载中"
        },
        cascader: {
            noMatch: "无匹配数据",
            loading: "加载中",
            placeholder: "请选择",
            noData: "暂无数据"
        },
        pagination: {
            goto: "前往",
            pagesize: "条/页",
            total: "共 {total} 条",
            pageClassifier: "页",
            page: "页",
            prev: "上一页",
            next: "下一页",
            currentPage: "第 {pager} 页",
            prevPages: "向前 {pager} 页",
            nextPages: "向后 {pager} 页",
            deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
        },
        dialog: {
            close: "关闭此对话框"
        },
        drawer: {
            close: "关闭此对话框"
        },
        messagebox: {
            title: "提示",
            confirm: "确定",
            cancel: "取消",
            error: "输入的数据不合法!",
            close: "关闭此对话框"
        },
        upload: {
            deleteTip: "按 delete 键可删除",
            delete: "删除",
            preview: "查看图片",
            continue: "继续上传"
        },
        slider: {
            defaultLabel: "滑块介于 {min} 至 {max}",
            defaultRangeStartLabel: "选择起始值",
            defaultRangeEndLabel: "选择结束值"
        },
        table: {
            emptyText: "暂无数据",
            confirmFilter: "筛选",
            resetFilter: "重置",
            clearFilter: "全部",
            sumText: "合计"
        },
        tour: {
            next: "下一步",
            previous: "上一步",
            finish: "结束导览"
        },
        tree: {
            emptyText: "暂无数据"
        },
        transfer: {
            noMatch: "无匹配数据",
            noData: "无数据",
            titles: ["列表 1", "列表 2"],
            filterPlaceholder: "请输入搜索内容",
            noCheckedFormat: "共 {total} 项",
            hasCheckedFormat: "已选 {checked}/{total} 项"
        },
        image: {
            error: "加载失败"
        },
        pageHeader: {
            title: "返回"
        },
        popconfirm: {
            confirmButtonText: "确定",
            cancelButtonText: "取消"
        },
        carousel: {
            leftArrow: "上一张幻灯片",
            rightArrow: "下一张幻灯片",
            indicator: "幻灯片切换至索引 {index}"
        }
    }
};
const _sfc_main$2 = defineComponent({
    __name: "app",
    setup(e) {
        const t = useMounted();
        return (r, n) => {
            const o = __nuxt_component_0
              , a = __nuxt_component_1
              , s = ElConfigProvider
              , i = resolveDirective("visible");
            return openBlock(),
            createBlock(s, {
                locale: unref(zhCn)
            }, {
                default: withCtx( () => [withDirectives((openBlock(),
                createElementBlock("aside", null, [createVNode(a, null, {
                    default: withCtx( () => [createVNode(o)]),
                    _: 1
                })])), [[i, unref(t)]])]),
                _: 1
            }, 8, ["locale"])
        }
    }
});
function useXpDialogShow(e, t=!1) {
    const r = ref(t);
    return [r, (...a) => {
        r.value = !0
    }
    , () => {
        r.value = !1
    }
    ]
}
function useXpNavInit(e, t=0) {
    return reactive({
        list: e,
        active: t
    })
}
async function useXpCacheRequest(e, t, r) {
    const n = JSON.stringify(r);
    let o;
    return e.value[n] ? o = e.value[n] : o = await t(r).then( ({data: a}) => (e.value[n] = a,
    e.value[n])),
    o
}
function useXpSeo(e) {
    useHead({
        title: e.title,
        meta: [e.description !== void 0 && {
            name: "description",
            content: e.description,
            tagPriority: uXpSeoPriority.DK
        }, e.keywords !== void 0 && {
            name: "keywords",
            content: e.keywords,
            tagPriority: uXpSeoPriority.DK
        }].filter(Boolean)
    })
}
const _hoisted_1$1 = {
    class: "page-error"
}
  , _hoisted_2 = {
    class: "flex-col flex-ic pt-40 pb-80"
}
  , _hoisted_3 = ["src"]
  , _hoisted_4 = {
    class: "text-black text-26 lh-44px mt-30"
}
  , _sfc_main$1 = defineComponent({
    __name: "error",
    props: {
        error: {}
    },
    setup(e) {
        useXpSeo({
            title: "错误页面-私募排排网",
            description: "",
            keywords: ""
        });
        const t = computed( () => {
            try {
                return JSON.parse(e.error.data)
            } catch {
                return {}
            }
        }
        )
          , r = () => clearError({
            redirect: "/"
        })
          , n = () => useRouter().back()
          , o = computed( () => t.value.message ? t.value.message : e.error.statusCode === 404 ? "Sorry 您要访问的页面不小心弄丢了" : "出现一点小错误，请稍后重试")
          , a = computed( () => {
            switch (t.value.type) {
            case "product":
                return {
                    href: uXpFundIs(t.value.id, "pub") ? "/jjpm" : "/",
                    name: "查看更多基金排名"
                };
            default:
                return
            }
        }
        );
        return onMounted( () => {
            console.error(e.error.message, e.error)
        }
        ),
        (s, i) => {
            const l = arrow_right_default
              , u = __nuxt_component_5;
            return openBlock(),
            createElementBlock("div", _hoisted_1$1, [createBaseVNode("section", _hoisted_2, [createBaseVNode("img", {
                src: ("uXpStatic"in s ? s.uXpStatic : unref(uXpStatic))("/image/index/404.svg")
            }, null, 8, _hoisted_3), createBaseVNode("p", _hoisted_4, toDisplayString(unref(o)), 1), createBaseVNode("div", {
                class: "flex-jc gap-24 mt-40"
            }, [createBaseVNode("button", {
                class: "border-1 border-solid border-red c-red",
                onClick: r
            }, "返回首页"), createBaseVNode("button", {
                class: "bg-red c-white",
                onClick: n
            }, "回上一页")]), unref(a) ? (openBlock(),
            createBlock(u, {
                key: 0,
                class: "c-blue mt-50",
                to: unref(a).href,
                replace: ""
            }, {
                default: withCtx( () => [createTextVNode(toDisplayString(unref(a).name) + " ", 1), createVNode(l, {
                    class: "w-10 h-12"
                })]),
                _: 1
            }, 8, ["to"])) : createCommentVNode("", !0)])])
        }
    }
})
  , _export_sfc = (e, t) => {
    const r = e.__vccOpts || e;
    for (const [n,o] of t)
        r[n] = o;
    return r
}
  , ErrorComponent = _export_sfc(_sfc_main$1, [["__scopeId", "data-v-aa4f6739"]])
  , _hoisted_1 = {
    key: 0
}
  , _sfc_main = {
    __name: "nuxt-root",
    setup(e) {
        const t = () => null
          , r = useNuxtApp()
          , n = r.deferHydration();
        if (r.isHydrating) {
            const l = r.hooks.hookOnce("app:error", n);
            useRouter().beforeEach(l)
        }
        const o = !1;
        provide(PageRouteSymbol, useRoute$1()),
        r.hooks.callHookWith(l => l.map(u => u()), "vue:setup");
        const a = useError()
          , s = !1;
        onErrorCaptured( (l, u, c) => {
            if (r.hooks.callHook("vue:error", l, u, c).catch(f => console.error("[nuxt] Error in `vue:error` hook", f)),
            isNuxtError(l) && (l.fatal || l.unhandled))
                return r.runWithContext( () => showError(l)),
                !1
        }
        );
        const i = !1;
        return (l, u) => (openBlock(),
        createBlock(Suspense, {
            onResolve: unref(n)
        }, {
            default: withCtx( () => [unref(s) ? (openBlock(),
            createElementBlock("div", _hoisted_1)) : unref(a) ? (openBlock(),
            createBlock(unref(ErrorComponent), {
                key: 1,
                error: unref(a)
            }, null, 8, ["error"])) : unref(i) ? (openBlock(),
            createBlock(unref(t), {
                key: 2,
                context: unref(i)
            }, null, 8, ["context"])) : unref(o) ? (openBlock(),
            createBlock(resolveDynamicComponent(unref(o)), {
                key: 3
            })) : (openBlock(),
            createBlock(unref(_sfc_main$2), {
                key: 4
            }))]),
            _: 1
        }, 8, ["onResolve"]))
    }
};
let entry;
{
    let e;
    entry = async function() {
        var s, i;
        if (e)
            return e;
        const n = !!(((s = window.__NUXT__) == null ? void 0 : s.serverRendered) ?? ((i = document.getElementById("__NUXT_DATA__")) == null ? void 0 : i.dataset.ssr) === "true") ? createSSRApp(_sfc_main) : createApp(_sfc_main)
          , o = createNuxtApp({
            vueApp: n
        });
        async function a(l) {
            await o.callHook("app:error", l),
            o.payload.error = o.payload.error || createError(l)
        }
        n.config.errorHandler = a;
        try {
            await applyPlugins(o, plugins)
        } catch (l) {
            a(l)
        }
        try {
            await o.hooks.callHook("app:created", n),
            await o.hooks.callHook("app:beforeMount", n),
            n.mount(vueAppRootContainer),
            await o.hooks.callHook("app:mounted", n),
            await nextTick()
        } catch (l) {
            a(l)
        }
        return n.config.errorHandler === a && (n.config.errorHandler = void 0),
        n
    }
    ,
    e = entry().catch(t => {
        throw console.error("Error while mounting app:", t),
        t
    }
    )
}
export {d_arrow_left_default as $, isString$1 as A, getScrollContainer as B, _export_sfc as C, useTimStore as D, ElIcon as E, ElMessage as F, uXsMessageBox as G, modifyGroupData as H, deleteGroupMember as I, ElInput as J, ElButton as K, commonjsGlobal as L, getDefaultExportFromCjs as M, uXpFetch as N, useUserStore as O, uXpConfig as P, isNaN$1 as Q, getGroupInfo as R, DefAvatar as S, getWelcomeMsgList as T, getGroupSubjectApply as U, cloneDeep as V, sendTextMessage as W, getSuperInfo as X, getManagerAgentInfo as Y, useCookie as Z, _export_sfc$1 as _, useNamespace as a, useFormSize as a$, useRoute$1 as a0, getChatListByPN as a1, getIMsignature as a2, __vitePreload as a3, getGroupInviteList as a4, getViewList as a5, bell_default as a6, arrow_down_default as a7, __nuxt_component_5 as a8, getCustomerService as a9, getGroupList as aA, getCollection as aB, getShelfSaleSelect as aC, useXpUserDone as aD, getSunRelationManager as aE, uXpProductIsValid as aF, useElementHover as aG, search_default as aH, navigateTo as aI, decodeNav as aJ, getManagerInfo as aK, uXsAppoint as aL, uXsWxService as aM, getShelfFundList as aN, uXpStaticPriStrategyL1 as aO, uXpStaticPriIndex as aP, iconPropType as aQ, withNoopInstall as aR, useSizeProp as aS, useAriaProps as aT, UPDATE_MODEL_EVENT as aU, INPUT_EVENT as aV, CHANGE_EVENT as aW, useFormItem as aX, throwError as aY, debugWarn as aZ, useFormItemInputId as a_, getTotalUserPC as aa, userCheck as ab, uXsAuth as ac, arrow_down_bold_default as ad, getAnnounceDetail as ae, useDateFormat as af, watchImmediate as ag, caret_bottom_default as ah, caret_top_default as ai, uXpReport as aj, uXpProfitClass as ak, createError as al, useXpSeo as am, useHead as an, uXpBaiduDateScript as ao, useNow as ap, uXpDateMeta as aq, postWebIMReport as ar, useXsReportGJFX as as, uXpStaticCompareList as at, uXpProfitValue as au, uXpIsEmpty as av, uXpIsNumber as aw, createReusableTemplate as ax, useDebounceFn$1 as ay, uXpFundIs as az, buildProps as b, circle_check_default as b$, uXpProductIsShare as b0, postApplyNav as b1, uXsRoutes as b2, uXpProductIsNavGuidance as b3, uXpWorkTime as b4, uXpProductCLRQKeyName as b5, uXpProductIsLiquidated as b6, useMounted as b7, uXpProductBuyProcess as b8, watchDeep as b9, useScriptTag as bA, uXpStatic as bB, useMemoize as bC, useElementSize as bD, useEventListener$1 as bE, isNumber$2 as bF, isArray$5 as bG, uXpProductRiskMismatch as bH, signRiskApply as bI, useXpDialogShow as bJ, uXsP2PApply as bK, useXpNavInit as bL, tradingRules as bM, useInfiniteScroll as bN, profitProbability as bO, assetSizeList as bP, getPubAssetSize as bQ, holderStructure as bR, arrow_up_default as bS, top_default as bT, bottom_default as bU, pubFundHolding as bV, holdingDate as bW, announceList as bX, uXpProductPubBuyLimitCalc as bY, pubDistributionList as bZ, uXsMessage as b_, calendar_default as ba, uXpFormatDateToZero as bb, uXpProductScale as bc, uXsAssetsExchange as bd, useState as be, getFundScale as bf, useXpCacheRequest as bg, getNavMissingDate as bh, getPriNavData as bi, uXpProductNAVSize as bj, getPubNavData as bk, getBonus as bl, uXpProductIsZG as bm, uXpProductDefaultRival as bn, uXpProductEarlierDate as bo, getProfitRiskIndicators as bp, getOldProfitRisk as bq, useWindowSize as br, buySellRateRule as bs, warning_default as bt, getFundSameStrategyRandomList as bu, dayjs as bv, until as bw, uXpStaticOverProfitList as bx, getRangeGain as by, rongzhiTrend as bz, useZIndex as c, useDevice as c$, checkGroup as c0, createGroup as c1, getSuperQuestionList as c2, uXsCopy2Favor as c3, isPrototype as c4, isArrayLike as c5, copyObject as c6, keys as c7, assignValue as c8, keysIn as c9, info_filled_default as cA, d_arrow_right_default as cB, arrow_left_bold_default as cC, useVModel as cD, circle_close_filled_default as cE, useScroll as cF, useElementBounding as cG, uXpProductIsSale as cH, arrow_right_bold_default as cI, uXpStaticPubStrategyL2 as cJ, useMutationObserver as cK, isNil as cL, isUndefined as cM, useFormDisabled as cN, minus_default as cO, plus_default as cP, componentSizes as cQ, more_filled_default as cR, useGlobalSize as cS, useDeprecated as cT, uXpStaticPriStrategyL2 as cU, uXpStaticPriStrategyL3 as cV, uXpStaticGetStrategy as cW, useId as cX, addUnit as cY, FOCUS_TRAP_INJECTION_KEY as cZ, isFunction as c_, baseGet as ca, castPath as cb, toKey as cc, flatRest as cd, arrayMap as ce, getAllKeysIn as cf, baseClone as cg, getCollectionStatus as ch, uXpCollectType as ci, uXpThisIdIs as cj, postViewLog as ck, uXsDownload as cl, reactiveComputed as cm, question_filled_default as cn, useXpMount2body as co, useLocalStorage as cp, pick as cq, uXpProductIsP2PApplicable as cr, arrow_up_bold_default as cs, uXpStaticPriStrategy as ct, uXpStaticPubStrategy as cu, uXpProductRiskLevel as cv, view_default as cw, watchOnce as cx, uXpDomQs as cy, useIntersectionObserver as cz, definePropType as d, uXsUnreceivedCodeTips as d$, getPriProductPageDetail as d0, getPubProductPageDetail as d1, useEnvStore as d2, uXpProductFeeCalc as d3, useTimestamp as d4, watchDebounced as d5, uXpStaticPriPPW as d6, uXpStaticNavFlagList as d7, uXpProductLegendVisible as d8, getFundPNR as d9, isPropAbsent as dA, useNuxtApp as dB, asyncDataDefaults as dC, getSunFundInfo as dD, getPubFundInfo as dE, getPubRelationManager as dF, toggleCollection as dG, useSessionStorage as dH, toReactive as dI, uXsLogin as dJ, logout as dK, defineStore as dL, close_bold_default as dM, extendRef as dN, uXsGJFXPreCheck as dO, uXpProductShowShortTip as dP, hide_default as dQ, ElMessageBox as dR, scanBind as dS, scanRegBind as dT, loginWithSms as dU, loginWithPwd as dV, sendSms as dW, setPassword as dX, uXpGreeting as dY, wxQRCode as dZ, checkScanResult as d_, isObject$2 as da, uXpCallBySex as db, isEmpty as dc, isDate$1 as dd, circle_close_default as de, useEmptyValuesProps as df, useFocusController as dg, useEmptyValues as dh, clock_default as di, onClickOutside as dj, NOOP as dk, unrefElement as dl, getStyle as dm, flatten as dn, hasClass as dp, isObject as dq, get as dr, useResizeObserver as ds, useComposition as dt, ValidateComponentsMap as du, isIOS as dv, toRawType as dw, scrollIntoView as dx, uXpTypeJud as dy, isBoolean$1 as dz, close_default as e, getTag as e$, authIdentity as e0, submitQualifiedInvestor as e1, uXpStaticCustomerRiskLevel as e2, getRiskQuestionList as e3, uXsFetchCatch as e4, submitRiskResult as e5, syncRiskResult as e6, baseFlatten as e7, hasOwn$2 as e8, addClass as e9, onClickOutside$1 as eA, moveFund as eB, success_filled_default as eC, uXpProductIsMonetary as eD, withInstallDirective as eE, useDraggable as eF, CloseComponents as eG, useGlobalConfig as eH, defaultNamespace as eI, useLockscreen as eJ, useTimeoutFn as eK, ElOverlay as eL, ElFocusTrap as eM, useSameTarget as eN, isSymbol$1 as eO, root as eP, getFragmentHTML as eQ, buildProp as eR, tryOnScopeDispose as eS, useGetDerivedNamespace as eT, useIdInjection as eU, isFocusable as eV, formItemContextKey as eW, MapCache as eX, Symbol$1 as eY, Uint8Array$1 as eZ, getAllKeys as e_, removeClass as ea, getProp as eb, loading_default as ec, useGlobalComponentSettings as ed, hyphenate as ee, Stack as ef, isKey as eg, hasIn as eh, identity$1 as ei, setToString as ej, overRest as ek, isIndex as el, eq as em, isObjectLike as en, baseGetTag as eo, getPrototype as ep, baseAssignValue as eq, isBuffer$1 as er, isTypedArray as es, copyArray as et, cloneBuffer as eu, cloneTypedArray as ev, isArguments as ew, isFunction$1 as ex, initCloneObject as ey, postAddGroup as ez, full_screen_default as f, transparentAvatar as f0, formContextKey as f1, refDebounced as f2, useUserExtendStore as f3, applyP2P as f4, uXpStaticFOFEmailURL as f5, caret_right_default as f6, expand_default as f7, fold_default as f8, arrow_left_default as g, arrow_right_default as h, isNumber$1 as i, zoom_in_default as j, refresh_right_default as k, EVENT_CODE as l, mutable as m, useEventListener as n, keysOf as o, fromPairs as p, useAttrs as q, refresh_left_default as r, scale_to_original_default as s, isClient as t, useLocale as u, isArray$4 as v, withInstall as w, useThrottleFn as x, isElement$1 as y, zoom_out_default as z};
